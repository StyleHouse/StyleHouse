# Picturity
   // modulat
    me.scroll = &acgts{
        s&mh = s;
        s&over = 1
    }
    # in-modulat &nu
    me.mnu = &acgtgts{
        $nu = me&nu,t,s;
        nus&ope = 1;
        me&zN,nu;
        me&zuct,g,nu;
    };
   // pi f
    # selective ex, removing
    #  as in consuming arguments from a c
    window.tax = &s,take,c{
        !c and return s
        !isha(s) || isC(s) || !isha(c) || isC(c) and throw "tax"
        isst(take) and take = G&peel,take
        else
        isar(take) and throw "{map{k:1}take}"
        each k,remove take {
            !hak(c,k) and continue
            remove and s[k] = delete c[k]
            else { s[k] = c[k] }
        }
        return s
    }
    # "$t1-$t2" for [C,C,C{.t==not}]
    window.joint = &N,join,not{
        # ioty may N=C/*
        $M = me&ioty,N .map(n => isC(n) ? n.t : n)
            .filter(t => t != null && (not == null || t != not))
        $s = M.shift()
        join ||= '-'
        each in M {
            # leading joiner-ish thing
            n.startsWith('<'+join) and s += n
            else { s += join+n }
        }
        return s
    }
    window.defor = &sc{
        return s != null ? s : c
    }
    # y(k,v) for s
    window.hav = &sy{
        return haks(s).map(k => y(s[k],k))
    }
    # create a -pi on a node
    me.Api = &acgtstc{
        !isst(t) and throw "which -pi"
        # takes c.t (< etc) into a new c
        c = tax({},'t',c)
        c.el = 2
        $b = s.y [t]
        $E = s.y [t] = Cye([defor(c.t,s.t),1,{pi:t}])
        Ey&up = s
        return E
    }
    
   // -eight**
    me.pieight = &acgtRsc{
        $E = me&Api,s,'eight',c
        
        $fo = me&pifour,R,s
        me&fiu,E,fo
        # only -four yet, to help -eight sublate
        c.ov < 0.6 and return
        
        each ie ss&z {
            # paragraph of story: -seven a %Yingate
            $se = me&piseven,R,e,{t:i}
            # < could almost rename that after returning it
            #   would require A:n@1 until the S domed
            me&fiu,E,se
            
        }
        # through -tll (thing looks like) to -act
        
        #ss&z.length > 5 and me&scroll,27
        
        # 6
        $d = {
            compLines:&DdC{
                me&dopi,D,d,C,c
            },
        }
        # < the Lineso top D on ss&string.D
        #   showing the string with chunks inteligised
        me&Linets,s,E,d
        
        # &acceptables_reself
        c.Finto &&
            me&nodei,R,c.Finto,{Fin:s,dige:ss&dige}
    }
    # < may merge -eight with similar -four
    #   eg a sequence of e:clicks each return to Story
    #    whereas a bunch all happen, then return to Story
    me.pifour = &acgtRsc{
        $fo = me&Api,s,'four',c
        $gof = me&acting,R,'-four',0
        
        # -four/-gate(-eight/*-seven) is input
        $D = me&Api,fo,'gate'
        # < i $D/@row%gate=@gate y:row o $s/:gate/:row
        # < separation happening. it's not our $row to eat.
        #   separation coming before the row:{} here
        #   better getting at the row in &ind, grouped by arkfor?
        #   and tw mode, or even t mode (dup keep z)
        #   otherwise works:    this v is io's d.row, not brack row
        # i $D/@row row:{ s&gate = s.row[1] } y o $s/:gate/:row
        # instead:
        me&ioty,s .map(&z{
            me&ioty,z .map(&t{
                t = Cye(t)
                ts&gate = z
                ac(D,'z',t)
            })
        })
        
        # < interactive
        $br = me&pibrackology,R,s,{D}
        bry&M(&Km,{
            $leg = me&pilegs,R,s,{Km}
            # fatal create each -leg in -four
            me&fiu,fo,leg,2
        })
        
        # out of timer
        $po = me&piling,R,fo
        gof and me&nu,"tugboat",po
        
        return fo
    }
    # < self in %Yingate, continues with -eight
    me.piseven = &acgtRsc{
        $se = me&Api,s,'seven',c
        
        $g = sy&brackology
        
        gs&z.map(&Km,{
            !Kms&groupthing and return
            # -gate: bunch of rows
            #  each row allowed one oddness, see &brackgroupX
            $tee = me&ioty,Km .map(Kn => Kn.t).join('-')
            # < &fiu,s,z,2 - fatal create?
            me&fiu,se,tee,8 and throw "already a "+tee
            $mg = Kmy&gate = me&fiu,se,tee

            # < hardwired or $Storie-got configuring
            # < track approx time of each -seven
            #   species a trail of samples
            tee == 'time' and mgc&ms = 'z'; return

            !Kmc&rows and throw "norows"
            each in Kmc&rows {
                $gr = me&fiu,mg,i
                gry&row = n
                each kv n.sc {
                    $gv = me&fiu,gr,k
                    gvc&s = v
                    gvc&pi = 'vat'
                }
            }
        })
        return se
    }
  // -piling
    # draws drawings together as plans to complete them
    # find all -pi for s, generating an M
    me.piling = &acgtRsc{
        $po = me&Api,s,'ling',c
        # searches s for sy&somethingc&pi,
        #  eg s=$fo=-four, finds $D, $br
        $M = []
        $api = v => v && v.c && v.c.pi && M.push(v)
        hav(s.y, v => api(v))
        # and eg $fo/$leg+
        sc&pi && me&ioty,s .map(v => api(v))
        
        poc&M = arou(uniq(M),v=>v!=po)
        return po
    }
    me.dopi = &acgtDdCc{
        $s = c&s
        if (c&pi == 'vat') {

            # starts s=object|data|value, becomes stringified
            !isC(s) and Dc&s = ki(s); return
            Dc&s = s.t
            # avoid talking of R
            isR(s) and return Ds&R = 1
            Dc&pi = 'n'
            # usually -n: a C we can find
            # as a flower amongst|beyond the body of nodes
            $stem = []
            $beyond
            $Xss = c.nlist || []
            $la
            $foundnode = me.cby(s,&zd{
                $t = z.t
                # tell if la^z != z/la
                if (la && !(zs&z && zs&z.includes(la))) {
                    $r = zy&R
                    $rem = ''
                    # < see vv/beginning/3 "Story/Story!%eph/beginning"
                    #   s^^ different to sy&R^^
                    r && !(rs&eph || me&ollbs,r,'eph' ) and rem = '!'
                    !r and rem = '?'
                    stem[0].push(rem+'%eph')
                }
                la = z
                stem.unshift([t])
                if (Xss.includes(z)) {
                    !zy&path and throw "node!zy&path"
                    # finish?!
                    return 1
                }
                beyond = 1
                return 0
            })
            !stem.length and throw "nostem C"
            Dc&s = stem.map(l => l.join('')).join('/')
            !foundnode and Dc&pi = 'C'
            else
            beyond and Ds&beyond = 1
        }
        # normal -vat -> -n, talk of ground things
        Dc&pi == 'n' and delete Dc&pi
    }
  // stylemap
    
  // -brackology** - takes a look
    # situating crammed meanings
    #  wildest edge of things, where wheres where
    # < fill with hooks, combine with KnowC?
    #   see CB, which also wants:
    # < brackology with styles
    # < may have already been, shade difference?
    
    # find openness asap, ology upwards
    me.pibrackology = &acgtRsc{
        $br = me&Api,s,'brackology',c
        $D = c.D
        !D and throw "!D"
        
        $g = me&piology,R,br,{D}
        me&nu,"BVra",g
        # load with D
        return br
    }
    # for s if sc&pi=$k, or sy&$k
    # < used
    window.phisy = &sk{
        $z = sc&pi == k ? s : s.y [k]
        !z || !zc&pi and throw "shocks",z
        return z
    }
    # viewable end of a -process
    # eg -brackology is -brack -> -ology
    me.piology = &acgtRsc{
        # eg R:eight/-four/-brackology/-ology
        $br = s
        $fo = bry&up
        # < named after s.t,(^^^brc&pi)
        # pi-sonality
        $D = c.D
        c.t ||= joint([s.t, fo && foc&pi, brc&pi, D && Dc&pi && '<-'+Dc&pi])
        c.el and $g = me&Api,br,'ology',c
        else {
            # $br becomes &opeology-ish cell divider-ness
            $g = bry&ology = br
            g.t = c.t
            gy&cv = 0.2
        }
        
        # all R/**{,2}/-ology appear
        $appears = br == Rc&s || fo == Rc&s || foy&up == Rc&s
        appears and ac(R,'M',g)
        
        # clickable
        $tog = me&togcon,R,br
        $c = {
            walls:'b:2.2',
            label:{walls:'bg',tog},
            tog,
        }
        # < move out
        c.label.s = 'four'
        c.sc and ex(g.sc,c.sc)
        gs&hue = 30
        gs&ws = 0
        me&applystylec,g,c,{};
        me&opelabel,g,c.label;
        me&opewires,g;
        
        # energised
        gs&ope and gs&pow = gs&ope
        gs&pow ||= 0
        if (gs&pow > 1) {
            #gs&float = 'right';
            #gs&dis = 2;
        }
        bry&M = &y{
            me&ioty,g,'groupthing' .map(m => y(m))
        }
        return g
    }
    # temperature
    # < generalise from label only
    # for within elvising on s-pi,
    #  where its ^^^.t must be uniq
    me.togcon = &acgtjs{
        $C = js&C
        $z = jc&s
        return &gq{
            ~>3 Togable: q.name, z.t
            # q.name qualifies up g to R
            $ok = q.name
            !q.name and throw "named!?"
            $n = q.n = me&mtsc,g,q.may,q.s,'y'
            $issetor = &z,is{
                ~>3 Togs: q.name, z.t, is
                z.y [ok] == null && is != null and z.y [ok] = is
                return z.y [ok]
            }
            $ope = 1
            # -1..2 adjustable
            me.nto(j,n,&sTe{
                $add = e.t.startsWith('C') ? -1 : 1
                # may start from an ope we inherit
                $is = issetor(z,ope) || 0
                is += add
                is > 2 and is = 2
                is < -1 and is = -1
                z.y [ok] = is
            })
            # inherit last defined ok
            zy&R && me.cbu(zy&R,&r{
                $z = rc&s
                if (z) {
                    $te = rs&Te
                    # may remember over null
                    te and issetor(z,te.sc[ok])
                    $is = z.y [ok]
                    if (is != null) {
                        te.sc[ok] = is
                        ope = is; return 1
                    }
                }
                rs&Peace == 4 and return 1
            })
            ns&fs = 9+(ope*2)
            ns&ope = ope
            return n
            # to &vlabinto, &opelabel
        }
    }
   // ology # ways to lum -brackology/Km
    # for 
    me.pilegs = &acgtRsc{
        $Km = c.Km
        !Km and throw "!Km"
        c.t ||= joint(Km,'-','gate')
        $mg = me&Api,s,'legs',c
        
            me&ioty,Km .map(&Kn,{
                $N = me&ioty,Kn
                #me&nu,"Kn:"+Kn.t,N
                $gr = me&fiu,mg,Kn.t
                grc&pi = 'leg'
                Knc&size and grs&size = Knc&size
                gry&leg = Kn
                if (Kn.t != 'gate') {
                    $x = Knc&x
                    $ii = 0
                    # ology modulat compresses same v.t along N
                    #  to simplify order of every ref
                    each in N {
                        !ns&vis and continue
                    each i,vi ns&vis {
                        $fx = x.ref[vi]
                        $v = x.refs[vi];
                        # how many times it was used
                        $gv = me&fiu,gr,''+(ii++)
                        gvc&pi = 'vat'
                        gvc&s = v
                        gvs&size = fx.z.length
                        gvs&size == 1 and delete gvs&size

                        $nN = me&ioty,n
                        each iz nN {
                            zs&groupthing and debugger
                            # size,sym,label
                        }
                    }
                    }
                }
                else {
                    # mute %%gate after size
                    # < in such a way that Te|diff can inflate it
                    $aft_size = 0
                    each in N {
                        aft_size and ns&dis = 0
                        n.t == 'size' and aft_size = 1
                    }
                }
            })
        return mg
    }
   // legacy
    
    # find openness asap, ology upwards
    me.sbrackope = &acgtjkc{
    };
    
    me.sbrackology = &acgtjzc{
        $C = js&C
        c ||= {}
        $config = c
        isst(z) and z = j.sc[z]
        !isC(z) and throw "!z"
        $k = c.t || z.t;
        $g = me&brackope,j,k,config||{}
        !z and return g;
        
        $X = zs&X ||= me&brackX,zs&z;
        
        !hak(X.k) and return g
        
        gy&brack = z;
        zy&brackology = g;
        gy&X = X;
        
        if (gs&ope) {
            #me&nu,'waigh',z;
            #me&nu,"X",X;
        }
        
        # 0 - t-only, grouped
        # 1 - with amounts
        # 2 - t:v, for 1 v only (as now)
        # < t-only, of at the toplevel
        if (gs&pow < 0) {
            # < only changes pop up, shrink in
            $op = me&sizo,g,{t:'rows',len:zs&z.length,opelen:1};
            me&sizo,g,{len:hak(X.k)};
            !(op && ops&ope) and return g
        }
        
        $N = me&brackgroupX,j,z;
        
        each ic N {
            $ug = g;
            if (!cs&X) {
                cs&X = me&brackX,cs&z;
                ug = me&opeKn,g,c.t+'-'+i,{walls:'bd:1.4'}
                ugs&bgh = 581;
                ugs&dis = 2;
            }
            ugc&rows = cs&z;
            ugs&pow = gs&pow;
            ugs&ope = gs&ope;
            #j.t == 'Travel' and me&nu,"rowish"+i,c
            me&brackXology,ug,cs&X,config;
        }
        # < X.ref for inter-group object link
        # < ny&act from a &acting%ope glow
        return g;
    };
    # regroup similar rows
    # allowing a and a+b to fit together,
    #  sizo per column|value communicates the oddness
    # < show clearer when Km%ope (tabular?)
    me.sbrackgroupX = &acgtjz{
        $N = [];
        each in zs&z {
            nc&drop and continue
            $ks = haks(n.sc);
            $matchness = 0;
            $match = null;
            each ic N {
                $no = haks(c.c).filter(k => !hak(n.sc,k)).length;
                no > 1 and continue
                ns&dome != cc&dome and continue
                $yes = ks.filter(k => hak(c.c,k)).length;
                $matched = yes - no;
                matched <= matchness and continue
                match = c;
                matchness = matched;
                #j.t == 'Travel' and me&nu,"matched"+i,[ks.join(','),matched+'('+yes+'/'+no+')'+matchness,c.t]
            }
            if (match && matchness >= ks.length-1) {
                # groups members with <= 1 odd key
                $c = match;
                ac(c,'z',n);
            }
            else {
                $c = Cye([ks.join(','),1]);
                c.c = ex({},n.sc)
                cs&z = [n];
                N.push(c)
            }
        }
        #N.length == 1 and N = [z]
        return N
    };
  
  // brackXology - draw openable!
    # draw openable X.k/ref/z
    me.sbrackXology = &acgtgXc{
        c ||= {}
        $Kms = [];
        each kx X.k {
            $Km = me&opeKm,g,k;
            Kmc&k = k;
            Kmc&x = x;
            #
            Kms&pow = 1
            $con = c.kc && c.kc[k]
            con and ex(Km.sc,con)
            gs&ope && Kms&ope == null and Kms&ope = 1
            Kms&ope and Kms&pow = gs&pow = 2
            gs&pow ||= 0
            Kms.push(Km)
        }
        
        gs&pow < 2 and gs&ma = 0.2
        each i,Km Kms {
            $k = Kmc&k;
            $x = Kmc&x;
            if (Kms&pow < 1) {
                Kms&ma = 0.1
                continue
            }
            
            # total values for key, Km%ope if 1
            me&opesizup,Km,{len:hak(x.ref)};
            !Kms&ope and continue
            
            fio(Km,['ope',1,{s:":"},'hs:888']);
            $vii = 0;
            each vi,fx x.ref {
                $v = x.refs[vi];
                $lc = me&labeline,v
                $Kn = me&opeKn,Km,lc.t,{label:{tsc:'y'}};
                Kny&v = v
                ac(Kn,'vis',vi)
                
                $lab = Kny&label;
                $bsize = Knc&size || Knc&sortcv && 1 || 0
                Knc&sortcv = 1;
                lc.C &&
                    fio(Kn,['sym'+vi,112,{s:lc.sym},
                    'label,fs:13,lh:0.8,hs:757']);

                # total rows for this value with this key
                # < light up other k/v/rows this k/v/row has
                Knc&size = 0
                me&sizo,Kn,{len:fx.z.length};
                # many same lc.t pile up many sym, add sizo
                # < fix in -ology
                Knc&size ||= 1
                Knc&size *= 1
                bsize and Knc&size = (Knc&size||1)*1 + bsize*1
                Knc&size == 1 and delete Knc&size
                Knc&size > 2000 and debugger
                Kns&ma = 0.2;
                if (Kns&ope) {
                    each in fx.z {
                        $val = n.sc[k];
                        $na = [g.t,k,vi,i].join("'");
                        $wa = me&opeKn,Kn,na;
                        way&cv = 0.2;
                        was&dis = 1;
                        # sprout icon, some non-nu to click
                        $wan = me&opeKn,wa,'ܤ',{label:{tsc:'y'}};
                        if (wans&ope) {
                            # whole row
                            me&mnu,wa,'row',n
                        }
                        else {
                            # for the value
                            me&mnu,wa,k,val;
                        }
                        wany&cv = 0.8;
                    }
                }
            }
        }
        return g
    };
    # a title for $s, data if weird
    # < -vat compat, fliop
    me.slabeline = &acgts{
        $c = {}
        if (isC(s)) {
            c.C = 1
            c.sym = isR(s) ? 'R' : 'C'
        }
        c.t = c.C ? s.t :
            s == null ? '*null' :
            isst(s) ? s :
            isob(s) ? ki(s,2) : ""+s;
        return c
    }
    
   
   