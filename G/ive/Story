# Yap
me.Sch_Story = &acgt{ return [

// Story - intents <-> extents
   
   =pod
    < %Story runtime difference, on %%wake
     %Yingates mark details
     < %TheNine can create/resume tests
     < %sleepic %Stories
     < %Stories select which/what
     
      %Story + %Plot
      < shall go looking for %%may,
        ends up engaging a Gumpframe,
         which ... Travel/$t,
          Story letting the workflow,
           locking on %Pave?
      described beyond the test data function:
    
    prem|exact|retro-ly,
    -eight/-seven/**/-vat emerge
     gaining simpname from nodepile relations
      -vat -> -n|-C for sy&up does|not lead to a node
     < %Slope about sy&up, c.ip, etc.
     satisfying Plot etc
     when ready:
      < to Dome slep the othering of R%Yingates
         if R%tunneling, wants update|change
          can we deliver e.c to specific wakers?
        from:
        %Yingates[-2..] (!%Fin) awake for streaming, then finish
         < %onlylish sometimes flaky until R:Ying itself happens
            knowing more &Yingwhen may find why,
            %Yingates/* also want selective waking
            yet it depends on *%ball%Peace and ^%Ying
    
    in bursts of activity:
     < hide most of the nodepile and nodes
     < regroupable, to Plot points
    
    once computed a bit,
      < know if weird, eg C not node or e
      < know if unexpected if $Storie
      and the whole bunch,
      < merge into similar previous %Yingates,
         waking [-3] to incorporate [-2]/*
          with %Yingates%onlyish + slep
           to keep most -gate|-seven (%Yingate),
           tallying into -eight again (%Yingates)
        by overall same-ness, looking for e:clicking
         < generated by Zif<->Lines<->C
      < ignore %Story/**, leaving only %%quiet,wake?
         could be implied by the ending of an -eight
        if e:click
          if %Story/**
           capture any adjusted ology for replay
            configuring magnifying glasses to produce test data
            not as e:clicks but as parameters on the %Yingate
             a Te proposed to be permanent,
              apply to others after it with Index?
            slep it to re-Y:pi accodingly,
           < Jx new modulat must ...
          else
           capture pointer|meanings for replay
            previously went quiet? (awaiting click) or:
             < e:click while thinking loses a &Yinge?
             < while at it, later[] may have R-d since
              
    storability:
      < the %Yingates/%Yingate -> -seven/-rows/-row/-vat becomes:
        %Storie/%Stori/-thing**
         %Storie+ are tapes to sync to $Story
         %Stori moment
          happens ||= s&when || next %Yingate
          s&rows breakdown pointing to **:
         -thing** as mentioned in s&rows, default -n
          see 'pile of nodes':
           say $step..$node, even if $step asleep
            maybe more if $node needs unique name
             in the -thing** and in the node pile,
              ie a %twmt across either,
               so Ghost..$z-node can point to the %dige%Q
                coming from a Duolish..$t-node...,
                 coming from a Travel..$t-node
       < or:
        -nine/-eight/-seven/-six/-five/-four/-three/-two/-one
          -nine a whole book
          -eight a chapter, lump of pages|trips
         %Yingate expanded about the aparatus of the plot:
          -seven a page, a trip to A.4|$Ying
            possibly more than one trip,
             ie %Jrunto many times between %Jproto
          -six the overall notion of change, plot pointering
          -five why doing (e|%Jproto plans)
          -four what doing (%Jrunto dome state)
          -three who (dome thing)
          -two part (A pointers)
          -one detail
         all may + Elsewheel, appears with developer
      
      # then Lines it
      < as diff against previous Lines (el:6?)
        web landscaping
      < which might turn into tiny Lines for $Storie:
          implying -nine/-eight/-seven/-n**, etc
          Lines[5] implies z + low light (ki d=4.23)
      < stable $Storie Lines indent -> type means:
         wide ack for similar tests|output
          subtracting normal: what most tests sound like
      
    < %The names %Plot for a new %Storie,
       Stu->toPave without %MayGansp

    < rebuild &waits_8, test against $Stories
    
    < @Story groups time, turns observe/respond corner
      pretending to be Fingo S-ing, providing:
        < log interesting acts
         eg CBing|Travel|Duolish starts|ends
        < log should be mergible with Yingu, Evelse, etc logs.
        shuntographer
        runs the game seq:
        < %Paving nice, found%Pave
        < @Story: %Paving+twinned ready
        < %Paving CB also from Ghost..$z
         diff Know..$s/found%Pave with:
          Know..$s%Paving itself
            eg %cha:Thing-has:dige,src:s,from:Q
          Ghost..$z%twin, as used by Travel..$t
            eg %%cha:Thing-has:dige,src:s,from:Q,to:z,t:t
        < %Gump gets Know..$s (+ Ghost/$t..$z)? out of date
        < @Story: %Paving+twinned+%Gump ready
        < %Story:
         any Ghost/$t..$z -> Travel/$t
         notices them vanish, knows why
        < @Story:
          start Travel/* wanted,
           pre-@Search the %Gump versions (%Jhost)
            inc anything in a $W.5, with wjs %args
          start Travel/$t
          end Travel/$t
          end Travel/*
          start Duolish/*
           $u should be as input to %Gump, or restart?
          end Duolish/*, when all is commit
   =cut
   
   // todo
    =todo
     
     -seven..-vat are Yingate's rows' properties
     
     < er diag, jam the Y:-seven until sorted,
        adjust ology|pointing or encoding after,
         usu define schema|depth-limit|reducer for random data
     
     -seven/-rows/-row/-vat
      -vat draws the something on the rows of -seven
     
     < -vat -> -row: brack in brack
       it would become a -row as well
     < -row:$b (anywhere) may include interesting by&up
       bc&shade, or the R/node/C via by&brack for it
       < leading back to a non-waker Yingate row,
         and then the r row that %%waits, etc
     < -row ref-itivity,
       maybe point to another -row (anywhere)
       esp as a later -seven/-rows/-row
       esp the one described in The**/Misc**
        collection of oddities (non-node items)
       or pool some misc upwards, on Misc accept:
        repile -row to point to it
        knowing that it was looking for it, eg &nodeo
     
     // less urgey
       < -R with sip|tip (serial or Te ip):
       < also know the R above R:Ying
         eg it starts with an %%e,to=Lingo-R c.o:^2
         see 'say $step..$node'
         -R names climb Rc&X beyond the last $node etc?
       < Ac&ip, like Y:Acec&ip or what Rc&ip could be,
          are per Run, per time finding names
         Cc&ip, like Jc&ip, Tec&ip or Xc&ip
          are per finding of the name, many times
         wave and particle, frames and movie
      
         # compression or re|de|piling:
         < stop at some -rows or -row if so simple,
           c&s = diagram pointering -thing** beyond
            or pointering nodepile if -n. gets complicated:
           changes (eg assigning c.ip) would need rolling out
            as some kind of change to auto-accept (%Zif)
             rename wants this
           novelty depiles back to -row/-vat
            to find &brackology to lay into
             and in general... diff long form, diag short form
    =todo
 
 // %Story itself
    ['Story',0.299,&acgtRs{
        
        me&reaw,R,'Story'
        $x = me&Jx,R

        # quiet,wake:Story then Story/This
        if (!me&rollbs,R,'ever_quiet' ) {
            me&quiet_waker,R and Rs&ever_quiet = 1
            !Rs&ever_quiet and return
        }
        
        # sources of and tests
        me&bal,'Stories','Stories,eph'
        
        # expectation
        me&bal,'The','The,eph'
        
        # pile of nodes
        me&bal,'Nodar','Nodar,eph'

        # navigator
        me&bal,'Plot','Plot,eph'
            
        # experience
        $r = me&bal,'This','theThis,eph'
        # is visited to draw them into %Yingates/%Yingate
        # < lighter drawing into -eight/-seven
    },'ift,D'],
 
 // %Stories/Stori/Eighi Live
   
   // %Pavings
    ['Stories',0.297,&acgtRs{
        me&reaw,R,'Stories,eph'
        me&inode,R;
        $x = me&Jx,R;
        Rs&Pavings = 1
        Rs&directory = "Stories"
        ah(R,'inheritscif','ball','Stori',1)
        # < give nodeo pathia, %%inside=Stori,tw=Eighi
        ah(R,'adhere','twmt',s)
        # make W**%Paving mean W/J**,
        #  J directoried inside J^
        #  %Compiling used to W**
        #  suits compiling mountains of code,
        #  to give %Paving** that hierarchy
        #   eg remotes listen to the peak
        #  as views all named in the same space
        ah(R,'adhere','director',1)
        # species=1 only
        ah(R,'adhere','fully',1)
        # less Paving brains
        # < may %onlyish settle up etc
        ah(R,'adhere','noGump',1)
        
        $r = me&bal,"Around","Around"
        !Rc&b and me&fiu,s,'vv'
        s&hue = 66;
    },'ift,D'],
    ['Stories+Pavings',0.2999,&acgtRs{
        me&bewind,R and return
        me&tsc,"SP"
    },'ift,D'],
    
   // %Paving
    # loads if The/Stori wants
    # many Stori/Eighi%dige toc for directory=$Stori
    #  usu enough to pass tests where -eight%dige matches
    ['Stori',0.298,&acgtRs{
        me&reaw,R,'Stori'
        me&tsc,"Stori"
        # has Eighi inside
        ah(R,'inheritscif','ball','Eighi',1)
        # Stori%twmt=Stories, Stori/**%twmt=Stori
        #  does its own %eto,tw for its Eighi
        ah(R,'adhere','twmt',s)
    },'ift,D'],
    
    # loads if Stori wants
    # download details to difference an -eight
    ['Eighi',0.33,&acgtRs{
        #me&sleepic,R and return
        me&reaw,R,'Eighi'
        
        #me&tsc,"Eighi:"+ki(Rs&twmt,2)
    },'ift,D'],
    
    # loads, small list of potential Stori
    #  could be in each A.4 (W:Lingo) Stories,
    #   outsphere of Story/Stories
    #  since Stories%eph we must store our list
    ['Stori+Around',0.298,&acgtRs{
        me&reaw,R,'Around'
        me&scroll,10
        me&tsc,"Arou"
        ah(R,'noadhere','director',1)
        # does its own %eto,tw
        ah(R,'noadhere','twmt',1)
        ah(R,'adhere','twmt',s)
        Rs&fully = 1
    },'ift,D'],
 
 // %The/TheTest/TheNine/TheEigh pos
  
  // 1 %TheTest o Stori
    ['The',0.292,&acgtRs{
        me&reaw,R,'The'
        me&inode,R
        ah(R,'inheritscif','ball','TheTest',1)
        # init The/$t then <-> -eight%%Fin,dige
        $z = sy&Test = me&fiu,s,'vv'
    },'ift,D'],
    # -nine being Zavable
    ['TheTest',0.294,&acgtRs{
        me&reaw,R,'TheTest'
        Rs&acceptables = 1
        $go = me&acting,R,'That'
        $x = me&Jx,R;
        # wants to get Stories/$t(/$bits)
        #  and commit them all at once, with history
        #  and commit $t -> Stories/Around
        $that = me&getThat,R,xs&Stories,s.t
        !that and return
        # then harness %Live into TheNine
        # < harness self (TheNine<->...) <-> other (Paving)
        $self = me&selfThat,R,that
        # < a Stori could compose many Stori,
        #    a Stori = plot - subplots
        #     subplots pointed to, recipised to solo:
        #      being vague about -nodes,
        #      templating the test data for inputs from Stori,
        #      from Zif noticing only $t, $begin|end_dige change
        $r = me&bal,s.t,self,'TheNine,eph'
        rc&s != self and me&nu,"Craze",rc&s
    },'ift,D'],
       
  // 3  %TheNine <-> Yingates
    # Nine/$exp + Story/-eight%Yingates
    #  = Nine/Eigh%exp+%got
    ['TheNine',0.295,&acgtRs{
        me&reaw,R,'TheNine,bal_tw_s'
        Rs&acceptables = 1
        $go = me&acting,R,'Nine'
        $x = me&Jx,R;
        sc&pi = 'nine'
        # roll the invention of Eigh s
        me&sleepic,R and me&rollbs,R,'bal_tw_s'; return
        
        # * become Eigh%exp
        Rs&noRsync = 1
        #  %exp = $t's link to Stories/$t/$eight
        #  %got = Yingates, having a %dige%string
        $N = me&ioty,xc&This,'Yingates'
        me&twlic,N,s (&zlct{
            $r = me&bal,t,'eph'
            rs&TheEigh = 1
            # may +%now_missing once later $eight are found
            ex(r.sc,c)
            l and rs&exp = l
            z and rs&got = z
        })
    },'ift,D'],
    
    # many acceptables
    ['acceptables',0.295,&acgtRs{
        me&reaw,R,'acceptables,reself'
        me&rollbs,R,'reself'
    },'ift,D'],
    ['TheNine',0.67,&acgtRs{
        $N = me&ioty,R,'TheEigh'
        # -nine settles the -eights, see &sleepic
        # < create new &settles and go to sleep
        #me&settle,R,N && me&sleepic,R,2 and return
        me&acceptables,R,N
        $c = {
            # an Eigh accepted again
            accept: &acgtsOrznt{
                me&accept,R,t
                $dige = me&storable,t
                # Stories/$t links /$eight
                $link = me&fiu,O,t.t,2
                linkc&pi = 'eight'
                links&dige = dige
            },
            # an Eigh still
            sleep: &acgtsOrz{
                $t = rs&exp
                !t and return
                # Stories/$t links /$eight
                # < should be as it was, skip encode?
                me&fiu,O,Cye(t),2
            },
            # the Nine itself
            self: &acgtsO{
                me&Linets,s,O
                me&accept,R,s
            }
        }
        me&acceptables_reself,R,N,c
        
    },'ift,D'],
  
  // 6  %TheEigh 
    ['TheEigh',0.33,&acgtRs{
        me&reaw,R,'TheEigh,exp,got,now_missing'
        $x = me&Jx,R;
        $go = me&acting,R,'Eigh'
        $t = Rs&exp
        $z = Rs&got
        # z-eight is already Lineso:
        $Dige = z && zs&dige
        $cha = !Dige || !me&za,R,{Dige}
        Dige and me&ha,R,{Dige}
        !cha && me&sleepic,R and return
        if (go) {
            me&zu,"TheEigh",s
            me&zu,"Exp",t
            me&zu,"Got",z
        }
        ss&coun ||= 0
        ss&coun++
    },'ift,D'],
    ['TheEigh',0.36,&acgtRs{
        $t = Rs&exp
        $z = Rs&got
        
        # has -eight happened (got got)
        !z || !zs&dige || !zs&string and return me&ha,R,'unready'
        # < exp ||= surprise?
        
        # from here, it's a &toPave that doesn't pushPave at the end,
        #  instead sending the flock of storables onward
        me&acceptable,R,z,t
        
        # < probably want Qdiff,z,t=null
        #    or know t is a link, do &moreThat
        #    or t could be this step's part of another &Linets
        #     and need to other it there and then commit that,
        #      staging chunk regroup for commit essential
        #     lots of slightly different %%$word...,
        #      iterating commissions on 
        me&ja,R,'ok' and return
        !t and return
        !(tc&pi && ts&dige) and return me&tsc,"Nine/!-eight"
        
        $self = me&moreThat,R,t,t
        !self and return me&waits,"Nine/.."
        
        $Q = me&PaveQ,R,selfy&That
        
        me&Qdiff,R,z,Q
        # < to &brackology
        # < mergible
    },'ift,D'],
  
  // 7 %TheTest reselfs %ReNine <- %TheNine
    # < i $t... ytia o %%acceptia:t
    ['TheTest',0.294,&acgtRs{
        $h = {
            ytag: 'tia',
            self: &acgtnt{
                $r = me&bal,"Re:"+t.t,'ReNine,unity,eph'
                $z = rc&s
                return z
            },
            other: &acgtntzlm{
                return me&fiu,z,l.t
            },
        }
        me&acceptables_reother,R,h
    },'ift,D'],
    ['ReNine',0.295,&acgtRs{
        me&reaw,R,'ReNine,unity'
        ah(R,'inheritscif','ball','ReNine',1)
    },'ift,D'],
    ['ReNine+unity',0.35,&acgtRs{
        $N = me&ioty,R,'ReNine'
        s&bg = '#180213'
        me&toPaves,R,[R,...N]
    },'ift,D'],
    
    ['ReNine',0.33,&acgtRs{
        $go = me&acting,R,'Re'
        $x = me&Jx,R;
        # the got, being pushed
        $tia = sy&tia
        # into the enclosing Stories or /Stori**
        # < because pipe can go back through Nine &reother,
        #    and Test/Eigh &reself, to 
        $t = me&twineThat,R,tia,{origin:xs&Stories}
        # difference and flock apply again
        # < ReNine species
        t and me&toPave,R,R,t,tia

        go and me&nu,"tia",tia
        !t and return
        $r = ty&R
        $Q = rs&Q;
        if (go) {
            me&nu,"Q",Q
            me&nu,"P",Qs&P
        }
    },'ift,D'],
 
 
 // This/$eight stream
    ['theThis',0.293,&acgtRs{
        me&reaw,R,'theThis,wakeful,onlyish'
        me&inode,R
        # wake R when p%onlyish/R%wakeful
        Rs&wakeful = 1
        # sleep r when R%onlyish/r!%wakeful
        Rs&onlyish = 1
        if (0) {
            # shows sleep|wake pattern
            $p = Ry&up
            ah(R,'inheritscif','ball','theThis',1)
            $i = ss&quue = (ss&quue||0) + 1
            !ps&theThis and me&input,R,"le_"+i
            else {
                ps&z.slice(-2).includes(R) and Rs&wakeful = 1
            }
            return
        }
        $Ying = me.cbu(R,'Ying')
        $c = {s:Yings&Outlog}
        me&Storystream,R,s,c
    },'ift,D'],
    ['theThis',0.296,&acgtRs{
        $D = Rs&Storystream
        $x = me&Jx,R
        
        # draw the story
        # < selfing it to -seven and -eight already,
        #    realising novelty asap
        each im Ds&z {
            mc&pi ||= 'eight'
            # %onlyish 294 has made these if sleeping them
            $r = me&bal,m.t,m,'Yingates,Fin,eph'
            rc&s != m and throw 'crae'
        }
        # leaves current -gate
        r and rs&wakeful = delete rs&Fin
    },'ift,D'],
        
 // Storystream <- Outlog/Page
    # when e,on:m%Yingates, it keeps filling up
    ['sleeping+Storystream',0.53,&acgtRs{
        $D = Rs&Storystream
        # < want to have a sleeping This just for this
        #    more often than waiting til quiet
        #   moment to picture things before they ~ again
        Dy&stream()
    },'ift,D'],
    &{
    me.Storystream = &acgtRsc{
        $x = me&Jx,R
        me&reaw,R,'Storystream'
        me&rollbs,R,'Storystream'
        $D =
        # < it having a Y to consider, slepvia
        sy&Storystream =
        Rs&Storystream ||= me&logdome,R,s
        !c.s and throw "thing to follow"
        Dc&thing = c.s
        Dc&ignoring = x.ro('pause',{})
        
        # page turning
        # may be unturned, see merge similar previous
        # < turn fractions of a page|plot, when|why
        $Plot = xs&Plot
        $page_turning = &c{
            $i = sy&quue = (sy&quue||0) + 1
            Dy&domed(c)
            
            $d = Ds&z.slice(-1)[0]
            $cb = Ploty&pageturn
            cb and cb(R,d)
            else {
                i > 1 and Rs&pause = 1
            }
            # < Plot leaves tightenable hooks
            #   for Yingate_2 -> Outlog -> next:
            
            Dy&dome("le-"+i,'light')
        }
        # takes over from Story
        $q = me&quiet_waker,R
        q ||= !sy&quue
        if (q) {
            me&tsc,"q";
            #~>4 quiet,wake: s.t
            # tailwag so -eights end in %%quiet(_recently,wake)
            page_turning({tailwag:1})
        }
        # even if too close to the last quiet,wake to self
        $Y = me.cbu(R,'Ying').sc.Ying
        Ys&quiet_wakers_too_recently = &{
            # if next page == Plot%wants_upto, must self to act
            $to = Plots&want_upto
            ~>4 pagequiet: to, sy&quue
            sy&quue == to and return 1
            page_turning()
        }
        # then inhaling nothing if the page was just turned ^
        Dy&stream()
    }
    },
 
 # < is Y:-eight/-seven
 #   through -tll (thing looks like) to -act
 // This/$eight %Yingates details
   
   // This/$eight/*%Yingate
    ['Yingates',0.298,&acgtRs{
        me&reaw,R,'Yingates,wakeful,who,Fin'
        me&inode,R
        Rs&rowish = 1
        # * become %Yingate!%ball
        Rs&noRsync = 1
        each in ss&z {
            $r = me&Ret,R,{t:"n:"+i,s:n,Yingate:1}
        }
    },'ift,D'],
   
   // %Yingate -> &brackology
    # < self a -seven
    #   has a &brackology + more
    # < brackology rearranging so node:Gilramp=wake
    # < saying when node:Travel..Gilramp
    ['Yingate',0.32,&acgtRs{
        # how to brackology:Yingate !
        #sc&i == 1 and debugger;
        n Dci 01 $s:sc&i %fs:8
        # < maybe how to -gate..-vat,
        #   see 'capture any adjusted ology for replay'
        #   specifics for the process its going into,
        #    want tuning in the brackology
        sc&pi ||= 'ugh'
        $c = {t:sc&pi}
        s&hue = 138;
        sc&pi != 'gate' and s&ml = -2; s&hue = 100
        sy&R = R
        $g = me&brackology,R,s,c
        me&walls,g,'b:2.2';
        ac(R,'M',g);
    },'ift,D'],
    
    # < othering back into &brackology any novelty
    ['Yingate',0.44,&acgtRs{
        me&reaw,R,'Yingate'
        Rs&rowish = 1
        !sy&seven and return
        $x = me&Jx,R;
        $go = me&acting,R,'-seven',0
        
    },'ift,D'],
   
   // %Yingates%Fin -eight/-seven 
    # othering the /*-seven from &brackology
    #  &brackolgy left from selfing /*%Yingate
    #  so we can go here to other more, self the one changer
    # < see Atiming of R,R/*, adjust cv for less rounds
    ['Yingates+Fin',0.33,&acgtRs{
        me&bewind,R and return
        $x = me&Jx,R;
        # chapter of story: -eight a %Yingates
        $b = sy&eight;
        $E = sy&eight = Cye([s.t,1,{pi:'eight'}])
        $go = me&acting,R,'-eight',0
        
        go and me&zu,"exp",Rs&exp
      
        me&pifour,R,E,s
      
      // skipout
        $Ch = me&jaa,R,'Checkable,efrom' [0]
        !Ch and return me&tsc,"..Checkable"
        
      // five
        # 5
        each iz ss&z {
            # paragraph of story: -seven a %Yingate
            me&piseven,R,E,s,i
        }
        # through -tll (thing looks like) to -act
        
        #ss&z.length > 5 and me&scroll,27
        
        # 6
        $No = xs&Nodar
        $X = Noy&X
        $c = {nlist:X.ss}
        $d = {
            compLines:&DdC{
                me&dopi,D,d,C,c
            },
        }
        # < the Lineso top D on ss&string.D
        #   showing the string with chunks inteligised
        me&Linets,s,E,d
        
        # &acceptables_reself
        me&nodei,R,Chs&efrom,{Fin:s,dige:ss&dige}
    },'ift,D'],
  // func
   // pi
    &{
    me.scroll = &acgts{
        s&mh = s;
        s&over = 1
    }
    me.pifour = &acgtREs{
       // make overall quantology from the many -gate
        # < may merge with z/-3 if similar,
        #   eg a sequence of e:clicks each return to Story
        #    whereas a bunch all happen, then return to Story
        # and oking, via:
        $D = Cye([s.t+'-four',1,{pi:'gate'}])
        Ds&z = []
        each iz ss&z {
            each it zs&z {
                t = Cye(t)
                ts&gate = z
                Ds&z.push(t)
            }
        }
        # < interactive
        $g = me&brackology,R,D,{t:'four'}
        me&walls,g,'b:2.2';
        gs&hue = 200
        ac(R,'M',g);
       // into el:2-four..-vat
        $fo = sy&four = Cye([s.t,1,{pi:'four'}])
        me&fiu,E,fo
        $gof = me&acting,R,'-four',0
        me&ioty,g .map(&Km,{
            !Kms&groupthing and return
            
            $tee = me&ioty,Km .map(Kn => Kn.t)
                .filter(t => t != 'gate').join('-')
            # < &fiu,s,z,2 - fatal create?
            me&fiu,fo,tee,8 and throw "already a "+tee
            $mg = Kmy&gate = me&fiu,fo,tee
            mgc&pi = 'legs'
            
            me&ioty,Km .map(&Kn,{
                $N = me&ioty,Kn
                #me&nu,"Kn:"+Kn.t,N
                $gr = me&fiu,mg,Kn.t
                grc&pi = 'leg'
                Knc&size and grs&size = Knc&size
                gry&leg = Kn
                if (Kn.t != 'gate') {
                    $x = Knc&x
                    $ii = 0
                    # ology modulat compresses same v.t along N
                    #  to simplify order of every ref
                    each in N {
                        !ns&vis and continue
                    each i,vi ns&vis {
                        $fx = x.ref[vi]
                        $v = x.refs[vi];
                        # how many times it was used
                        $gv = me&fiu,gr,''+(ii++)
                        gvc&pi = 'vat'
                        gvc&s = v
                        gvs&size = fx.z.length
                        gvs&size == 1 and delete gvs&size

                        $nN = me&ioty,n
                        each iz nN {
                            zs&groupthing and debugger
                            # size,sym,label
                        }
                    }
                    }
                }
                else {
                    # mute %%gate after size
                    # < in such a way that Te|diff can inflate it
                    $aft_size = 0
                    each in N {
                        aft_size and ns&dis = 0
                        n.t == 'size' and aft_size = 1
                    }
                }
            })
        })
        return fo
    }
    me.piseven = &acgtREsi{
        $se = sy&seven = me&fiu,E,''+i
        sec&pi = 'seven'
        $g = sy&brackology
        gs&z.map(&Km,{
            !Kms&groupthing and return
            # -gate: bunch of rows
            #  each row allowed one oddness, see &brackgroupX
            $tee = me&ioty,Km .map(Kn => Kn.t).join('-')
            # < &fiu,s,z,2 - fatal create?
            me&fiu,se,tee,8 and throw "already a "+tee
            $mg = Kmy&gate = me&fiu,se,tee

            # < hardwired or $Storie-got configuring
            # < track approx time of each -seven
            #   species a trail of samples
            tee == 'time' and mgc&ms = 'z'; return

            !Kmc&rows and throw "norows"
            each in Kmc&rows {
                $gr = me&fiu,mg,i
                gry&row = n
                each kv n.sc {
                    $gv = me&fiu,gr,k
                    gvc&s = v
                    gvc&pi = 'vat'
                }
            }
        })
    }
    me.dopi = &acgtDdCc{
        $s = c&s
        if (c&pi == 'vat') {

            # starts s=object|data|value, becomes stringified
            !isC(s) and Dc&s = ki(s); return
            Dc&s = s.t
            # avoid talking of R
            isR(s) and return Ds&R = 1
            Dc&pi = 'n'
            # usually -n: a C we can find
            # as a flower amongst|beyond the body of nodes
            $stem = []
            $beyond
            $Xss = c.nlist || []
            $la
            $foundnode = me.cby(s,&zd{
                $t = z.t
                # tell if la^z != z/la
                if (la && !(zs&z && zs&z.includes(la))) {
                    $r = zy&R
                    $rem = ''
                    # < see vv/beginning/3 "Story/Story!%eph/beginning"
                    #   s^^ different to sy&R^^
                    r && !(rs&eph || me&ollbs,r,'eph' ) and rem = '!'
                    !r and rem = '?'
                    stem[0].push(rem+'%eph')
                }
                la = z
                stem.unshift([t])
                if (Xss.includes(z)) {
                    !zy&path and throw "node!zy&path"
                    # finish?!
                    return 1
                }
                beyond = 1
                return 0
            })
            !stem.length and throw "nostem C"
            Dc&s = stem.map(l => l.join('')).join('/')
            !foundnode and Dc&pi = 'C'
            else
            beyond and Ds&beyond = 1
        }
        # normal -vat -> -n, talk of ground things
        Dc&pi == 'n' and delete Dc&pi
    }
    },
    
 // signals
  // The<->This
    # The/Test/Nine is wanted
    ['The',0.46,&acgtRs{
        $x = me&Jx,R;
        $z = sy&Test
        $liz = me&zaa,xs&This,'listening',1 [0]
        !liz and me&wants,R,'Theing',z
    },'ift,D'],
    # Nine -> This%%listening
    ['TheNine',0.295,&acgtRs{
        $x = me&Jx,R;
        xc&This and me&nodei,R,xc&This,{listening:s}
    },'ift,D'],
    
    # < an &Accepting mode for these three,
    #   controlling and resulting an A
    # Nine <- %%Having=This/$eight
    ['theThis',0.297,&acgtRs{
        $D = Rs&Storystream
        $who = Rs&who = me&jaa,R,'listening',1 [0]
        who and Ds&z.map(Having => me&nodei,R,who,{Having} )
    },'ift,D'],
    # Eigh%%Checkable <- Plot
    ['TheNine',0.45,&acgtRs{
        $i = 0
        $upto = me&jaa,R,'upto,efrom',1 [0] || 0
        me&ioty,R,'TheEigh' .map(&r{
            $z = rc&s
            i < upto and me&nodei,R,z,{Checkable:1}
            i++
        })
    },'ift,D'],
    # Eigh -> This/$eight%%Checkable
    #  $eight Yingates+Fin:
    #   half happens without it,
    #   -> Eigh%%Fin:$eight,dige checks it
    #    < Plot/L by Eigh, wake Nine when upto==Checkedupto
    ['TheEigh',0.35,&acgtRs{
        $x = me&Jx,R;
        $t = Rs&exp
        $z = Rs&got
        !z and return
        # have an -eight, waiting for %%Eigh
        $r = zy&R
        # may still be streaming
        !rs&Fin and me&ha,R,'NoFin'; return
        
        $check = me&jaa,R,'Checkable,efrom',1 [0]
        check ||= x.ro("check",{})
        check and me&nodei,R,z,{Checkable:1,expect:t}
    },'ift,D'],
  
  // about Qup
    &{
    # log but dont e:elQups
    me.YingelQup_2 = &acgtR{
        4s&noelQups = &e{
             $D = me&log,R,'elQups'
             me&Delvis,R,D,e
        }
    }
    # catch e that wake:Ying
    me.Yingwhen_e = &acgtRe{
         if (e.t == 'elQups') {
             $D = me&log,R,'e:elQups',{e}
             me&Dtunneling,R,D
             return 1
         }
    }
    me.PaveelQup_5 = &acgtRs{
        $Q = Rs&Q
        $was = me&jaa,R,'isready',1 [0]
        $also = me&ja,R,'isready',0
        also != was and throw "wasi"
        $is = Qs&ready ? 1 : 0
        !(was == null || was != is) and return
        me&ha,R,{isready:is,dome:'isready'}
        me&log,R,'Q~'+is,{Q,node:s}
    }
    },
    ['noGump+Paving',0.55,&acgtRs{
        me&PaveelQup_5,R,s
    },'ift,D'],
]}