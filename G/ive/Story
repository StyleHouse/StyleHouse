# Yap
me.Sch_Story = &acgt{ return [

// Story - intents <-> extents
   
   =pod
    Story/** mark runtime difference along Plot/Point
     on %%quiet,wake: This &pageturn,
      marks where Plot%Page++ > Point
     < on %%wake or sync occurances of arbitrary etc
    we mark Point//-eight
     < locked into Story/** while marking,
        since testing and tested share Ying,
         should have some %%wake lock?
     usu spend a Page marking a Point
     if ok
       +Point:$next (on &pageturn) to continue
     else
       < Point%trouble = +Point:trouble
          no Pointc&Page_out until &accept
          locked into Story/**, consuming -eights
         then restart or resume after Point:trouble as if ok
          ignoring Point%trouble and Point:trouble,
         making this a messy testrun, semi-valid
          < Story/** and not may be separate enough?
     
    %TheNine can create|resume|update tests
     < subtests per Travel/$t
       or anything with a state to reset|repeat
       startStory,Adventure+
       eg:
     < shall go looking for %%may,
       ends up engaging a Gumpframe,
        which ... Travel/$t,
         Story letting the workflow,
         locking on %Pave, with bunch to push?
     
    -eight/-seven/**/-vat emerge
     gaining simpname from nodepile relations
      -vat -> -n|-C for sy&up does|not lead to a node
     < %Slope about sy&up, c.ip, etc.
     when ready:
      < to Dome slep the othering of R%Yingates
         if R%tunneling, wants update|change
          can we deliver e.c to specific wakers?
        from:
        %Yingates[-2..] (!%Fin) awake for streaming, then finish
         < %onlylish sometimes flaky until R:Ying itself happens
            knowing more &Yingwhen may find why,
            %Yingates/* also want selective waking
            yet it depends on *%ball%Peace and ^%Ying
    
    in bursts of activity:
     < hide most of the nodepile and nodes
     < regroupable, to Plot points
    
    once computed a bit,
      < know if weird, eg C not node or e
      < know if unexpected if $Storie
      and the whole bunch,
      < merge into similar previous %Yingates,
         waking [-3] to incorporate [-2]/*
          with %Yingates%onlyish + slep
           to keep most -gate|-seven (%Yingate),
           tallying into -eight again (%Yingates)
        by overall same-ness, looking for e:clicking
         < generated by Zif<->Lines<->C
      < ignore %Story/**, leaving only %%quiet,wake?
         could be implied by the ending of an -eight
        if e:click
          if %Story/**
           capture any adjusted ology for replay
            configuring magnifying glasses to produce test data
            not as e:clicks but as parameters on the %Yingate
             a Te proposed to be permanent,
              apply to others after it with Index?
            slep it to re-Y:pi accodingly,
           < Jx new modulat must ...
          else
           capture pointer|meanings for replay
            previously went quiet? (awaiting click) or:
             < e:click while thinking loses a &Yinge?
             < while at it, later[] may have R-d since
              
    storability:
      < the %Yingates/%Yingate -> -seven/-rows/-row/-vat becomes:
        %Storie/%Stori/-thing**
         %Storie+ are tapes to sync to $Story
         %Stori moment
          happens ||= s&when || next %Yingate
          s&rows breakdown pointing to **:
         -thing** as mentioned in s&rows, default -n
          see 'pile of nodes':
           say $step..$node, even if $step asleep
            maybe more if $node needs unique name
             in the -thing** and in the node pile,
              ie a %twmt across either,
               so Ghost..$z-node can point to the %dige%Q
                coming from a Duolish..$t-node...,
                 coming from a Travel..$t-node
       < or:
        -nine/-eight/-seven/-six/-five/-four/-three/-two/-one
          -nine a whole book
          -eight a chapter, lump of pages|trips
         %Yingate expanded about the aparatus of the plot:
          -seven a page, a trip to A.4|$Ying
            possibly more than one trip,
             ie %Jrunto many times between %Jproto
          -six the overall notion of change, plot pointering
          -five why doing (e|%Jproto plans)
          -four what doing (%Jrunto dome state)
          -three who (dome thing)
          -two part (A pointers)
          -one detail
         all may + Elsewheel, appears with developer
      
      # then Lines it
      < as diff against previous Lines (el:6?)
        web landscaping
      < which might turn into tiny Lines for $Storie:
          implying -nine/-eight/-seven/-n**, etc
          Lines[5] implies z + low light (ki d=4.23)
      < stable $Storie Lines indent -> type means:
         wide ack for similar tests|output
          subtracting normal: what most tests sound like
      
    < %The names %Plot for a new %Storie,
       Stu->toPave without %MayGansp

    < rebuild &waits_8, test against $Stories
    
    < @Story groups time, turns observe/respond corner
      pretending to be Fingo S-ing, providing:
        < log interesting acts
         eg CBing|Travel|Duolish starts|ends
        < log should be mergible with Yingu, Evelse, etc logs.
        shuntographer
        runs the game seq:
        < %Paving nice, found%Pave
        < @Story: %Paving+twinned ready
        < %Paving CB also from Ghost..$z
         diff Know..$s/found%Pave with:
          Know..$s%Paving itself
            eg %cha:Thing-has:dige,src:s,from:Q
          Ghost..$z%twin, as used by Travel..$t
            eg %%cha:Thing-has:dige,src:s,from:Q,to:z,t:t
        < %Gump gets Know..$s (+ Ghost/$t..$z)? out of date
        < @Story: %Paving+twinned+%Gump ready
        < %Story:
         any Ghost/$t..$z -> Travel/$t
         notices them vanish, knows why
        < @Story:
          start Travel/* wanted,
           pre-@Search the %Gump versions (%Jhost)
            inc anything in a $W.5, with wjs %args
          start Travel/$t
          end Travel/$t
          end Travel/*
          start Duolish/*
           $u should be as input to %Gump, or restart?
          end Duolish/*, when all is commit
   =cut
   
   // todo
    =todo
     
     -seven..-vat are Yingate's rows' properties
     
     < er diag, jam the Y:-seven until sorted,
        adjust ology|pointing or encoding after,
         usu define schema|depth-limit|reducer for random data
     
     -seven/-rows/-row/-vat
      -vat draws the something on the rows of -seven
     
     < -vat -> -row: brack in brack
       it would become a -row as well
     < -row:$b (anywhere) may include interesting by&up
       bc&shade, or the R/node/C via by&brack for it
       < leading back to a non-waker Yingate row,
         and then the r row that %%waits, etc
     < -row ref-itivity,
       maybe point to another -row (anywhere)
       esp as a later -seven/-rows/-row
       esp the one described in The**/Misc**
        collection of oddities (non-node items)
       or pool some misc upwards, on Misc accept:
        repile -row to point to it
        knowing that it was looking for it, eg &nodeo
     
     // less urgey
       < -R with sip|tip (serial or Te ip):
       < also know the R above R:Ying
         eg it starts with an %%e,to=Lingo-R c.o:^2
         see 'say $step..$node'
         -R names climb Rc&X beyond the last $node etc?
       < Ac&ip, like Y:Acec&ip or what Rc&ip could be,
          are per Run, per time finding names
         Cc&ip, like Jc&ip, Tec&ip or Xc&ip
          are per finding of the name, many times
         wave and particle, frames and movie
      
         # compression or re|de|piling:
         < stop at some -rows or -row if so simple,
           c&s = diagram pointering -thing** beyond
            or pointering nodepile if -n. gets complicated:
           changes (eg assigning c.ip) would need rolling out
            as some kind of change to auto-accept (%Zif)
             rename wants this
           novelty depiles back to -row/-vat
            to find &brackology to lay into
             and in general... diff long form, diag short form
    =todo
 
 // %Story itself
    ['Story',0.299,&acgtRs{
      // as non-%play
        me&reaw,R,'Story,Cu'
        me&inode,R
        $x = me&Jx,R
        
        # %play avoids running tests
        #  ie we are playing with the W
        $store = xs&Ying.t+"/Story%play"
        !Rc&b and Rs&play = (localStorage[store]||0) *1
        else {
            # sync %play once init
            localStorage[store] = Rs&play || 0
        }
        $play = Rs&play || 0
        me&introqua,R,{play}
        
        if (!Rs&play) {
            Rs&Shouldbeempty = 1
            me&tsc,"off",'','g'
            return
        }
        
      // as playing
        # quiet,wake:Story then Story/This
        #  ie settle non-Story**, then start Story
        sy&running = 1
        if (!sy&ever_quiet) {
            me&quiet_waker,R and sy&ever_quiet = 1
            !sy&ever_quiet and return
        }
        
        # changing Stories/Around
        me&ja,R,'Arounder' &&
            me&bal,'Arounder','Zaroum,eph'
        # sources of and tests
        me&bal,'Stories','Stories,eph'
        
        # expectation - where it begins
        
        # < Babz: o &bal,...
        #   io knowing i.bal likes to var $$t = C
        $r = me&bal,'The','The,eph'
        $The = rc&s
        #Thes&about ||= ['Fingo-init']
        # 
        Thes&about ||= ['Dealap']
        # max 400 Yings?
        #  left failing because Dealap toodiff as firstNine
        #Thes&about ||= ['vovol','Dealap']
        # max 490 Yings
        #  left failing while Jrunto learns logging
        Thes&about ||= ['vv','Easiness']
        
        # pile of nodes
        me&bal,'Nodar','Nodar,eph'

        # navigator
        me&bal,'Plot','Plot,eph'
        
        # experience
        $r = me&bal,'This','theThis,eph'
        # is visited to draw them into %Yingates/%Yingate
        # < lighter drawing into -eight/-seven
    },'ift,D'],
  // misc Story
    # negate %onlyish sleeping innards,
    #  lose history and make untunnelable
    ['Shouldbeempty',0.33,&acgtRs{
        # < stash history until?
        $N = grepout(Rs&z,r => rs&ball && rs&sleeping)
        me&losehistory,R,N
    },'ift,D'],
    &{
        me.losehistory = &acgtRN{
            N.map(&r{
                delete Rc&X.x[r.t]
                # ^ transacted, v not
                rs&ball and rc&s.y.invalide = 1
            })
        }
    },
    ['Storiz',0.33,&acgtRs{
        me&reaw,R,'Storiz'
        me&inode,R
        $p = Ry&up
        $pb = pc&b
        $b = Rc&b
        #pb && pbs&Shouldbeempty and debugger
        Rs&icount == 1 and G&yl:6000,&{ me&elvis,R,'leeks' }
        #Rs&icount == 2 and debugger
        me&nu,'wer',R
        #me&waits,"Formore"
    },'ift,D'],
 
 // %Stories/Stori/Eighi Live
   
  // %Stories%Pavings
    ['Stories',0.297,&acgtRs{
        
        me&reaw,R,'Stories'
        me&inode,R;
        $x = me&Jx,R;
        Rs&Pavings = 1
        Rs&directory = "Stories"
        ah(R,'inheritscif','ball','Stori',1)
        # < give nodeo pathia, %%inside=Stori,tw=Eighi
        ah(R,'adhere','twmt',s)
        # make W**%Paving mean W/J**,
        #  J directoried inside J^
        #  %Compiling used to W**
        #  suits compiling mountains of code,
        #  to give %Paving** that hierarchy
        #   eg remotes listen to the peak
        #  as views all named in the same space
        ah(R,'adhere','director',1)
        # species=1 only
        ah(R,'adhere','fully',1)
        # less Paving brains
        # < may %onlyish settle up etc
        ah(R,'adhere','noGump',1)
        
        $r = me&bal,"Around","Around"
        $The = xs&The
        if (!Rc&b) {
            $p = me.cbu(R,r => rs&Peace == 9).y.up
            p = ps&Te
            !py&Stories_init and Thes&very_first = 1
            py&Stories_init = 1
            each it Thes&about {
                # is 1: "0" && 1
                i > 0 && !Thes&very_first and break
                # the first time Story resets, warm cache
                # this will mess up L:startStory,
                #  which never sees async &t
                me&fiu,s,t
            }
            0 == i and delete Thes&very_first
        }
        s&hue = 66
    },'ift,D'],
    ['Stories+Pavings',0.2999,&acgtRs{
        me&bewind,R and return
        me&tsc,"SP"
    },'ift,D'],
    
  // Stori/Eighi?%Paving
    # loads if The/Stori wants
    # many Stori/Eighi%dige toc for directory=$Stori
    #  usu enough to pass tests where -eight%dige matches
    ['Stori',0.291,&acgtRs{
        #me&inode,R
        #!me&za,R,'waits' && me&sleepic,R and return ~>5 Sleeps: s.t
    },'ift,D'],
    ['Stori',0.298,&acgtRs{
        me&reaw,R,'Stori'
        me&tsc,"Stori"
        # has Eighi inside
        ah(R,'inheritscif','ball','Eighi',1)
        # Stori%twmt=Stories, Stori/**%twmt=Stori
        #  does its own %eto,tw for its Eighi
        ah(R,'adhere','twmt',s)
    },'ift,D'],
    
    # loads if Stori wants
    # download details to difference an -eight
    ['Eighi',0.33,&acgtRs{
        #me&sleepic,R and return
        me&reaw,R,'Eighi'
        
        #me&tsc,"Eighi:"+ki(Rs&twmt,2)
    },'ift,D'],
   
  // Around** < until -pipe good
    # loads, small list of potential Stori
    #  could be in each A.4 (W:Lingo) Stories,
    #   outsphere of Story/Stories
    #  since Stories%eph we must store our list
    ['Stori+Around',0.294,&acgtRs{
        me&reaw,R,'Around,onitself'
        me&inode,R
        # does its own %eto,tw
        ah(R,'adhere','twmt',s)
        #me&scroll,10
        # has ourself inside:
        #me&bal,"Around","Zaroum,eph"
    },'ift,D'],
    ['Stori+Around',0.7,&acgtRs{
        $x = me&Jx,R
        $Q = me&PaveQ,R,s
        Qc&el == 9 || x.ro("Arou",{}) and me&nodei,R,xs&Story,"Arounder"
    },'ift,D'],
    
    # like TheTest (stages Around)
    ['Zaroum',0.291,&acgtRs{
        me&reaw,R,'Zaroum,onitself'
        #debugger
        me&inode,R
        Rs&acceptables = 1
        me&tsc,"Zaroum"
        
        me&bal,"Around","Zaround,eph"
    },'ift,D'],
    ['Zaroum',0.294,&acgtRs{
        $h = {
            ytag: 'origin',
            self: &acgtnt{
                $r = me&bal,"Re:"+t.t,'ReArou,unity,eph'
                $z = rc&s
                return z
            },
            other: &acgtntzlm{
                return me&fiu,z,l.t
            },
        }
        me&acceptables_reother,R,h
    },'ift,D'],
   // ReArou
    ['ReArou',0.295,&acgtRs{
        me&reaw,R,'ReArou,unity'
        ah(R,'inheritscif','ball','ReArou',1)
    },'ift,D'],
    ['ReArou+unity',0.35,&acgtRs{
        $N = me&ioty,R,'ReArou'
        s&bg = '#180213'
        # Accepting:Push
        me&toPaves,R,[R,...N]
    },'ift,D'],
    # ReArou** difference and flock apply again
    ['ReArou',0.33,&acgtRs{
        $go = me&acting,R,'Re'
        $x = me&Jx,R;
        # the got, being pushed, is 
        $The = sy&origin
        $t = me&twineThat,R,The,{origin:xs&Stories}
        t and me&toPave,R,R,t,The

        go and me&nu,"The",The
        !t and return
        $r = ty&R
        $Q = rs&Q;
        if (go) {
            me&nu,"Q",Q
            me&nu,"P",Qs&P
        }
    },'ift,D'],
    
    
   // Zaround
    # like TheNine (for Around)
    ['Zaround',0.33,&acgtRs{
        me&reaw,R,'Zaround,onitself'
        #debugger
        me&inode,R
        me&tsc,"Zaro"
        $x = me&Jx,R
        $that = me&getThat,R,xs&Stories,"Around"
        !that and return
        #me&nu,'that',that
        $self = me&selfThat,R,that
        #me&nu,'self',self
        
        $r = me&bal,s.t,self,'ZaTen,eph'
    },'ift,D'],
    ['ZaTen',0.294,&acgtRs{
        me&tsc,"ZaTen"
        me&reaw,R,'ZaTen,bal_tw_s'
        Rs&acceptables = 1
        ah(R,'inheritscif','ball','ZaNine',1)
        $go = me&acting,R,'Nine'
        $x = me&Jx,R;
        $Plot = xs&Plot
        sc&pi = 'Arou'
        # roll the invention of Eigh s
        me&sleepic,R and me&rollbs,R,'bal_tw_s'; return
        
        if (!me&ioty,s .length) {
            me&fiu,s,"Roundness"
        }
    },'ift,D'],
    ['ZaTen',0.67,&acgtRs{
        $N = me&ioty,R,'ZaNine'
        # -nine settles the -eights, see &sleepic
        # < create new &settles and go to sleep
        #me&settle,R,N && me&sleepic,R,2 and return
        me&acceptables,R,N
        $c = {
            
            # Eigh have inside:
            #  t may be accepted in-change
            # outside:
            #  merely reincludes Nine/$z (Eigh%exp)
            #  z%* or z/* may have been changed
            #   are meta or recipe for the running of it
            # z separates to allow y&up=O, keeps s&z, y&*
            # < align diff chunks outside Nine/($z**)
            #    per Nine/($t** inside)
            
            # an Eigh accepted again
            accept: &acgtsOrznt{
                me&accept,R,t
                $dige = me&storable,t
                # Nine/$z links /$eight
                $Z = G&Cye,z
                me&fiu,O,Z,2
                Zc&pi = 'eight'
                Zs&dige = dige
            },
            # an Eigh still
            sleep: &acgtsOrz{
                $Z = G&Cye,z
                me&fiu,O,Z,2
            },
            # the Nine itself
            self: &acgtsO{
                me&Linets,s,O
                me&accept,R,s
            },
        }
        me&acceptables_reself,R,N,c
    },'ift,D'],
    ['ZaNine',0.291,&acgtRs{
        me&inode,R
        me&tsc,"ZaNine"
    },'ift,D'],
 
 // %The/Test/Nine/Eigh pos
  
  // 1 %TheTest o Stori
    ['The',0.292,&acgtR,The{
        me&reaw,R,'The'
        me&inode,R
        $x = me&Jx,R
        ah(R,'inheritscif','ball','TheTest',1)
        # init The/$t/$t
        #  which %%Nine -> Plot, then <-> eight
        $Story = xs&Story
        $about = uniq([
            # < load all %about from the start
            #   needs to make a Nine current
            Thes&about[0],
            ... me&jaa,R,'Nine',1 ,
        ])
        each it about {
            $n = me&fiu,The,t
            i == 0 and ns&firstNine = 1
        }
    },'ift,D'],
    # -nine being Zavable
    ['TheTest',0.294,&acgtRs{
        
        me&reaw,R,'TheTest,shelf'
        me&rollbs,R,'shelf'
        Rs&acceptables = 1
        $go = me&acting,R,'Test'
        $x = me&Jx,R;
        # wants to get Stories/$t(/$bits)
        #  and commit them all at once, with history
        #  and commit $t -> Stories/Around
        $that = me&getThat,R,xs&Stories,s.t
        !that and return
        
        $The = xs&The
        if (Thes&very_first) {
            # reset after warming cache
            $p = me.cbu(R,r => rs&Peace == 9).y.up
            !ps&JRom and throw "where"
            ps&reset = 1
        }
        
        # then harness %Live into TheNine
        # < harness self (TheNine<->...) <-> other (Paving)
        $self = me&selfThat,R,that
        
        # doesn't reload Nine/Eigh
        # < unless it looks pulley
        #   without losing all the L-mapping etc: lv in?
        !Rs&shelf and Rs&shelf = self
        else
        self != Rs&shelf and me&tsc,'re-self',0,'g'
        self = Rs&shelf
        
        # < a Stori could compose many Stori,
        #    a Stori = plot - subplots
        #     subplots pointed to, recipised to solo:
        #      being vague about -nodes,
        #      templating the test data for inputs from Stori,
        #      from Zif noticing only $t, $begin|end_dige change
        $r = me&bal,s.t,self,'TheNine,eph'
        rc&s != self and me&nu,"Craze",rc&s
        sy&Nine = self
    },'ift,D'],
       
  // 3  %TheNine -> $eight
    # Nine/$exp + Story/-eight%Yingates
    #  = Nine/Eigh%exp+%got
    ['TheNine',0.295,&acgtRs{
        
        me&reaw,R,'TheNine,bal_tw_s'
        Rs&noRsync = 1
        Rs&acceptables = 1
        $go = me&acting,R,'Nine'
        $x = me&Jx,R;
        $Plot = xs&Plot
        sc&pi = 'nine'
        # roll the invention of Eigh s
        me&sleepic,R and me&rollbs,R,'bal_tw_s'; return
        
        if (sy&autoviv && !me&ioty,s .length) {
            ac(Plot,'autovivNine',s.t)
            if (ss&firstNine) {
                # init something for &Plot_Default to begin on
                #  usu tests grow off the end of others and never:
                # need to ignore startup (2 Pages, by the time Plot&init)
                me&fiu,s,['beginning',1,{},{L:'startup',ignore:'start'}]
                # and then this will turn into something
                me&fiu,s,['le-3',1,{},{L:'further'}]
            }
            else {
                # the next Test, Pages probably renumbered like so:
                me&fiu,s,[s.t+'-1',1,{},{L:'intoit'}]
            }
        }
        # $Nine cloned from a Stories/Stori
        # $Nine/* become Eigh%exp (have %dige, instructions)
        # these eight -> Eigh%got (have %dige%string, y&Point=$L)
        # < %%Having,eight come in order?
        $gotN = me&jaa,R,"eight,Having,L",1
        me&twlic,gotN,s (&lzct{
            $r = c.surprise ? me&bal,t,'eph'
                : me&bal,t,l
            
            ex(r.sc,c)
            #me&tsc,"Ergo:"+t+(ki(c)) .sc.dis = 1
            
            rs&TheEigh = 1
            l and rs&exp = l
            z and rs&got = z
        })
    },'ift,D'],
    # next to TheEigh
    ['EighExp',0.32,&acgtRs{
        me&reaw,R,'EighExp,title'
        s&bgh = '000'
    },'ift,D'],
    
  // 4  %TheNine <- $eight
    # many acceptables
    ['acceptables',0.295,&acgtRs{
        me&reaw,R,'acceptables,reself'
        me&rollbs,R,'reself'
    },'ift,D'],
    ['TheNine',0.67,&acgtRs{
        
        $N = me&ioty,R,'TheEigh'
        # -nine settles the -eights, see &sleepic
        # < create new &settles and go to sleep
        #me&settle,R,N && me&sleepic,R,2 and return
        me&acceptables,R,N
        $c = {
            
            # Eigh have inside:
            #  t may be accepted in-change
            # outside:
            #  merely reincludes Nine/$z (Eigh%exp)
            #  z%* or z/* may have been changed
            #   are meta or recipe for the running of it
            # z separates to allow y&up=O, keeps s&z, y&*
            # < align diff chunks outside Nine/($z**)
            #    per Nine/($t** inside)
            
            # an Eigh accepted again
            accept: &acgtsOrznt{
                me&accept,R,t
                $dige = me&storable,t
                # Nine/$z links /$eight
                $Z = G&Cye,z
                me&fiu,O,Z,2
                Zc&pi = 'eight'
                Zs&dige = dige
            },
            # an Eigh still
            sleep: &acgtsOrz{
                !rs&exp and return
                rs&exp != z and debugger
                $Z = G&Cye,z
                me&fiu,O,Z,2
            },
            # the Nine itself
            self: &acgtsO{
                me&Linets,s,O
                me&accept,R,s
            }
        }
        me&acceptables_reself,R,N,c
    },'ift,D'],
  
  // 6  %TheEigh 
    ['TheEigh',0.33,&acgtRs{
        me&reaw,R,'TheEigh,exp,got,now_missing'
        $x = me&Jx,R
        $go = me&acting,R,'Eigh'
        
        $t = Rs&exp
        $z = Rs&got
        $L = z && zy&Point
        
        # z-eight is already Lineso:
        $Dige = z && zs&dige
        $cha = !Dige || !me&za,R,{Dige}
        Dige and me&ha,R,{Dige}
        !cha && me&sleepic,R and return
        if (go) {
            me&zu,"TheEigh",s
            me&zu,"Exp",t
            me&zu,"Got",z
            me&zu,"Point",L
        }
    },'ift,D'],
    ['TheEigh',0.36,&acgtRs{
        
        $t = Rs&exp
        $z = Rs&got
        me&Pointness
        
        # has -eight happened (got got)
        !z || !zs&dige || !zs&string and return me&ha,R,'unready'
        # < exp ||= surprise?
        
        # from here, it's a &toPave that doesn't pushPave at the end,
        #  instead sending the flock of storables onward
        me&acceptable,R,z,t
        
        # < probably want Qdiff,z,t=null
        #    or know t is a link, do &moreThat
        #    or t could be this step's part of another &Linets
        #     and need to other it there and then commit that,
        #      staging chunk regroup for commit essential
        #     lots of slightly different %%$word...,
        #      iterating commissions on 
        if (me&ja,R,'ok' ) {
            s&bgh = '041'
            # &Effect needs to be permanent (or %%dome)
            me&Effect,s,zy&eight,'isok',{ok:1,ope:0}
            if (!me&za,R,'ok' ) {
                me&yyt,z,'on_ok',R,s
            }
            return
        }
        # when Story is recording itself,
        # these all cause that -eight to show the failing, etc
        if (!t) {
            me&log,R,"Unexpected",{got:z}
            return
        }
        if (me&za,R,'unready' ) {
            me&log,R,"Failing",{got:z}
            if (Rs&trailing) {
                # beyond last expected thing
                me&log,R,"Trailing"
            }
        }
        # receive the got into a diff against the full self
        !(tc&pi && ts&dige) and return me&tsc,"Nine/!-eight"
        
        $self = me&moreThat,R,t,t
        !self and return me&waits,"Nine/.."
        
        $Q = me&PaveQ,R,selfy&That
        
        me&Qdiff,R,z,Q
        # < to &brackology
        # < mergible
    },'ift,D'],
  
  // 7 %ReNine reselfs <- %TheNine
    # < i $t... ytia o %%acceptia:t
    ['TheTest',0.294,&acgtRs{
        $h = {
            ytag: 'origin',
            self: &acgtnt{
                $r = me&bal,"Re:"+t.t,'ReNine,unity,eph'
                $z = rc&s
                return z
            },
            other: &acgtntzlm{
                return me&fiu,z,l.t
            },
        }
        me&acceptables_reother,R,h
    },'ift,D'],
    ['ReNine',0.295,&acgtRs{
        me&reaw,R,'ReNine,unity'
        ah(R,'inheritscif','ball','ReNine',1)
    },'ift,D'],
    ['ReNine+unity',0.35,&acgtRs{
        $N = me&ioty,R,'ReNine'
        s&bg = '#180213'
        
        # Accepting:Push
        me&toPaves,R,[R,...N]
        # engages
        # < subscribe to Q-1 for this
        me&da,R,'Pushable,go'
            && me&log,R,'Pushabilityofthethingthatisnow'
        
        # completes: L%resumed for any fixed up
        me&da,R,'allok:Push'
            && uniq(me&ioty,R,'ReNine' .map(&r{
                    $z = rc&s
                    $ze = zy&origin
                    return zey&Point
            })).map(L => me&ReNine_pushed_Point,R,L )
    },'ift,D'],
    # ReNine** difference and flock apply again
    ['ReNine',0.33,&acgtRs{
        $go = me&acting,R,'Re'
        $x = me&Jx,R;
        # the got, being pushed, is 
        $The = sy&origin
        # into the enclosing Stories or /Stori**
        # < because pipe can go back through Nine &reother,
        #    and Test/Nine &reself
        $t = me&twineThat,R,The,{origin:xs&Stories}
        # < ReNine species
        t and me&toPave,R,R,t,The

        go and me&nu,"The",The
        !t and return
        $r = ty&R
        $Q = rs&Q;
        if (go) {
            me&nu,"Q",Q
            me&nu,"P",Qs&P
        }
    },'ift,D'],
 
 // This%Storystream
  
  // Outlog/* group into Pages -> /$eight
    ['theThis',0.293,&acgtRs{
        me&reaw,R,'theThis,wakeful,onlyish'
        me&inode,R
        # wake R when p%onlyish/R%wakeful
        Rs&wakeful = 1
        # sleep r when R%onlyish/r!%wakeful
        Rs&onlyish = 1
        
        $Ying = me.cbu(R,'Ying')
        $c = {s:Yings&Outlog}
        me&Storystream,R,s,c
    },'ift,D'],
    ['theThis',0.296,&acgtRs{
        $D = Rs&Storystream
        $x = me&Jx,R
        # draw the story, probably chunked by a %%quiet
        each im Ds&z {
            mc&pi ||= 'eight'
            # %onlyish 294 has made these if sleeping them
            $r = me&bal,m.t,m,'Yingates,eph'
            rc&s != m and throw 'crae'
        }
        # leaves current -gate streaming
        r and rs&wakeful = 1
    },'ift,D'],
        
    # when e,on:m%Yingates, it keeps filling up
    ['sleeping+Storystream',0.53,&acgtRs{
        $D = Rs&Storystream
        # < want to have a sleeping This just for this
        #    more often than waiting til quiet
        #   moment to picture things before they ~ again
        Dy&stream()
    },'ift,D'],
    &{
    me.Storystream = &acgtRsc{
        
        $x = me&Jx,R
        me&reaw,R,'Storystream,pause'
        me&rollbs,R,'Storystream'
        $D =
        # < it having a Y to consider, slepvia
        sy&Storystream =
        Rs&Storystream ||= me&logdome,R,s
        !c.s and throw "thing to follow"
        Dc&thing = c.s
        Dc&ignoring = x.ro('pause',{})
        
  // Ploty&Pageturn(ing)
        # page turning
        # may be unturned, see merge similar previous
        # < turn fractions of a page|plot, when|why
        $Plot = xs&Plot
        $This = s
        # just the turney bit
        Thisy&Pageturn = &q{
            # othery before turn: make name
            $t = me&yyt,Plot,'Pageturning',R,D
                || "blank-"+(1+hak(Ds&z))
            # close
            Dy&domed(q)
            # open
            Dy&dome(t,'light')
            return D
        }
        $page_turning = &q{
            # turney bit:
            me&yyt,This,'Pageturn'
            
            # othery &Plot_Pageturn responds to it
            me&yyt,Plot,'Pageturn',R,D
            
            $i = Ds&z.length
            i > 15 and Rs&pause = 1; ss&overturning = 1
            # < Plot leaves tightenable hooks
            #   for Yingate_2 -> Outlog -> next:
        }
        # when it matters, want to self,
        #  even if too close to the last quiet,wake (loop avoidance)
        $Y = me.cbu(R,'Ying').sc.Ying
        Ys&quiet_wakers_too_recently = &R{
            #~>4 pagequiet: Plots&Page
            # can sometimes want to happen:
            #  must self to act first in the next Page
            #   < supposing multiple layers of quiet_wakers
            me&yyt,Plot,'Pageturnable',R,D and return 1
            page_turning()
        }
        
  // usu on a quiet wake
        # takes over from Story
        $q = me&quiet_waker,R
        q ||= !sy&quue
        sy&quue = 1
        if (q) {
            me&tsc,"q";
            #~>4 quiet,wake: s.t
            $Ying = xc&Ying
            !Yings&Det and throw "!Det"
            $q = {}
            if (1) {
                # until the current Outlog:D
                #  so pages|-eights end with %%quiet(_recently,wake)
                q.until = Yings&Det
            }
            else {
                # OR, not. have on the old page:
                #  quiet waking %%node:This..
                #  < log:Pageturn...Point++ etc
                #   takes a few wakes to ready the next Point,
                #  should be on the old page?
                #   since they mention the old Point
                #  which is likely to be %%Ignored
                #   or grepo everything from Story**
                #    see Ying only in or out of some subnet
                #    may take templating the new Point in the old page,
                #     for a beginning with many different middles parametised
                #     watching the new Point set up there too
                #      and stream() just before it really starts
            }
            page_turning(q)
        }
        # then inhaling nothing if the page was just turned ^
        Dy&stream()
    }
    },
 
 // This/$eight/$seven details
   
  // $eight/$seven
    ['Yingates',0.296,&acgtRs{
        
        me&reaw,R,'Yingates,wakeful,who'
        me&inode,R
        $x = me&Jx,R
        Rs&rowish = 1
        # R/* become %Yingate!%ball
        Rs&noRsync = 1
        
        $E = Rs&eight = me&pieight,R,s,1
        $L = sy&Point
        
        if (Rs&wakeful) {
            # no -eight, yes -seven
            # < or -eight without &enL?
            me&tsc,"wakeful",0,'g'
        }
        else {
            # complete -eight
            Rs&Fin = 1
        }
        
        each in ss&z {
            $r = me&Ret,R,{t:"n:"+i,s:n,Yingate:1}
        }
    },'ift,D'],
   
  // -seven -> &brackology
    # < self a -seven
    #   has a &brackology + more
    # < brackology rearranging so node:Gilramp=wake
    # < saying when node:Travel..Gilramp
    ['Yingate',0.32,&acgtRs{
        sy&R = R
        $p = Ry&up
        $z = pc&s
        
        sc&pi ||= 'ugh'
        s&hue = 138
        # -seven...-ologise also colours it
        
        # have serials now interspersed
        # < notice c&i per c&pi?
        sc&i != null &&
            n Dci 01 $s:sc&i %fs:8
        # may be  (Dc&i per Dc&pi?)
        $zi = zs&z.indexOf(s)
        
        me&piseven,R,s,{t:zi,D:s}
    },'ift,D'],
    
    # < othering back into &brackology any novelty
    ['Yingate',0.44,&acgtRs{
        me&reaw,R,'Yingate'
        Rs&rowish = 1
        !sy&seven and return
        $x = me&Jx,R;
        $go = me&acting,R,'-seven',0
        
    },'ift,D'],
   
  // -eight/-seven
    # -eight collects -four,-seven+
    #  -seven selfs &brackology
    #   < slep
    # other it/them to:
    #  c.expect: Nine/$t
    #   < chunk difference
    #  c.nlist: official nodes
    #   -n can tpath relative to their name
    # < see Atiming of R,R/*, adjust cv for less rounds
    ['Yingates+Fin',0.33,&acgtRs{
        
        me&bewind,R and return
        Rs&fixatfour = 1
        $x = me&Jx,R;
        $go = me&acting,R,'-eight',0
        
        $E = Rs&eight
        $L = me&Pointness
        L != sy&Point and debugger
        
        # page of story: -eight a %Yingates
        $c = {ov:0.4}
        $Ch = c.Checkable = me&jaa,R,'Checkable,efrom' [0]
        if (Ch) {
            c.ov = 0.9
            # have name pile
            $No = xs&Nodar
            $X = Noy&X
            c.nlist = X.ss
            # Nine/$t instrunction
            $z = Chs&expect
            z and c.expect = z
            go and me&zu,"exp",z
            # send results
            c.Finto = Chs&efrom
        }
        else {
            if (L && Ls&checking) {
                # unchecked checkingness
                #  esp avoid if %Fuguing
                #   it will be loading more test data to diff
                me&Effect,s,E,'acheck','Ignored,ope:0'
                me&tsc,"acheck",0,'g'
            }
            elsif (me&ja,R,'Ignored' || me&ja,R,'Ignorable') {
                # ^ from This noticing no L for it, or ^ reason:
                # < that it was expected:
                $why = me&ja,R,'Ignorable',0
                $n = me&tsc,"Ignored:"+(why||"?"),"Ignored","g"
                !why and ns&fs = 18
                me&Effect,s,E,'Ignored','Ignored,ope:0'
            }
            elsif (Rs&icount < 5) {
                # start hidden, later Effect:diff reveals
                me&Effect,s,E,'hid',{hid:1,ope:0}
            }
        }
        
        me&pieight,R,s,c
        
        if (Ch) {
            # -> Eigh
            # randomly not part of %%Checkable circuit
            me&nodei,R,Chs&efrom,{Fin:s,dige:ss&dige}
        }
        else {
            !Es&Ignored and me&tsc,"..Checkable"
        }
    },'ift,D'],
   
 
]}