# go there for ...
# having to contribute
  
    // for Brackio
        # index n by n%*
        #  X/k/ref(s) enumerate columns and their values
        # ongoingly to index N-news into X
        me.brackX = &acgtNX{
            X ||= {};
            X.k ||= {};
            each in N {
                each kv n.sc {
                    $x = X.k[k] ||= {};
                    # without ref(s):
                    x.z ||= [];
                    x.z.push(n);
                    # by id of the value
                    $fs = x.refs ||= [];
                    $vi = fs.indexOf(v);
                    vi < 0 and vi = fs.push(v)-1
                    $f = x.ref ||= {};
                    $fx = f[vi] ||= {};
                    fx.z ||= [];
                    # a row
                    fx.z.push(n);
                }
            }
            return X;
        }
    // for Nodar
      =write or read (autovivificatorialy)
        X.$someindex ||= x += $r
       leading to x, another|inside X via $someindex
       x remembering what indexes it is in?
        joins|varies by x.z/r,
         the members being added to x locatable space
      =cut 
        # the X/$t += r
        # r could be Y, s (C), X|x, anything
        # in &RbitXarrive it is R, &brackX it is a row
        me.X_t = &acgtXtrk{
            k ||= 't'
            X[k] ||= {}
            $x = X[k][t] ||= {};
            x.z ||= [];
            r && x.z.push(r)
            return x
        }
        # the X/uniq($s) += r
        me.X_s = &acgtXsr,kf{
            kf ||= 's'
            return me&X_refer,X,s,r,kf
        }
        me.X_refer = &acgtXsr,kf,kfs{
            !kf and throw "named"
            kfs ||= kf+'s'
            # by id of the value
            $fs = X[kfs] ||= [];
            $vi = fs.indexOf(s);
            vi < 0 and vi = fs.push(s)-1
            $f = X[kf] ||= {};
            $x = f[vi] ||= {};
            x.z ||= [];
            r && x.z.push(r);
            return x
        }
    
 // jobs
    // &twlic, &twlim - tw matchup
        # as twlim but with one r?,l? callback
        me.twlic = &acgtNL{
            return &y{
                $M = []
                # returns list of y returns
                $ya = &zlc{
                    c ||= {}
                    c.t ||= l && l.t || z.t
                    $t = delete c.t
                    M.push(y(z,l,c,t))
                }
                $con = me&twlim,L (&lc{ ya(null,l,c) })

                N.map(&t{
                    $z = isR(t) && ts&ball ? tc&s : t
                    $l = con(z)
                    ya(z,l)
                })
                con()
                
                return M
            }
        }
        # consume L/* by t one at a time in order
        #  y(L) for missing
        me.twlim = &acgtL{
            $used = L ? me&ioty,L : []
            $for_missing
            return &y{
                for_missing = y;
                return &s{
                    !s and used.map(l => for_missing(l)); return
                    $l = L && me&fiu,L,s,8
                    if (l) {
                        $li = used.indexOf(l)
                        # before found now missing
                        li > 0 && used.splice(0,li)
                            .map(l=> for_missing(l,{now_missing:1}));
                    }
                    return l
                }
            }
        }
