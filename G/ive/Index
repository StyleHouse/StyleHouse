# go there for ...
# having to contribute
  
    // for Brackio
        # index n by n%*
        #  X/k/ref(s) enumerate columns and their values
        # ongoingly to index N-news into X
        me.brackX = &acgtNX{
            X ||= {};
            X.k ||= {};
            each in N {
                each kv n.sc {
                    $x = X.k[k] ||= {};
                    # without ref(s):
                    x.z ||= [];
                    x.z.push(n);
                    # by id of the value
                    $fs = x.refs ||= [];
                    $vi = fs.indexOf(v);
                    vi < 0 and vi = fs.push(v)-1
                    $f = x.ref ||= {};
                    $fx = f[vi] ||= {};
                    fx.z ||= [];
                    # a row
                    fx.z.push(n);
                }
            }
            return X;
        }
    // for Nodar
      =write or read (autovivificatorialy)
        X.$someindex ||= x += $r
       leading to x, another|inside X via $someindex
       x remembering what indexes it is in?
        joins|varies by x.z/r,
         the members being added to x locatable space
      =cut 
        # the X/$t += r
        # r could be Y, s (C), X|x, anything
        # in &RbitXarrive it is R, &brackX it is a row
        me.X_t = &acgtXtrk{
            k ||= 't'
            X[k] ||= {}
            $x = X[k][t] ||= {};
            x.z ||= [];
            r && x.z.push(r)
            return x
        }
        # the X/uniq($s) += r
        me.X_s = &acgtXsr,kf{
            kf ||= 's'
            return me&X_refer,X,s,r,kf
        }
        me.X_refer = &acgtXsr,kf,kfs{
            !kf and throw "named"
            kfs ||= kf+'s'
            # by id of the value
            $fs = X[kfs] ||= [];
            $vi = fs.indexOf(s);
            vi < 0 and vi = fs.push(s)-1
            $f = X[kf] ||= {};
            $x = f[vi] ||= {};
            x.z ||= [];
            r && x.z.push(r);
            return x
        }
    
    