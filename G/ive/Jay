# fangs
me.Yingmind ||= {};

 // n 1
        me.Yingmind.n = &acgt{ return [
        # s = C
        # < many C in one n, implied layer of doming
        ['ground',0.01,&acgtRYs,SC{
            sy&R = R;
            Ys&leamity = 3;
            if (sc&W) {
                $to = Ys&to;
                !to and throw "!to"
                sc&J ||= me&fiu,to,s.t;
            }
            if (sc&J) {
                Y.1 and Y.2 = Y.1
                $J = Y.1 = sc&J;
                # < want Jhost t&w:J.t
            }
            if (sc&e) {
                $e = sc&e;
                # < see if any dome:e contain e Asip,
                #   or any along e cby, where it has been
                
            }
        },'ift,D'],
        # ghost suction
        ['realise',0.2,&acgtRYs,SC{
            if (sc&J) {
                # < Jy&Y
                me&Yingbal,'J:'+s.t,s
            }
        },'ift,D'],
   
 // n 5
        # atom -> atoms
        ['tick',0.5,&acgtRYs,SC{
            $C = s;
            s = Cc&s;
            T.nN = [];
            # A=Y must serve G&t for A.I, have 4s&globals
            Y.6 = Y.4 = A.4;
            Y.7 = A.5;
            $D = Ys&Doming = me&Yingdome,R,Y,C;
            $Aye = A;
            A = Y;
            1s&N = [];
            if (c&J) {
                $pin = c&W;
                !pin and throw "huh"
                me&way,R,pin,{J:A.1,s}
            }
            A = Aye;
            Dy&ending()
        },'ift,D'],
        ['tock',0.7,&acgtRYs,SC{
            $D = Ys&Doming;
            $t = Ys&osc = me&Yingosc,R,s,D;
            # if this has a diff it can takeover a branch
            A = Y;
            if (ts&top) {
                $op = 1s&top = ts&top;
                if ('osc' == 'out replaces Cz in...') {
                    sy&tw = {};
                    ss&z = [];
                    me&ioty,op .map(z => me&fiu,s,z )
                }
                1s&hold and return
                sy&A = Y;
            }
            else {
                # unfinished
                1s&N.push(Y)
            }
        },'ift,D'],
    ]};
   
 // &Yingdome
    # (Travis)
    me.Yome = &acgtRs{
        $D = me&Yong,R,s,'Doming',{},1
        # for a S+ay
        Dy&dome = &tc{
            isst(c) and c = G&peel,c
            c ||= {};
            c.t = t;
            return Dy&current = me&Yong,R,D,'Dome',c,1
        }
        # or on either end of them,
        # before the first S:
        Dy&dome('beginning','light')
        # after them. %light vanishes if empty
        Dy&ending = &{
            Dy&dome('ending','light')
            Dy&domed()
            me&Yong,R,D,{},2;
        }
        # commit current
        Dy&domed = &{
            !Dy&current and Dy&dome('middling','light')
            Dy&download and $sc = Dy&download()
            else {
                throw "Yome!y&download"
            }
            isar(sc) and sc = {N:sc}
            sc and me&Yong,R,Dy&current,sc,2
            Dy&current = null
        };
        return D
    }
  // Y:Doming|Dome
    # < turn into something
    # < slep
    me.Yingmind.Doming = &acgt{ return [
        # C
        ['ground',0.01,&acgtRYs,SC{
            return Cye([s.t,3])
        },'ift,D'],
    ]};
    # piece of things
    me.Yingmind.Dome = &acgt{ return [
        # C
        ['ground',0.01,&acgtRYs,SC{
            $t = Ys&t;
            !t and throw "!t"
            $z = me&fiu,s,t
            return z
        },'ift,D'],
        ['ground',0.13,&acgtRYs,SC{
            each in Ys&N {
                ac(s,'z',n)
            }
            Ys&light && !ss&z.length and me&fiu,sy&up,s,9
        },'ift,D'],
    ]};
    
  // frontends
    # N = %Ying%Outlog tracking
    me.logdome = &acgtRs{
        $D = me&Yome,R,s
        # < feedread ^^%Ying%Outlog
        Dy&download = &{
            $N = Dc&thing
            !N and throw "!thing"
            $sc = {}
            N != Dc&last_thing and sc.chathing = 1; Dc&i = 0
            Dc&last_thing = N
            N.length > Dc&i+1 and sc.N = N.slice(Dc&i+1)
            Dc&i = N.length - 1;
            return sc
        }
        return D
    }
    # A:n having S
    # ie the whole attention span
    me.Yingdome = &acgtRYs{
        $D = me&Yome,R,s
        me&Yingbal,'%Doming',D
        
        # grounds adopted from recent: n ...
        Dy&download = &{ return me&ydome }
        
        # Section deciver
        Yc&Srupto = &acgtst,talk,params{
            #~Srupt: s, ':', t, '%', talk
            
            # whatever is over now:
            Dy&domed();
            # various minds:
            A&Sonly && num(s) && s != A&Sonly and return 0
            A&ioing and return A&ioing.next()
            # vaguely named:
            t ||= s;
            # to happen once:
            A&doings ||= {};
            $l = A&doings[t] ||= {};
            if (l.done) {
                l.done < 2 and Dy&domed()
                l.done = 2
                return
            }
            l.done = 1;
            Dy&dome(t);
            #~sttalk: ki([s,t,talk,params]);
            return 1;
        };
        
        return D
    };
    
   
 // &Yingosc
    me.Yingosc = &acgtRsD{
        $s = me&Yong,R,s,'osc',{D:D}
        me&Yingbal,'%osc',s
        me&Yong,R,s,{},9
        return s
    }
    # < C from dome or so
    me.OsC = &acgtsDc{
        c ||= {};
        # < indo should use c, so c.O after is first
        $first;
        me&indo,D,c (&nd{
            $O = Cye(n);
            Oy&n = n;
            d.O = O;
            first ||= O;
            d.only and d.nofurther = 1; return
            # < flatten later, when swims back
            #   to keep both zeal%of:i and zeal%of:J
            #   so such a thing can be considered by the encoder
            $p = d.up && d.up.O || s;
            $dup = me&fiu,p,n.t,8;
            # < merge, io
            # < brack this so we old,neu
            dup && p == s and ac(s,'dups',dup)
            me&fiu,p,O;
        }) [0];
        return first
    }
    me.Yingmind.osc = &acgt{ return [
        # C
        ['osc',0.01,&acgtRYs,SC{
            return Cye([s.t,3])
        },'ift,D'],
        
        ['i Domings',0.5,&acgtRYs,SC{
            $Doming = Ys&D;
            each i,Dome Domings&z {
                each in Domes&z {
                    me&OsC,s,n
                }
            }
            # A:n magnet, was T.op, 1s&top etc
            $p = sy&up;
            $Yp = py&Y;
            Ypc&t != 'n' and throw "!n"
            
            $t = Ys&top = me&OsC,s,p,{only:1};
            # < ty&Y? per &Yong (argable A)
            #   each osc could coopt $t as far as it is worth keeping,
            #   eg for shared objects that dont need to pull,
            #    ie t@2 (get via J) to download new object with changes
            ty&osc = s;
            Yc&M = [Ys&top,...ss&z];
        },'ift,D'],
      // 6 swims
        ['o swims',0.6,&acgtRYs,SC{
            #~>4 sea: Y.t, s.t
            $C = s;
            $s = Ys&returns;
            c&s and s&strinoge = c&s.split("\n").length
            
            # %of travel to W:of for encoding!
            $swims = {of:'i'}
            each kt swims {
                # < ha,Y,eto:W,t:s&of,W:of
                #   W routing to Jproto,
                k == sc&W and continue
                C.sc[k] == 1 and C.sc[k] = t
                C.sc[k] && !C.c[k] and ah(Y,['swims'],k,C.sc[k],C)
                # many per J
                $J = s&J;
                if (J) {
                    $z = Js&top || Js&z || [];
                    me&ioty,z .map(&n{
                        nc&W == k and ah(Y,['swims',k,C.sc[k],n])
                    })
                }
            }
        },'ift,D'],
        
        ['i swims',0.62,&acgtRYs,SC{
            !Ys&swims and return
            
            # < making swum (via J) not travel for enlightenment
            each ktN Ys&swims {
                t == 1 and t = 'i'
                # Y%of=Y:voy, whole bunch of elvising
                $E = Y.sc[k] ||= me&Yingvoy,R,s,'swim',k
                me&Yong,R,E,'swim',{t,N},1;
                # to each thing
            }}
            
            # < tug
            each in Ys&swim {
                me&Yong,R,n,{},7;
                each iz ns&swum {
                    me&OsC,s,z
                }
            }
        },'ift,D,self'],
        
      // 7 out
        # osc/* -> top/*
        ['selfs',0.7,&acgtRYs,SC{
            # < the main thing, osc may other
            $t = Ys&top;
            me&ioty,s .map(n => me&OsC,t,n )
        },'ift,D,self'],
        ['selfs',0.77,&acgtRYs,SC{
            $t = Ys&top;
            $d = {};
            d.compLines = &D{
                delete Dc&J
            }
            # W.1
            $one = me&Lineso,t,d;
            # whole bunches of Lines.join("\n")+"\n"
            !one.endsWith("\n") and throw "&Lineso!\n$"
            ah(s,'store','W',one);
            d.dige = dig(one);
            
            # < W.5, dep for a single W:of inc. w:JaBabz.
            #  < backporting JaBabz,Wud for StyleAgent?
            
            # W.js
            me&ioty,t .filter(n => nc&W == 'of') .length
                && ah(s,'store','js',me&jsso,t,d )
            
        },'ift,D,self'],
        ['selfs',0.9,&acgtRYs,SC{
            # where s is this view of it and more (rolling domes)
            ss&top = Ys&top
        },'ift,D,self'],
        
    ]};
   
 // &Yingvoy - osc elvis leaving
    # < make a variant of Yingdome, for loading eg swim
    me.Yingvoy = &acgtRstk{
        $s = me&Yong,R,s,'voy',{k},1;
        me&Yingbal,'Y:voy:'+t+':'+k,s
        return s
    }
    # < vague sharable slep, Copy Lines, lv
    # < C.t == null should throw
    me.Yingmind.voy = &acgt{ return [
        # elvis stilling out
        ['elvoy',0.01,&acgtRYs,SC{
            !Ys&k and throw "nok"
            $U = sy&Y;
            !U and throw "nestY"
            $z = Cye([Ys&k,3]);
            ac(U,'swim',z)
            return z
        },'ift,D'],
        ['elvoy',0.13,&acgtRYs,SC{
            # picture each t:Wof
            Yc&M = ss&z;
        },'ift,D'],
        ['elvoy',0.2,&acgtRYs,SC{
            sc&W = Ys&k;
            sy&cv = 0.001;
        },'ift,D'],
        ['elvoy',0.21,&acgtRYs,SC{
            me&Yong,R,s,{},7;
            # < Y.1 already, enclosing J namespace
            me.cby(s,&s{
                sy&Y && sy&Y.1 and return Y.1 = sy&Y.1
            })
            sc&J = me&fiu,Y.1,s.t;
        },'ift,D'],
        ['elvoy',0.23,&acgtRYs,SC{
            # they all %%string
            #sy&toLines and throw "hadLines"
            sy&toLines = me&indo,s (&s,d{ return sy&toLines });
            # this now a c&W to elvis, slept by %string
            
            $n = me&Zeve,R,s
            !n and T.hwack = "Y:voy:"+s.t; return
            $e = ns&e;
            !isC(e) and throw "reb"
            ss&e = e;
            # incorporate that
            !es&z and throw "Weird"
            # e:of is about several n:W:ofs
            $N = ss&swum = [];
            # < should use OsC that spots c&J?
            #   want to log J use
            each in es&z {
                # elvoys:n still origin, top made clean
                $J = nc&J;
                $top = Js&top;
                topy&cv != ny&cv and throw "*moted by peer"
                N.push(top)
            }
        },'ift,D,self'],
    ] };
    me.Yingmind.swim = &acgt{ return [
        ['elvoys',0.01,&acgtRYs,SC{
            # < exp lang
            $t = Ys&t;
            !t and throw "!t"
            $z = me&fiu,s,t
            $N = Ys&N;
            !N and throw "!N"
            Yc&M = N;
            return z
        },'ift,D'],
        ['elvoys',0.2,&acgtRYs,SC{
            $p = Ys&returns;
            !pc&W and throw "What"
            # may have Lines already, see 'variant of Yingdome'
            (sc&W ? ss&z : [s]).map(&n{
                $dup = me&fiu,s,n.t,8
                #dup and ac(s,'dups',dup)
                dup && dupy&cv != ny&cv and throw "cv"
                
                # < clone deeply
                $K = Cye(n);
                Ky&O = n;
                Ky&Y = Y;
                # may mix from $W/*
                s != n and Ky&W = s
                
                me&fiu,p,K
            })
        },'ift,D'],
        ['elvoys',0.21,&acgtRYs,SC{
            tvsortz(ss&z);
            Yc&M = [s,...ss&z];
        },'ift,D,self'],
        ['K',0.22,&acgtRYs,SC{
            # encoding advice
            $d = {jsony:1}
            me&Lineso,s,d;
        },'ift,D,self'],
    ] };
   
 // Storable
    # make W.js usable for:
    #  boot: w:Twoism loadI, page includes Hunt.js (moved out of W/)
    #  u: @Search Talks.js
    #   < without the lookup step (you know %dige)
    me.jsso = &acgttd{
        # have just been Lineso'd
        $W = me&ioty,t .filter(n => nc&W == 'of');
        !d.dige and throw "W.1 !dige"
        $clone = &s{
            $D = Cye(s);
            # < do anything now?
            G&Compress,D;
            d.compLines and d.compLines(D,d)
            return D
        }
        $shush = &s{
            return s.replace(/\W+/g,'_')
        }
        
        # first function, on the first line, should be a toc
        # one item per line of it, including line number ranges
        # flat list, to include toc
        $N = [];
        each iI W {
            $z = me&ioty,I;
            I = W[i] = clone(I)
            Iy&cv ||= 0.1;
            $Icv = cvf(Iy&cv)
            z.map(&n{
                n = clone(n);
                ny&cv ||= 0.1;
                ns&name = shush([t.t,d.dige,I.t,Icv,
                    n.t,cvf(ny&cv)].join('_'));
                !nc&s.match(/^function/) and throw "doesnt ^function", n
                nc&s = nc&s.replace(/^function/,'function '+ns&name)
                ac(I,'z',n);
                N.push(n)
            })
        }
        each in N {
            !nc&s.match(/\n$/) and throw "No trailing \\n", n
            ns&lines = nc&s.split("\n").length
        }
        
        # [ind t y c sc]+
        $toc = [];
        each iI W {
            toc.push(['',I.t,cvf(Iy&cv),I.c,I.sc]);
            me&ioty,I .map(&n{
                toc.push(['  ',I.t,cvf(Iy&cv),n.c,n.sc]);
            })
            delete Is&z;
        }
        # also ^function...{\n and \n}\n$
        $toc_lines = toc.length + 3; 
        $code_lines = 0;
        each in N {
            ns&line = toc_lines + code_lines;
            code_lines += ns&lines;
        }
        $codes = [];
        each in N {
            codes.push(nc&s);
            delete nc&s;
        }
        $name = shush([t.t,d.dige].join("_"))
        $cur = shush([t.t,'current'].join("_"))
        return [
            "function "+cur+" () { return "+name+"() }\n",
            "function "+name+" () { return [\n",
            # data and code has indent
            ... toc.map(l => l[0]+enj(l)+",\n"),
            "]}\n",
            ... codes
        ].join('')
    }
    me.Lineso = &acgtsd{
        return me&indo,s,ex({},d) (&s,d{
            $Y = sy&Y;
            d.where && !d.where(s,d) and d.not = 1; return
            $part;
            try {
                part = 'scan';
                !isC(s) and throw "Not C"
                sc&N and throw "mightbe R"
                part = 'clone';
                $D = Cye(s);
                part = 'Compress';
                G&Compress,D;
                Y && Ys&compLines and Ys&compLines(D,d)
                d.compLines and d.compLines(D,d)
                part = 'toLines';
                d.toLines = d.jsony ? enj(D) : G&toLines,D;
                Ds&H && !d.toLines.match(/(H):(\w+)\b/) and throw "%H not so gc will see it"
            }
            catch (er) {
                ~enLinesR: ki(d.path,2)+"   !"+part+"! "+er
                #me&Rec,R,'err';
                d.toLines = "[error} "+ki(s);
                #Rs&err = "enLinesR: "+part+": "+er;
                #n err  $s:Rs&err
                d.nofurther = 1
                throw er, 'further'
            }
            sy&toLines = d.toLines;
            return d.toLines
        })
        + "\n"
    }
    # &ballLines climbing s, knowing R
    #  replaces: Describing via awaking everything with %Lines
    # < wants errors, compression pointers:
    # < n Leaps -code ballLines:Yingr # doing:
    #   .c resolving &ballLines, figuring R+Rc&s
    #$Yingr = me.cbu(R,'Ying');
    #hs&string = me&ballLines,Yingr,Yingrc&s;
    #me&tsc,"Leaps",s,'y' .sc.dis = 1;
    me.ballLines = &acgtRs{
        $d = {};
        d.R = R;
        d.where = &sd{
            $r = d.R;
            !r and return 1
            rc&s == s and return 1
            # RbitX follow it down, using last time
            #  which should have all the nodes
            # < resyncing by sy&R? wants visual clue, ioland
            # 
            $found = [];
            $x = rc&V && rc&V.x || {};
            each tX x {
                each ir X.z {
                    rs&ball && rc&s == s and d.R = r; return 1
                }
            }
            delete d.R
            return 1
        }
        d.compLines = &Dd{
            $r = d.R;
            !r and return
            rs&eph and debugger;
            rs&compLines and rs&compLines(D,d)
        }
        return me&Lineso,s,d
    }
   
 // &Zeve - Y e
    # supposing e=s and sc&W
    me.Zeve = &acgtRsaq{
        $p = me&Rsc,R,'^^Proto';
        # < o $s^^y&Ys&plan
        # be from Jrunto's plan to n, reoccurs after async
        $sup = me.cby(s,&s{
            $Y = sy&Y;
            return Y && Ys&plan
        });
        $Cn = sup[0];
        $Yn = Cn && Cny&Y;
        $plan = Yn && Yns&plan;
        !plan and throw "n!plan", sup
        
        # the question (gets .e=s in &nodee)
        q ||= {};
        q.dome ||= plan
        # recycles e
        sy&toLines and q.dige = dig(sy&toLines)
        
        sy&timese ||= 0;
        sy&timese++;
        
        return me&nodee,R,p,s,{},q
    }
    