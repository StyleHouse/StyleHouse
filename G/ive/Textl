# lines of characters, etc
 // chunkology
    # follows the universal plant-in-the-lobby pattern:
    #   headings followed by empty lines do not a chunk make
    # < all known limitations involve io-happy regroup:
    # < joining b in ((...,0),(1,2,2,1,2,2,1):b):a
    #    esp if a > 80, we could look harder
    #    b is otherwise 3 chunks, none big enough, also:
    # < pre|post-amble, braces or comments, if gap beyond
    #   (1,2,2,1),0,(1,2,2,1)
    # see &chunksoflines various < 20 for some stumbling into:
    # < play with which being open gives near 100 lines
    #   or 100 lines per 1000 lines, or so
    # < when aging/inserting folds,
    #     open those the cursor/diff is mostly in
   // cm side
    # all at once
    #   no memo, usu rarely happens via s&valuecha()
    me.cm_chunksfold = &acgt,cm,z,ch{
        z ||= Cye([C.t,1,{s:cm.getValue()}]);
        $lines = zc&s.split("\n");
        # not the osc C?
        z == C and z = Cye(['lod',1]);
        # split that up
        !zs&chunks and me&chunksoflines,z,lines;
        # the existing marks
        $ope = me&cm_foldmap,cm
        # adjust to C
        me&cm_foldCode,z,ope,cm,ch;
        return z
    }
    # our chunks match|make a fold
    # < z**%ope=1/0, changing what is
    # < top-down lazily, %open/%closed/* to instantly:
    #   pop open, yet close more chunks within that
    #    (closing a then a/b opens a)
    me.cm_foldCode = &acgtz,ope,cm,ch{
        $found = [];
        if (zs&commentsey) {
            cm.options.foldOptions ||= {};
            cm.options.foldOptions.rangeFinder = &cm,pos{
                $from = pos.line;
                if (from > 0 && !cm.getLine(from).includes('#c ')) {
                    # not on a #c, use indent
                    $f = cm.getHelpers(pos,'fold')[0];
                    $range = f(cm,pos);
                    !range and ~>5 seekup til #c?:
                    return range
                }
                $end = cm.lastLine();
                $to = from;
                while (to < end) {
                    $text = cm.getLine(to+1);
                    text && text.includes('#c ') and break
                    to++
                }
                if (to > from) { return {
                    from: CodeMirror.Pos(from, cm.getLine(from).length),
                    to: CodeMirror.Pos(to, cm.getLine(to).length)
                }}
            }
        }
        #$topdown = zs&chunks.slice().reverse();
        each is zs&chunks {
            $f = ope[ss&line];
            ss&line *= 1
            if (ch) {
                debugger
                ch.from && ss&line+2 < ch.from.line and continue
                ch.to && ss&line-2 > ch.to.line and continue
            }
            # for Glimpes
            f and fy&chunk = s
            elsif (ss&proper) {
                # this checks again that fold makes sense
                $fo = cm.foldCode(CodeMirror.Pos(ss&line,0));
                found.push(fo)
                !fo and continue
                nofo = 0
                # doesn't make an $f
                # open widgets
                me&cm_mark_refoldable,fo,cm;
            }
        }
        # see stylehouse/CodeMirror.git 0a8f8455f2d48
        #  you might also findMarksAt after !cm.foldCode
        found.length && !found.filter(n => n).length and ~>5 cm_foldCode none found:
    }
    # current folds by line, inc open if refold marked
    me.cm_foldmap = &acgt,cm{
        $M = cm.getAllMarks()
        .filter(n => n.__isreFold && n.otherend || n.__isFold)
        .map(&n{
            $pos = n.find();
            # they get lost on big copy+paste
            !(pos.to && pos.from) and return 
            n.otherend and pos = {from:pos,to:n.otherend.find()}
            return Cye(['fold',1,{},{mark:n,
                line: pos.from.line,
                toline: pos.to.line
            }])
        }).filter(f=>f);
        $ope = {};
        each if M {
            ope[fs&line] = f
        }
        return ope
    }
    # an open fold having close buttons at each end
    me.cm_mark_refoldable = &acgtm,cm{
        $refoldable;
        refoldable = &m{
            m._handlers and delete m._handlers.clear;
            m.on('clear',&from,to{
                !(from && to) and return ~>5 lost fold:
                $N;
                $foldagain = &{
                    $pos = N[0].find();
                    N.map(n => n.clear())
                    !pos and return
                    #~>3 foldat: pos.line
                    $fo = cm.foldCode(pos);
                    !fo and return ~>5 lost refold:
                    refoldable(fo);
                };
                N = [from,to].map(&l{
                    $sym = l == from ? "\u21A6" : "\u21A4";
                    $widget = $('<n>'+sym+'</n>')
                        .on('click',foldagain)
                        # < clickable large floaty things...
                        #.css('font-size','280%')
                        .css('color','#7c9')[0];
                    $lop = cm.setBookmark(l,{widget});
                    lop.__isreFold = 1;
                    return lop;
                });
                N[0].otherend = N[1]
            })
        };
        refoldable(m);
    }
   // lines side
    # s/$c**, also s%chunks = [c in reverse (depth first)]
    me.chunksoflines = &acgts,lines{
        # starting from s = the whole document!
        ss&line = 0;
        ss&toline = lines.length-1;
        # i $s/$c each divisible chunk
        $N = me&indo,s,{dl:15} (&sd{
            # keep small chunks, no further
            #ss&toline-ss&line < 20 and return s

            me&chunkchunksoflines,s,lines;
            !ss&z and throw "nochunks"
            
            # drop small chunks
            ss&z.filter(c => 1+cs&toline-cs&line < 20)
                .map(c => me&fiu,s,c,9 );
            
            # and any one chunk same as the parent chunk
            ss&z.length == 1 && ss&z
            .filter(c => cs&line == ss&line).map(&c{
                cs&toline != ss&toline and throw "was shorter!!"
                me&fiu,s,c,9
            });
            return s
        });
       // etc
        $z = s;
        $resetN = &{
            N = [s];
            sy&tw = {};
            ss&z = [];
        }
        $assign = &N,lines{
            # assign their substrings 
            N.map(&s{
                #ss&string = lines.slice(ss&line,ss&toline+1).join("\n");
                ss&lines = 1+(ss&toline-ss&line);
                ss&lines < 20 and delete ss&proper
            });
            $rev = N.slice().reverse();

            # size supposing s/*%folded are each 1 line
            rev.filter(s => s == z || ss&proper).map(&s{
                ss&size = ss&lines;
                ss&z .filter(c => cs&proper).map(&c{
                    ss&size -= cs&lines-1;
                });
                if (ss&size < 20 && 
                    !(ss&size > 5 && ss&heading))
                    delete ss&proper
            })
            
            return rev
        };
        $rev = assign(N,lines);
       // or #c
        if (ss&lines > 100 && ss&size > ss&lines*0.1) {
            # didnt fold much, fallback to #c markers
            $wasN = N;
            resetN();
            # < why does this leave a few?
            #ss&z.map(c => me&fiu,s,c,9);
            #ss&z.map(c => me&fiu,s,c,9);
            #ss&z.map(c => me&fiu,s,c,9);
            $la;
            each il lines {
                la && !l.includes('#c ') and continue
                i *= 1;
                $c = Cye(['chunk@'+i,1]);
                la and las&toline = i-1
                cs&line = i;
                cs&proper = 1;
                me&fiu,s,c;
                la = c;
                N.push(c);
            }
            las&toline = i;
            rev = assign(N,lines);
            
            if (ss&size > ss&lines*0.1) {
                ~>7 chunksoflines confused by: s.t
            }
            elsif (ss&lines / ss&z.length > ss&lines / 2) {
                #~>7 chunksoflines uncommentsey: s.t
            }
            else {
                ss&commentsey = 1;
            }
            if (!ss&commentsey) {
                resetN();
                wasN.filter(c => c != s)
                    .map(c => me&fiu,s,c && N.push(c) );
                rev = assign(N,lines);
            }
        }
        ss&chunks = rev;
    }
    # i $s/$chunk+
    #  relating s%(to)lines -> lines
    me.chunkchunksoflines = &acgts,lines{
        $chunk = &sil{
            $c = Cye(['chunk@'+i,1]);
            cs&line = l;
            me&fiu,s,c;
            return c
        }
        $c = null;
        $i = 0;
        $li = ss&line || 0;
        $laindent = ss&indent || 0;
        $ltoindent = {};
        while (lines[li+i] != null) {
            $l = lines[li+i];
            $indent = ltoindent[li+i] ||= l.match(/^(\s*)(.*)$/);
            $stuff = indent[2];
            indent = indent[1].length;
            $p = c;

            # level this chunk is based at
            $cind = c && cs&indent || 0;
            
            # remaining at s's indent is not c-worthy
            !c && ss&line && indent == ss&indent and i++; continue
            else
            !c and c = chunk(s,i,li+i)
            else
            !i and throw "i=0"
            else
            # not minding empty lines
            !stuff and indent = laindent; 'grow'
            else
            # < python-ish indent-implied blocks. would ignore:
            stuff[0] == '#' && indent == cind and 'grow'
            else
            # (1,2),(1) or (2,3),(1)
            if (cind == indent && indent < laindent
                || cind > indent) {
                c = chunk(s,i,li+i)
            }
            else
            # (1,1),(2) -> (1),(1,2)
            if (cind < indent && laindent <= cind
                && (ps&toline - ps&line > 0
                    || ps&line == ss&line)) {
                c = chunk(s,i,li+i);
                cs&laindent = laindent;
                if (ps&line != ss&line && laindent != ss&indent) {
                    # borrow the 1, or start indent from here
                    cs&indent = laindent;
                    ps&toline--;
                    cs&line--;
                    if (!/\S/.test(lines[cs&line])) {
                        # no plant-in-the-lobby trick, open
                        # consume the skipped over !stuff
                        cs&spacedopen = 1;
                        while (1) {
                            cs&spacedopen++ >4 and throw "big cs&spacedopen"
                            /\S/.test(lines[cs&line]) and break
                            cs&line--;
                        }
                    }
                    
                }
            }
            else
            # chunks with something further inside will cm.doFold
            #  unless they're /^#/, no prob
            # ie only the (1,2) of (1,1,1),(1,2)
            indent > cind and cs&proper = 1
            # various reasons un-proper, eg (2, ,3)
            cs&spacedopen and delete cs&proper
            
            if (p != c) {
                $lindo = ltoindent[cs&line];
                lindo[2][0] == '/' and cs&heading = 1
            }

            if (cs&indent == null) {
                cs&indent = indent
            }
            cs&toline = li+i;
            cs&toline >= ss&toline and break
            laindent = indent;
            i++;
        }
    }

  
 // Storables
    # see Jay Y:osc 7
    # make W.js usable for:
    #  boot: w:Twoism loadI, page includes Hunt.js (moved out of W/)
    #  u: @Search Talks.js
    #   < without the lookup step (you know %dige)
    me.jsso = &acgttd{
        # have just been Lineso'd
        $W = me&ioty,t .filter(n => nc&W == 'of');
        !d.dige and throw "W.1 !dige"
        $clone = &s{
            $D = Cye(s);
            # < do anything now?
            G&Compress,D;
            d.compLines and d.compLines(D,d)
            return D
        }
        $shush = &s{
            return s.replace(/\W+/g,'_')
        }
        
        # first function, on the first line, should be a toc
        # one item per line of it, including line number ranges
        # flat list, to include toc
        $N = [];
        each iI W {
            $z = me&ioty,I;
            I = W[i] = clone(I)
            Iy&cv ||= 0.1;
            $Icv = cvf(Iy&cv)
            z.map(&n{
                n = clone(n);
                ny&cv ||= 0.1;
                ns&name = shush([t.t,d.dige,I.t,Icv,
                    n.t,cvf(ny&cv)].join('_'));
                !nc&s.match(/^function/) and throw "doesnt ^function", n
                nc&s = nc&s.replace(/^function/,'function '+ns&name)
                ac(I,'z',n);
                N.push(n)
            })
        }
        each in N {
            !nc&s.match(/\n$/) and throw "No trailing \\n", n
            ns&lines = nc&s.split("\n").length
        }
        
        # [ind t y c sc]+
        $toc = [];
        each iI W {
            toc.push(['',I.t,cvf(Iy&cv),I.c,I.sc]);
            me&ioty,I .map(&n{
                toc.push(['  ',I.t,cvf(Iy&cv),n.c,n.sc]);
            })
            delete Is&z;
        }
        # also ^function...{\n and \n}\n$
        $toc_lines = toc.length + 3; 
        $code_lines = 0;
        each in N {
            ns&line = toc_lines + code_lines;
            code_lines += ns&lines;
        }
        $codes = [];
        each in N {
            codes.push(nc&s);
            delete nc&s;
        }
        $name = shush([t.t,d.dige].join("_"))
        $cur = shush([t.t,'current'].join("_"))
        return [
            "function "+cur+" () { return "+name+"() }\n",
            "function "+name+" () { return [\n",
            # data and code has indent
            ... toc.map(l => l[0]+enj(l)+",\n"),
            "]}\n",
            ... codes
        ].join('')
    }
    # returns %string, &toLines,s**
    #  was &Serialise
    me.Lineso = &acgtsd{
        return me&indo,s,ex({},d) (&s,d{
            $Y = sy&Y;
            d.where && !d.where(s,d) and d.not = 1; return
            $part;
            try {
                part = 'scan';
                !isC(s) and throw "Not C"
                sc&N and throw "mightbe R"
                part = 'clone';
                $D = Cye(s);
                part = 'Compress';
                G&Compress,D;
                Y && Ys&compLines and Ys&compLines(D,d,s)
                d.compLines and d.compLines(D,d,s)
                part = 'toLines';
                d.toLines = d.jsony ? enj(D) : G&toLines,D;
                Ds&H && !d.toLines.match(/(H):(\w+)\b/) and throw "%H not so gc will see it"
            }
            catch (er) {
                ~enLinesR: ki(d.path,2)+"   !"+part+"! "+er
                #me&Rec,R,'err';
                d.toLines = "[error} "+ki(s);
                #Rs&err = "enLinesR: "+part+": "+er;
                #n err  $s:Rs&err
                d.nofurther = 1
                # in case we dont throw new Error(...)
                # < generalise handling, fix up toLines: throw "Leaky...
                isst(er) and throw "Lineso: "+er, d.path
                # this Babz into er.catches+={stack,tc=[further]}; throw er
                throw er, 'further', d.path
            }
            sy&toLines = d.toLines;
            return d.toLines
        })
        + "\n"
    }
    # o y $s**
    #  was &Copy (made R:Copy)
    # < more like &acceptables_reself, %string -> lv sense etc
    me.Clone = &acgtsd{
        return me&indo,s,d (&sd{
            $z = d.O = Cye(s)
            z.y [d.ytag||'Clone'] = s
            $du = d.up
            $pz = du && du.O
            # rebuilding y&tw and s&z, dup fatal
            pz and me&fiu,pz,z,2
            return z
        }) [0]
    }
    # &ballLines climbing s, knowing R
    #  replaces: Describing via awaking everything with %Lines
    # < wants errors, compression pointers:
    # < n Leaps -code ballLines:Yingr # doing:
    #   .c resolving &ballLines, figuring R+Rc&s
    me.ballLines = &acgtRs{
        $d = {};
        d.R = R;
        d.where = &sd{
            $r = d.R;
            !r and return 1
            rc&s == s and return 1
            # RbitX follow it down, using last time
            #  which should have all the nodes
            # < resyncing by sy&R? wants visual clue, ioland
            # 
            $found = [];
            $x = rc&V && rc&V.x || {};
            each tX x {
                each ir X.z {
                    rs&ball && rc&s == s and d.R = r; return 1
                }
            }
            delete d.R
            return 1
        }
        d.compLines = &Dd{
            $r = d.R;
            !r and return
            rs&eph and debugger;
            rs&compLines and rs&compLines(D,d)
        }
        return me&Lineso,s,d
    }
 
 // *Lines (from j/27)
  // compress
    # various things shouldn't be let out
    # something else (G&toLines) makes y.* disappears, wormholing only cv
    # < an embryonic composited sub, like thro, 
    # < the opposite, collected from n and something else...
    # < use the d (state from G&ind) to make links for duplicated objects
    # see j/7 K: used to mute any ref not gk =~ /x$/
    me.Compress = &acgtsd{
        # the other things are around, also via y.{tw,tv,in} etc
        delete ss&z;
        
        # especially if pi
        ss&J and delete sc&s;
        typeof sc&s == 'object' and delete sc&s
        typeof ss&J == 'object' and delete ss&J
        
        $mute = {c:['code'],sc:[]};
        $unmuted_objects = [Object,Array];
        # this just does:
        #   sc&code and delete sc&code; sc&mc = 'code';
        # < Be properties
        each nk,gks mute {
            $he = s[nk];
            $muted = {};
            each gk,v he {
                gks[gk] and muted[gk] = 1; continue
                # data should be limited somehow...
                typeof v != 'object' and continue
                unmuted_objects.indexOf(v.constructor) >= 0 and continue
                # name of v.constructor
                muted[gk] = G&arfgunc,v || 1;
                
            }
            each gk,reason muted {
                delete he[gk]
            }
            # say that it is muted, eg c&mc = 'muted Cc keys'
            #  in a thing that could pretend to be a hash for simplicity...
            if (Object.keys(muted).length) {
                $ou = 'm' + nk.slice(0,1);
                $was = s.c[ou];
                if (was) {
                    was = G&peel:was,{sep:' '};
                    $.extend(muted, was);
                }
                s.c[ou] = G&depeel:muted,{sep:' '};
            }
        }
    }
  // enL
   
  // deL
   