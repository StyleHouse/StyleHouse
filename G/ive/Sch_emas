# Picturity
    me.scroll = &acgts{
        s&mh = s;
        s&over = 1
    }
   // pi
    # selective ex, removing
    #  as in consuming arguments from a c
    window.tax = &s,take,c{
        !c and return s
        !isha(s) || isC(s) || !isha(c) || isC(c) and throw "tax"
        isst(take) and take = G&peel,take
        else
        isar(take) and throw "{map{k:1}take}"
        each k,remove take {
            !hak(c,k) and continue
            remove and s[k] = delete c[k]
            else { s[k] = c[k] }
        }
        return s
    }
    
    window.defor = &sc{
        return s != null ? s : c
    }
    # create a -pi on a node
    me.Api = &acgtstc{
        !isst(t) and throw "which -pi"
        # takes c.t (< etc) into a new c
        c = tax({},'t',c)
        c.el = 2
        $b = s.y [t]
        $E = s.y [t] = Cye([defor(c.t,s.t),1,{pi:t}])
        Ey&up = s
        return E
    }
    
   // -eight**
    me.pieight = &acgtRsc{
        $E = me&Api,s,'eight',c
        
        $fo = me&pifour,R,s
        me&fiu,E,fo
        # only -four yet, to help -eight sublate
        c.ov < 0.6 and return
        
        each ie ss&z {
            # paragraph of story: -seven a %Yingate
            $se = me&piseven,R,e,{t:i}
            # < could almost rename that after returning it
            #   would require A:n@1 until the S domed
            me&fiu,E,se
            
        }
        # through -tll (thing looks like) to -act
        
        #ss&z.length > 5 and me&scroll,27
        
        # 6
        $d = {
            compLines:&DdC{
                me&dopi,D,d,C,c
            },
        }
        # < the Lineso top D on ss&string.D
        #   showing the string with chunks inteligised
        me&Linets,s,E,d
        
        # &acceptables_reself
        c.Finto &&
            me&nodei,R,c.Finto,{Fin:s,dige:ss&dige}
    }
    me.pifour = &acgtRsc{
        $fo = me&Api,s,'four',c
        $gof = me&acting,R,'-four',0
       // make overall quantology from the many -gate
        # < may merge with z/-3 if similar,
        #   eg a sequence of e:clicks each return to Story
        #    whereas a bunch all happen, then return to Story
        # and oking, via:
        $D = Cye([s.t+'-four',1,{pi:'gate'}])
        Ds&z = []
        each iz ss&z {
            each it zs&z {
                t = Cye(t)
                ts&gate = z
                Ds&z.push(t)
            }
        }
        # < interactive
        $g = me&brackology,R,D,{t:'four'}
        me&walls,g,'b:2.2';
        gs&hue = 200
        ac(R,'M',g);
       // into el:2-four..-vat
        me&ioty,g .map(&Km,{
            !Kms&groupthing and return
            
            $tee = me&ioty,Km .map(Kn => Kn.t)
                .filter(t => t != 'gate').join('-')
            # < &fiu,s,z,2 - fatal create?
            me&fiu,fo,tee,8 and throw "already a "+tee
            $mg = Kmy&gate = me&fiu,fo,tee
            mgc&pi = 'legs'
            
            me&ioty,Km .map(&Kn,{
                $N = me&ioty,Kn
                #me&nu,"Kn:"+Kn.t,N
                $gr = me&fiu,mg,Kn.t
                grc&pi = 'leg'
                Knc&size and grs&size = Knc&size
                gry&leg = Kn
                if (Kn.t != 'gate') {
                    $x = Knc&x
                    $ii = 0
                    # ology modulat compresses same v.t along N
                    #  to simplify order of every ref
                    each in N {
                        !ns&vis and continue
                    each i,vi ns&vis {
                        $fx = x.ref[vi]
                        $v = x.refs[vi];
                        # how many times it was used
                        $gv = me&fiu,gr,''+(ii++)
                        gvc&pi = 'vat'
                        gvc&s = v
                        gvs&size = fx.z.length
                        gvs&size == 1 and delete gvs&size

                        $nN = me&ioty,n
                        each iz nN {
                            zs&groupthing and debugger
                            # size,sym,label
                        }
                    }
                    }
                }
                else {
                    # mute %%gate after size
                    # < in such a way that Te|diff can inflate it
                    $aft_size = 0
                    each in N {
                        aft_size and ns&dis = 0
                        n.t == 'size' and aft_size = 1
                    }
                }
            })
        })
       // etc 
        return fo
    }
    me.piseven = &acgtRsc{
        $se = me&Api,s,'seven',c
        
        $g = sy&brackology
        
        gs&z.map(&Km,{
            !Kms&groupthing and return
            # -gate: bunch of rows
            #  each row allowed one oddness, see &brackgroupX
            $tee = me&ioty,Km .map(Kn => Kn.t).join('-')
            # < &fiu,s,z,2 - fatal create?
            me&fiu,se,tee,8 and throw "already a "+tee
            $mg = Kmy&gate = me&fiu,se,tee

            # < hardwired or $Storie-got configuring
            # < track approx time of each -seven
            #   species a trail of samples
            tee == 'time' and mgc&ms = 'z'; return

            !Kmc&rows and throw "norows"
            each in Kmc&rows {
                $gr = me&fiu,mg,i
                gry&row = n
                each kv n.sc {
                    $gv = me&fiu,gr,k
                    gvc&s = v
                    gvc&pi = 'vat'
                }
            }
        })
        return se
    }
    me.dopi = &acgtDdCc{
        $s = c&s
        if (c&pi == 'vat') {

            # starts s=object|data|value, becomes stringified
            !isC(s) and Dc&s = ki(s); return
            Dc&s = s.t
            # avoid talking of R
            isR(s) and return Ds&R = 1
            Dc&pi = 'n'
            # usually -n: a C we can find
            # as a flower amongst|beyond the body of nodes
            $stem = []
            $beyond
            $Xss = c.nlist || []
            $la
            $foundnode = me.cby(s,&zd{
                $t = z.t
                # tell if la^z != z/la
                if (la && !(zs&z && zs&z.includes(la))) {
                    $r = zy&R
                    $rem = ''
                    # < see vv/beginning/3 "Story/Story!%eph/beginning"
                    #   s^^ different to sy&R^^
                    r && !(rs&eph || me&ollbs,r,'eph' ) and rem = '!'
                    !r and rem = '?'
                    stem[0].push(rem+'%eph')
                }
                la = z
                stem.unshift([t])
                if (Xss.includes(z)) {
                    !zy&path and throw "node!zy&path"
                    # finish?!
                    return 1
                }
                beyond = 1
                return 0
            })
            !stem.length and throw "nostem C"
            Dc&s = stem.map(l => l.join('')).join('/')
            !foundnode and Dc&pi = 'C'
            else
            beyond and Ds&beyond = 1
        }
        # normal -vat -> -n, talk of ground things
        Dc&pi == 'n' and delete Dc&pi
    }
    