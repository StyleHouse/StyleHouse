# get from R to SCA
#  SCA needs to be above what's awaking,
#   but then can do many reactions in a single self
=pod
 for groups of language to find their completion
 Know->That was an I mixer,
  becomes one of many things we could do with W
  Place for generating to e
  
  < turn into
 Know $W used, versions in here
 Travel $W using: $W used, why/how
 That $W using
  # want to hotwire w/I it uses
  #  to implant me&T hooks etc

Yingwhen
 what sense we arrive to this R%Ying
 usu tunneling there
 < relate to e%term, 

=cut
me.Sch_ema = &acgt{ return [
  
  // %SCinto # schemas employable from s/s%SC
    ['SCinto','292',&acgtRs{
        
        Rs&mindused = 'SCones';
        me&reaw,R,'mindused';
        4s&mainthing = R;
        # look for R/r(%SC=ForThee
        #  becomes R%ForThee%SupplyChai
        $g = me&opeolo,'SCinto';
        $autoad = Rs&icount != 1
        me&ioty,s,'SC','' .map(&z{
            $t = zs&SC;
            # .1 starts it, can be switched off
            !autoad and autoad = R.sc['maydo_label_SCinto_SC-able_'+t] = 1
            $c = gy&can('m','SC-able');
            $n = cy&can('n',t,{label:1});
            # %Ying is persisted early by %nextlifesc
            !ns&ope and delete Rs&Ying
            else {
                # switch on the %$schema
                #  will create %Ying here
                R.sc[t] = 1;
                $ml = cy&label;
                mls&fs = 6;
                # switch on Search P -> J
                4s&Pringit = 1;
            }
        });
    },'ift,D'],
    
  // R%Ying  # joining Steps time
   # building on the e%tunnel function
   #  to wake+sleep togethers
   #  tunneling past R:Ying%sleeping most of the time
    # early, no schema, only steps that are tunneled
    ['sleeping+Ying','296',&acgtRs{
        $SC = me&rollbsc,R,'Ying';
        isR(SC) and throw "%Ying became R"
        me&Yingwhen,R,SC and return
        me&Yong,R,SC,{},9;
    },'ift,D'],
    
    # Ying normally after R%Peace and schemas load 
    ['Ying','296',&acgtRs{
        T.Mw = 'SC';
        me&reaw,R,'Ying,Outlog';
        $SC = me&rollbsc,R,'Ying';
        me&rollbs,R,'Outlog';
        me&Yingwhen,R,SC and return
        # < feedback, early intro tunneling
        ah(R,'nextlifesc','Ying',SC);
        # steps congealed
        $s = me&Yong,R,SC,{},9;

        s&boc = 588;
    },'ift,D'],
   
  // &Yingwhen - assign R/*%onlyish
    &{
    # see what's tunneled
    me.Yingwhen = &acgtRY{
        $N = me&ioty,R;
        if (!Rs&tunneling) {
            # nothing
            # < a loose wave of attention,
            #   do 100ms work, etc.
            #   casually refreshing around:
            #   $R/*/(*/*), $R/(*/*), ($R/*)
            # ($R/*)
        }
        $tunneling = N.filter(n => ns&tunneling && Rc&N.includes(n));
        if(0) {
            $blab = tunneling.map(&n{
                return n.t + (ns&sleeping ? "%sleeping" : "")
                    + (!ns&tunneling ? "!tun" : "")
                    + " P="+ns&Peace
            }).join(',');
            ~>3 tunneling: blab
        }
        $b = Rc&b;
        $est = b && bs&Ying;

        # the main things, $p%ball
        $two = tunneling.filter(n => ns&Peace == 2);
        # $p only, eg delivering %%eto:$p
        est && two.filter(n => !ns&sleeping).map(n => ns&onlyish = 1)
        # $R/$p only, all of them
        !tunneling.length and est && ah(R,'inheritscif','ball','onlyish',1)
        else
        # no &Ying for $R/$nonp (Yingu)
        !two.length and return 1
    };
    },
   
   // %onlyish
    # me&tunnel a cul de sac, to $p/*%sleeping
    ['Peace+onlyish','294',&acgtRs{
        $b = Rc&b;
        !b and throw "%onlyish !b"
        $N = bs&z;
        each ib N {
            !bs&Peace and continue
            bs&wakeful and continue
            $c = me&tunnel,R,{b};
            c.aleeping = 'aleep';
            c.JRom and throw "%onlyish/%JRom"
            me&tunnelin,R,c
        }
    },'ift,D'],
    # go %sleeping after arriveRbitX (@17), like tunneling @18
    ['aleeping','18',&acgtRs{
        me&recycleRbitXz,R;
        Rs&sleeping = Rs&aleeping
    },'ift,D'],
    # like tunneling @94, copy all other sc, eg %elvis
    ['sleeping+aleeping','94',&acgtRs{
        each kv Rc&b.sc {
            R.sc[k] ||= v;
        }
        delete Rs&aleeping
    },'ift,D'],
   
  // %supr
    #
    # the %eph and its /** become %supr
    #  and %$sy&supr - suprise puts that
    ['ball+supr','291',&acgtRs{
        sy&R = R;
        # children get %supr in time to get here
        ac(R,'inheritsc','supr');
        # our %ball/%fix appear after @4
        
        
        
        
        
        Rs&fixatfour = 1;
        # %supr only becomes %$supr if a node:
        #  me&suprise mostly just transfers it
        #   to sy&supr on entering a node
        sy&supr and R.sc[sy&supr] = 1
        # see Y:Steps about %nextlifesc %nottilund
    },'ift,D'],


  // schema %KnowThee
    # http://hereth.localhost:1812/?Wayout/Fingo
    ['KnowThee','294',&acgtRs{
        
        $h = me&Ying_Schema,R,'KnowThee',{};
        # G, storage type of step
        # bunch of G&t Q written down
        #  hierarchical looking, W/[W,W,W]
        #   able to conserve some hierarchy of W inclusion,
        #   and write down the essential Q of any ghost,
        #     may involve specificity, random folders
        #   in a pile easier to read than all the W.5s everywhere
        n Know 1  %bri:0.7,Pavings
        
        # Comal/Conal, Comste/Conste
        #n Compiling 3  %hue:70,supr:Conal
        #n Seq 5  %hue:110,supr:Conste,Omplateau
        
        # join
        # schema.c.twin puts %twin on the s.sc
        #  so does %Pavings, puts s%twmt
        n Ghost 2 twin:Travel|Know#of/t
        # awakening
        n Gump 3  %Gumptio
        n Travel 4  %Travels
        n Duolish 5  %Duolish
        # in a puff of ghost
        n To 6 twin:Travel|That#of/t
        
        n That 7  %Pavings
        n Story 8  %Story

        hy&domed()
    },'ift,D'],

  // schema %TravelThee
    # http://hereth.localhost:1812/?Wayout/Lingo
    ['TravelThee','294',&acgtRs{
        
        $h = me&Ying_Schema,R,'TravelThee',{};
        
        n Gump 3  %Gumptio
        n Travel 4  %Travelty
        n Duolish 5  %Duolish
        n Story 8  %Story

        hy&domed()
    },'ift,D'],
    
]};



me.Yingmind ||= {};
me.Yingmind.Schema = &acgt{ return [
    # SC/Schema/Y:$src/$step+ posit SC/Steps/$step+
    #  every time R%Ying wakes
    # < slep @2
    # %*T pronounces how it will be, arranging for SCing:
    # A:SC@1 %SupplyChai=C macro laterer
    #  A:Schema@1 %SCh/$t=C micro schema
    #   ...gets finished:
    #  A:Schema@2 can slep & tell macro
    #   @3 with each other, notice late joiners
    #   @4 patterns emerge
    #   @5 decide how to change the game in progress
    #   @6 Ret (via bal) the step
    # SCing:
    # A:SC@2 inits
    #  A:Schema@6 may be moved in here,
    #   to avoid it Ringing outside the SCing

    # %KnowThat forks SC/Schema/t=KnowThat
    ['+Schema',0.01,&acgtRYs,SC{
        # organise SC's Ys as of/t:
        $Sch = me&fiu,SC,'Schema';
        $t = Ys&t;
        !t and throw "give t"
        # el:1 recreates, string t makes spacer
        #  and sets sy&Y = Y
        $s = me&fiu,Sch,t,{el:1,Y:Y};
        # drop cache # < wake Y:Schema if diff
        delete Schc&compiled;
        # makes the subject of iteration, sets sy&Y=Y
        return s
    },'ift,D'],
    # day, display zone
    ['on',0.02,&acgtRYs,SC{
        sy&R = R;
        # nowhere:
        $g = sy&g = me&opeolo,s.t,{walls:'b:2.2h6',label:{walls:'bg'}};
        Rc&brackuiet = 1;
        gy&can('ope',&{ Rc&brackuiet = 0 });
    },'ift,D'],
    # i $s:schema/$step o T.nN/*:step
    # steps adopted from recent: n ...
    ['steps adopted',0.11,&acgtRYs,SC{
        $N = Ys&N;
        !N and throw "nosteps"
        each in N {
            $p = fio(s,[n.t,n.y.cv||1]);
            py&Schema_step and throw "multi schema step", n
            py&Schema_step = n;
        }
    },'ift,D'],
]};
