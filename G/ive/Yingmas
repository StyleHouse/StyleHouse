# R -> Ying
# < -> A revival!
# R%Ying becomes - see %Ying in Sch_emas
# < make Yc&tug?
=pod
 Ying needs to be above whats awaking,
   but then can do many reactions in a single self
 for groups of language to find their completion
 Know->That was an I mixer,
  becomes one of many things we could do with W
  Place for generating to e

  < turn into
 Know $W used, versions in here
 Travel $W using: $W used, why/how
 That $W using
  # want to hotwire w/I it uses
  #  to implant me&T hooks etc

Yingwhen
 what sense we arrive to this R%Ying
 usu tunneling there
 < relate to e%term
=cut

// Yingwards
# mind
 // Yingf
    me.Yingmind ||= {};
    # get I = me.Yingminds.$t ||= me.Yingmind.$t
    me.Yingminds ||= {};
    me.Yingmindo = &acgtt{
        !t and throw "Yingminds!t"
        $N = me.Yingminds[t];
        N and return N
        !me.Yingmind[t] and throw "Yingmind!t:"+t
        $M = me.Yingmind[t](A,C,G,T);
        $N = [];
        each in M {
            # sack of me.functions
            isfu(n) and n(); continue
            N.push(Cye(n))
        }
        N.map(n => n.c = {s:n.c})
        me.Yingminds[t] = N;
        return N
    };
    # drink grounds into Ying/Schema
    me.Ying_Schema = &acgtRtc{
        $SC = me&rollbsc,R,'Ying';
        $s = me&Yong,R,SC,'Schema',{t:t},1;
        # steps adopted from recent: n ...
        sy&domed = &{
            $N = me&ydome;
            me&Yong,R,s,{N:N},2;
        };
        return s
    };
    # py&l|r - linked listness of a step
    me.neigh = &py{
        $Steps = py&up;
        $z = Stepss&z;
        $pi = z.indexOf(p);
        pi <0 and throw "!step"
        y(z[pi-1],z[pi+1])
    };
# appear
 // Yong - use sy&Y link to Ying $s**
    =pod conventionae Yongus

      Yong,$s:Steps,{sc},ov
        has Stepsy&Y to resume
      Yong,$s:SC,$t=Steps,{sc},ov
        is a difft, Ying Steps@o1 to create/find $s:Steps
         giving it this new Y
     either then:
      sy&R!future - Ying @o2, resyncing new R
        saving higher cv/ov until Steps does Yc&resumeov()
     and:
      Ying up to that ov

    =cut
    # me&Yong R $s(y&Y?) $mind? {Y.sc intro} $ov||=9 - 
    #  $mind on est. might return forked Y/Y:$mind
    me.Yong = &acgtRst,sc,ov{
        isob(t) and ov = sc; sc = t; t = null
        ov < 0 and $rewind = ov = ov *-1
        ov = scaf(ov) || 0.9;
        
        # s may be inside SC
        # < io: optimise SC**/$s knowing sy&up
        # < slope sy&up and know stuff, part of wider Aing
        $dive = me.cby(s);
        $SC = dive[0];
        $Y = sy&Y;
      
      // begin if c.t || !sy&R
        $began = Y && Yc&cv || 0;
        $rem = "";
        if (t) {
            rem += " +Y:"+t;
            # o1 with new Y:Yc&t, create/find s for itself
            #   starting from the s
            $Y = me&Ying,R,s,{t:t,ov:0.01},sc,SC;
            # intro Yong(...sc) once, any of these places
            sc = {};
            s = Ys&returns;
            !s and throw t+"@01 !returns"
        }
        if (sy&R && me&yfuture,sy&R != sy&R
                || Rs&sleeping && R != sy&R) {
            # o2 per sy&R checks Y into lowov
            #  join macro A (eg R)
            #   so it can give/take grounds there
            $c = {};
            c.cv = c.ov = 0.02;
            # saving higher cv/ov until Y is ready
            !Y and debugger;
            Yc&resumeov = extemp(Y.c,c);
            c.Y = Y;
            # doing o2 even if cv==o2
            # < rename incv=ov, for iterating same t
            c.incv = c.ov;
            $Y = me&Ying,R,s,c,sc,SC;
            sc = {};
            rem += " ~R"
        }
      // continue if ->?ov
        # what to do
        $c = {ov};
        if (!Y) {
            # begins itself, mind Yc&t = s.t
            c.t = s.t;
            rem += " s+Y:"+c.t;
        }
        else {
            c.Y = Y
        }
        if (rewind && Y && Yc&cv >= ov) {
            c.incv = c.cv = ov;
            Y = null
        }
        !Y || Yc&cv < ov and Y = me&Ying,R,s,c,sc,SC
        
        $ind = dive.map(s=>s.t).join('/');
        SCc&verbose and ~>6 Yingd: ind, began, Yc&cv, ov, rem, ki(c)
        
        $re = Ys&returns || (Yc&M||[])[0];
        rey&Y != Y and throw "returning !yY=Y"
        return re
    };
# act
 // Ying - mind (Yc&N) over matter (Yc&M)
    # as a way to find C about how to A
    # may c.t=newmind
    # may !c.Y, is created
    # sets sy&Y=Y for Yc&M/*
    #  and on itself if it returns so from 0.01
    me.Ying = &acgtRsc,sc,SC{
        # incv allows doing Ycv==tcv
        $incv = delete c.incv;
        # Y = c.Y explicitly, probably is sy&Y
        $Y = delete c.Y;
        if (!Y) {
            # init happens this way, from Yong $t
            # 
            # could Yy&up = sy&Y before it reinits?
            Y = Cye(['Y:'+c.t,'']);
        }
        # A:$t cv-ov are life + time to be
        # < see me&tempwind undoing some of this, 
        ex(Y.c,c);
        Yc&ov and Yc&ov = sca(Yc&ov)
        Yc&cv and Yc&cv = sca(Yc&cv)
        $wascv = Yc&cv;
        # its quest for a specific etc
        ex(Y.sc,sc);
        # of this linguistic actuation linearity
        Yc&N = me&Yingmindo,Yc&t;
        # and this exception actuator, and the one above
        $oT = T;
        $T = {};
        $returns = &{
            Yc&M and Yc&M.map(s => sy&Y ||= Y)
            return Y
        }
        $il = 30;
        while (1) {
            il-- < 0 and throw "ManyYing"
            # fracseek
            # < near Yc&N being changed while Yinging
            $ci = t ? Yc&N.indexOf(t) : -1;
            $t = Yc&N[ci+1];
            !t and break
            ty&cv > Yc&ov and break
            ty&cv <= Yc&cv && incv != ty&cv and continue
            
            # < thinkseek
            
            # < bitseek
            incv and wascv = incv
            # usu so many at == cv all happen
            incv = ty&cv;
            # <=@o2 iterate themselves
            $M = ty&cv > 0.02 && !ts&self && Yc&M || [s];
            each in M {
                delete T.not;
                # t act, n ground
                
                # deciding
                if (ns&sleeping) {
                    # misses everything but sleeping spells
                    !(ts&sleeping || t.t.substr(0,8) == 'sleeping') and T.not = 'sleeping'
                }
                T.not and continue
                
                # can't always trust whatever these might be:
                #$r = ny&R || sy&R || Cy&R;
                # R is from the Ying above (R%SC)
                # < elabourate argumentation
                sc&verbose and ~>4 Ying: s.t, t.t, t.y.cv, n.t, Yc&ov
                $re = tc&s(A,C,G,T,R,Y,n,SC);
                
                T.Z and me&T_Z,Y
                $nocvt = delete T.nocvt;
                !nocvt and Yc&cv = ty&cv;
                if (ty&cv == 0.01) {
                    # Y claims what o1 returns
                    #  or $s if non-forking o1
                    re ||= Ys&returns || s;
                    !isC(re) and throw "o1ret!C"
                    # 3 makes child
                    rey&cv == 0.3 and rey&up = s
                    # < may switch to it?
                    rey&Y and rey&oldY = rey&Y
                    rey&Y = Y;
                    Ys&returns ||= re;
                    s = re;
                }
            }
            delete T.not;
            T.hwack and Yc&cv = wascv; oT.hwack = T.hwack; return returns();
        }
        # so Y looks @2, if last ty&cv < 2
        Yc&cv = Yc&ov;
        return returns();
    };
    me.T_Z = &acgtY{
        $cv = delete T.Z;
        T.nocvt = 1;
        Yc&cv = scaf(cv);
    };

# get from R to Ying
me.Sch_ema = &acgt{ return [
 // R:Ying, how it /*
  
  // %SCinto # schemas employable from s/s%SC
    ['SCinto','2922',&acgtRs{
        
        Rs&mindused = 'SCones';
        me&reaw,R,'mindused';
        # look for R/r(%SC=ForThee
        #  becomes R%ForThee%SupplyChai
        $g = me&opeolo,'SCinto';
        $autoad = Rs&icount != 1
        me&ioty,s,'SC','' .map(&z{
            $t = zs&SC;
            # .1 starts it, can be switched off
            !autoad and autoad = R.sc['maydo_label_SCinto_SC-able_'+t] = 1
            $c = gy&can('m','SC-able');
            $n = cy&can('n',t,{label:1});
            # %Ying is persisted early by %nextlifesc
            !ns&ope and delete Rs&Ying
            else {
                # switch on the %$schema
                #  will create %Ying here
                R.sc[t] = 1;
                $ml = cy&label;
                mls&fs = 6;
                # switch on Search P -> J
                4s&Pringit = 1;
            }
        });
    },'ift,D'],
    
  // R%Ying  # joining Steps time
   # building on the e%tunnel function
   #  to wake+sleep togethers
   #  tunneling past R:Ying%sleeping most of the time
    # early, no schema, only steps that are tunneled
    ['sleeping+Ying','2926',&acgtRs{
        $SC = me&rollbsc,R,'Ying';
        isR(SC) and throw "%Ying became R"
        me&Yingwhen,R,SC and return
        me&Yong,R,SC,{},9;
    },'ift,D'],
    
    # Ying normally after R%Peace and schemas load 
    ['Ying','2926',&acgtRs{
        T.Mw = 'SC';
        me&reaw,R,'Ying,Outlog';
        $SC = me&rollbsc,R,'Ying';
        me&rollbs,R,'Outlog';
        me&Yingwhen,R,SC and return
        # < feedback, early intro tunneling
        ah(R,'nextlifesc','Ying',SC);
        # steps congealed
        $s = me&Yong,R,SC,{},9;

        s&boc = 588;
    },'ift,D'],
   
  // &Yingwhen - assign R/*%onlyish
    &{
    # since tunneling 18 you can see what's tunneled
    #   what's recycled will also be there
    me.whotun = &acgtR{
        $N = me&ioty,R;
        if (!Rs&tunneling) {
            # nothing
            # < a loose wave of attention,
            #   do 100ms work, etc.
            #   casually refreshing around:
            #   $R/*/(*/*), $R/(*/*), ($R/*)
            # ($R/*)
        }
        return N.filter(n => ns&tunneling && Rc&N.includes(n))
    }
    # see what's tunneled
    me.Yingwhen = &acgtRY{
        $tunneling = me&whotun,R
        if(0) {
            $blab = tunneling.map(&n{
                return n.t + (ns&sleeping ? "%sleeping" : "")
                    + (!ns&tunneling ? "!tun" : "")
                    + " P="+ns&Peace
            }).join(',');
            ~>3 tunneling: blab
        }
        $b = Rc&b;
        $est = b && bs&Ying;

        # the main things, $p%ball
        $two = tunneling.filter(n => ns&Peace == 2);
        # $p only, eg delivering %%eto:$p
        est && two.filter(n => !ns&sleeping).map(n => ns&onlyish = 1)
        # $R/$p only, all of them
        if (!tunneling.length) {
            if (est) {
                $e = me&Dtunneling,R
                e && me&Yingwhen_e,R,e and me&gosleep,R; return 1
                
                ah(R,'inheritscif','ball','onlyish',1)
            }
        }
        else
        # no &Ying for $R/$nonp (Yingu)
        !two.length and return 1
    };
    me.gosleep = &acgtR{
        me&recycleRbitXz,R
        Rs&sleeping = 'gosleep'
    }
    },
   
   // %onlyish
    # me&tunnel a cul de sac, to $p/*%sleeping
    ['Peace+onlyish','294',&acgtRs{
        $b = Rc&b;
        !b and return
        #throw "%onlyish !b"
        $N = bs&z;
        each ib N {
            !bs&Peace and continue
            bs&wakeful and continue
            $was = (Rs&z||[]).filter(r => r.t == b.t)[0]
            was and ~>4 %onlyish-already: R.t, b.t
            was and continue
            $c = me&tunnel,R,{b};
            c.aleeping = 'aleep';
            c.JRom and throw "%onlyish/%JRom"
            me&tunnelin,R,c
        }
    },'ift,D'],
    # go %sleeping after arriveRbitX (@17), like tunneling @18
    ['aleeping','18',&acgtRs{
        me&recycleRbitXz,R;
        Rs&sleeping = Rs&aleeping
    },'ift,D'],
    # like tunneling @94, copy all other sc, eg %elvis
    ['sleeping+aleeping','94',&acgtRs{
        each kv Rc&b.sc {
            R.sc[k] ||= v;
        }
        delete Rs&aleeping
    },'ift,D'],
   
  // %supr
    #
    # the %eph and its /** become %supr
    #  and %$sy&supr - suprise puts that
    ['ball+supr','291',&acgtRs{
        sy&R = R;
        # children get %supr in time to get here
        ac(R,'inheritsc','supr');
        # our %ball/%fix appear after @4
        
        
        
        
        
        Rs&fixatfour = 1;
        # %supr only becomes %$supr if a node:
        #  me&suprise mostly just transfers it
        #   to sy&supr on entering a node
        sy&supr and R.sc[sy&supr] = 1
        # see Y:Steps about %nextlifesc %nottilund
    },'ift,D'],

  // schema %KnowThee
    # http://hereth.localhost:1812/?Wayout/Fingo
    ['KnowThee','2924',&acgtRs{
        
        $h = me&Ying_Schema,R,'KnowThee',{};
        # G, storage type of step
        # bunch of G&t Q written down
        #  hierarchical looking, W/[W,W,W]
        #   able to conserve some hierarchy of W inclusion,
        #   and write down the essential Q of any ghost,
        #     may involve specificity, random folders
        #   in a pile easier to read than all the W.5s everywhere
        n Know 1  %bri:0.7,Pavings
        
        # Comal/Conal, Comste/Conste
        #n Compiling 3  %hue:70,supr:Conal
        #n Seq 5  %hue:110,supr:Conste,Omplateau
        
        # join
        # schema.c.twin puts %twin on the s.sc
        #  so does %Pavings, puts s%twmt
        n Ghost 2 twin:Travel|Know#of/t
        # awakening
        n Gump 3  %Gumptio
        n Travel 4  %Travels
        n Duolish 5  %Duolish
        # in a puff of ghost
        n To 6 twin:Travel|That#of/t
        
        n That 7  %Pavings
        #n Story 8  %Story

        hy&domed()
    },'ift,D'],

  // schema %TravelThee
    # http://hereth.localhost:1812/?Wayout/Lingo
    ['TravelThee','2924',&acgtRs{
        
        $h = me&Ying_Schema,R,'TravelThee',{};
        
        n Gump 3  %Gumptio
        n Travel 4  %Travelty
        n Duolish 5  %Duolish
        n Story 8  %Story

        hy&domed()
    },'ift,D'],
    
]};

me.Yingmind ||= {};
me.Yingmind.Schema = &acgt{ return [
    # SC/Schema/Y:$src/$step+ posit SC/Steps/$step+
    #  every time R%Ying wakes
    # < slep @2
    # %*T pronounces how it will be, arranging for SCing:
    # A:SC@1 %SupplyChai=C macro laterer
    #  A:Schema@1 %SCh/$t=C micro schema
    #   ...gets finished:
    #  A:Schema@2 can slep & tell macro
    #   @3 with each other, notice late joiners
    #   @4 patterns emerge
    #   @5 decide how to change the game in progress
    #   @6 Ret (via bal) the step
    # SCing:
    # A:SC@2 inits
    #  A:Schema@6 may be moved in here,
    #   to avoid it Ringing outside the SCing

    # %KnowThat forks SC/Schema/t=KnowThat
    ['+Schema',0.01,&acgtRYs,SC{
        # organise SC's Ys as of/t:
        $Sch = me&fiu,SC,'Schema';
        $t = Ys&t;
        !t and throw "give t"
        # el:1 recreates, string t makes spacer
        #  and sets sy&Y = Y
        $s = me&fiu,Sch,t,{el:1,Y:Y};
        # drop cache # < wake Y:Schema if diff
        delete Schc&compiled;
        # makes the subject of iteration, sets sy&Y=Y
        return s
    },'ift,D'],
    # day, display zone
    ['on',0.02,&acgtRYs,SC{
        sy&R = R;
        # nowhere:
        $g = sy&g = me&opeolo,s.t,{walls:'b:2.2h6',label:{walls:'bg'}};
        Rc&brackuiet = 1;
        gy&can('ope',&{ Rc&brackuiet = 0 });
    },'ift,D'],
    # i $s:schema/$step o T.nN/*:step
    # steps adopted from recent: n ...
    ['steps adopted',0.11,&acgtRYs,SC{
        $N = Ys&N;
        !N and throw "nosteps"
        each in N {
            $p = fio(s,[n.t,n.y.cv||1]);
            py&Schema_step and throw "multi schema step", n
            py&Schema_step = n;
        }
    },'ift,D'],
]};
