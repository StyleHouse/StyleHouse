# pile movie
me.Sch_Travel = &acgt{ return [
    =pod todo
    cm.getModeAt(pos
     < each step should Ring 2-9, try/catch

     nearly home
     &nodeo not found sends attention there:
      extra %twin &settle host makes it go,
      obscuring the probably still open:
       Travel%%tw making gets forgot:
       < %%eto dont land there reliably, is it:
        < coinciding &Yinge not lost
            # side tracks:
     < R%onlyish if R &settle,R/**,
        would be awake when we visit R,
        but can probably work for settling awaits:
       so %MayGansp may &settle all %%thing
     < come back to %MayGansp,
     to:
     < get all %%thing to %%ready|%%wantpush,Q,s+
     < push remainders, til all %%ready

     for coming back to %MayGansp
      awaiting all, until push ready
     < using %acty levels to move readiness around?
       they must &settle at each one,
       transmitting to neighbours
        was an inspiration for nodei
     < &elnodes must visit any $p/$n we add,
        to make sure it gives %twmt
       Rsync not enough?

     and back to this,
     < Know..s%Paving must be set up in the remotes
        or Ghost..s can be trusted to &nodei them?
     < Ghost..s grows/shrinks and downloads s.sc
      < goners may gc Know..s if !ja,Ghost,{host:Know,s}
      < keepers may drop sc evident in Know..s
      < other Ghost..s may acquire sc, above in reverse

     ^ loosely around:
     < n must push to That..s
     < u must be as Know..s, or Ghost..s may acquire sc
    =cut
   // &Jx etc - ->
    &{
    # expressions for
    me.Jx = &acgtRc{
        $C = Rs&C;
        $x = Cye(["x:"+R.t,22])
        
        # 2 degrees of local Js by name, c/sc R/s
        # the 4
        xc&Ying = me.cbu(R,'Ying')
        !xc&Ying and throw "!Ying"
        # the 3, aka 'client'
        xc&client = me.cbu(R,'SummerCat');
        !xc&client and delete xc&client;
        # throw "!client"
        each tr x.c {
            x.sc[t] = rc&s
            me&ioty,r,'ball' .map(&n{
                x.c[n.t] = n;
                x.sc[n.t] = nc&s;
            });
        }
        
        # < x. contextualised modulata/expressiona: x.ro, etc
        # click act
        x.ro = &kc{
            c ||= {once:1};
            c.k = k;
            return me&rolltog,R,c
        }
        
        # < brackimply: sets x.zaa etc to dome:plans or etc
        #   you: x.doming = 'plans' # etc per S
        return x
    }
    # send attention via Ying &waits_8
    #  no trace left in r, not like &nodee
    #   although most cases of this could be,
    #   eg Jproto elvises %%now to Jrunto,
    #    which process them and return an answer
    me.Yingwant = &acgtrsc{
        $R = me.cbu(r,'Ying');
        c = ex({waits:r,wants:s},c||{})
        me&ha,R,c
    }
    me.Yingerr = &acgtRetc{  
        $n = G&Cye,[t||'error','',{er:e}];
        nc&s = (e.message || e)+'';
        ns&now = Gtime();
        ns&A = A;
        ns&B = Gc&B;
        ns&R = R;
        nc&s.match(/^async/) and ns&async = 1
        else
        # < fix this... not realising its not ready?
        nc&s.match(/^no way:/) and ns&async = 1
        # bunch of artifaces, < (t,$s)+
        e.tc and nc&M = e.tc
        return n
    }
    },
   
// Yingu - every frame
    ['Yingu','7',&acgtRs{
        
        me&reaw,R,'Yingu';
        me&tsc,"%Yingu",0,'B' .sc.dis = 1;
        n Yingito  R %Tool
        
        $Y = Rs&Ace;
        $f = Y.4[1];
        $Ying = fs&Ying;
        me&nu,'Ying',Ying;
        !fs&Outlog and return
        $la = fs&Outlog.slice(-5);
        each il la {
            $k = fs&Outlog.indexOf(l);
            $g = me&opeolo,k,{label:{walls:'bg'}};
            gs&dis = 1;
            me&bracko,R,l,'wake',1 .map(&n{
                me&opeKm,g,n.t
            })
        }
        
        4s&intere and me&nu,'intere',4s&intere
    },'ift,D'],

// Story - intents <-> extents
    =pod
    < @Story groups time, turns observe/respond corner
      pretending to be Fingo S-ing, providing:
        < log interesting acts
         eg CBing|Travel|Duolish starts|ends
        < log should be mergible with Yingu, Evelse, etc logs.
        shuntographer
        runs the game seq:
        < %Paving nice, found%Pave
        < @Story: %Paving+twinned ready
        < %Paving CB also from Ghost..$z
         diff Know..$s/found%Pave with:
          Know..$s%Paving itself
            eg %cha:Thing-has:dige,src:s,from:Q
          Ghost..$z%twin, as used by Travel..$t
            eg %%cha:Thing-has:dige,src:s,from:Q,to:z,t:t
        < %Gump gets Know..$s (+ Ghost/$t..$z)? out of date
        < @Story: %Paving+twinned+%Gump ready
        < %Story:
         any Ghost/$t..$z -> Travel/$t
         notices them vanish, knows why
        < @Story:
          start Travel/* wanted,
           pre-@Search the %Gump versions (%Jhost)
            inc anything in a $W.5, with wjs %args
          start Travel/$t
          end Travel/$t
          end Travel/*
          start Duolish/*
           $u should be as input to %Gump, or restart?
          end Duolish/*, when all is commit
    =cut
    &{
    },
    ['Story',0.5,&acgtRs{
    
        me&reaw,R,'Story'
        $x = me&Jx,R;
        
        # on init
        # < uses Yingu to hide most of the steps
        #  when to unfold because why
        # < 300ms impatience for getting past:
        # always:
        # < wait for &settle without subscribing to updates from everyone?
        # < Ghost/$zt..$z &settle are too busy
        $them = 'Know Ghost Travel To That Duolish Gump'
            .split(' ').map(t => x.c[t])
        #me&settle,R,them and return

        # sometimes here because quiet (out of wakers[])
        # < not before a slow wakers[], for async
        #    may finish waiting early
        sy&quue ||= 0;
        $q = me&quiet_waker,s
        q and me&tsc,"q"; sy&quue++
        !sy&quue and return
        
        $D =
        sy&Nar ||= me&logdome,R,s
        Dc&thing = me.cbu(R,'Ying').sc.Outlog;
        q and Dy&domed(); Dy&dome("le "+sy&quue,'light')
        
        me&tsc,'y','','y'
        me&nodei,R,xs&Gump,{narrative:1},{dome:'nar'}
        
        $g = me&opeolo,R,'plans';
        each im Ds&z {
            # tabular expression?
            $gr = gy&can('w');
            $se = gry&can('c');
            $lc = sey&can('i',m.t)
            $le = gry&can('c');
            each in ms&z {
                #lcs&ope and ha('now',n)
                $ro = ley&can('w');
                ros&hue = 38;
                $rc = roy&can('i',ki(n,4.23))
                lcs&ope and roy&can('nu',"zip")
                
            }
        }
        me&nu,"Nar",D
    },'ift,D'],
  
// Gump - Know|That %%cha -> Travel
    ['Gumptio',0.5,&acgtRs{
    
        me&reaw,R,'Gumptio'
        
        me&jaa,R,'chag' .map(&n{
            # Know..$z
            $z = ns&efrom;
            # Travel..$n
            $N = me&otwin,z
            N.map(&n{
                $t = me&tpath,z
                me&zu,t,n
            })
        })
        
        # any new narrative is filled with the %%chag of now
        me&jaa,R,'narrative',1 .map(&i{
            $dome = 'v'+i
            me&ja,R,{dome} and return
            me&jaa,R,'chag' .map(&n{
                $z = ns&efrom
                n = ns&n
                me&otwin,z .map(&t{
                    me&ha,R,n,{dome},{cha:ns&cha||'?',t:t}
                })
            })
        });
        # < manage the Travel/$t
        # < %%chag instability before commit,
        #    see %Compiling
        
      // testable
        return;
        uniq( me&jaa,R,'chag','efrom' ) .map(&Z{
            # Know..$Z
            # Travel..$z
            $N = me&otwin,z
            
            $c = {};
            #z.t == 'Easiness' and me&zu,"from",z;
            c.from = me&tpath,Z;
            c.to = [];
            me&otwin,Z .map(&z{
                #me&zu,z;
                $b = {to:me&tpath,z ,from:[]}
                c.to.push(b);
                me&otwin,z .map(&v{
                    #v != z and me&zu,"diff",v
                    $path = me&tpath,v
                    b.from.push(path)
                    v == Z and b.from.push("== from")
                    ##path == 'That/W/Easiness' and me&zu,"^from",v
                })
            })
            me&zu,"fro",c
        })
        
    },'ift,D'],
  
// Duolish/%Releasor <- Travel
 # < de y&p %twin
   // %Releasor
    =pod see %Compiling
      a %Compiling in its push-phase,
       can decide to redo, because CBing, already
    
     Travel%%tw=$t should match:
     Ghost%twin/$t, giving (/of/$kt)
     Know%%tw=$kt same in reverse
     # on the inside of the join:
      Ghost..$t may know %%tw,s,host=Travel|Know already
     # on the outsides:
     Travel|Know p are %twinned by Ghost,
      Ghost providing queries from their perspective
       on Ghost p %structure, [C:t,C:of,C:t]
     
     Then we should end up with...
     < sheets of $t..$kt to apply to the joins:
       u towards Know:
        should still be that version
       n towards That:
        
       
     < other Ghost..$z joining Know..$kt etc,
       all have a %dige on Ghost..z, not:
       must have their truth shrunk onto the join,
       since we are replacing the shared record of something
       this is like getting pinned at a version, 
     < some even more complex Zave-tuition
    =cut 
    ['Releasor','298',&acgtRs{
        me&reaw,R,'Releasor';
        $S = me&inode,R;
        # to %ball/* from y&tw over s&z
        Rs&childy = 'tw';
        # Travel is %twinned to other steps
        $p = sy&participant
        # Travel/$t == sy&client (the experience)
        py&s != sy&client.y.up and throw "parts!client"
        !p and throw "nop"
        #$tr = Ry&up;
        #tr = trc&s;
        # < stop using y&p
        #$p = try&p;
        #!p || tr.t != 'Duolish' and throw "Travel?"
        
        # s was e, replaced on shunt
        # is the reality (Re:$t), beside the thing itself ($t)
        
     // func
      # < io this easy
      // y&Q leavers
        # $Steu/of(/args)?/t -> callback
        me.ofargsity = &acgt,Steu{
            return &y{
            me&indo,Steu (&sd{
                d.d <3 and return 's/of'
                $more = me&ioty,s .length
                more and return 'is an /args/ layer'
                $l = me.cby(d,&d{ return d.d <3 }).map(d => d.s);
                $t = l.pop();
                t != s and throw "confu";
                $of = l.shift();
                $args = l[0];
                # may not have args
                y (of,args,t)
            });
            }
        }
        # warn of args: $Steu/of(/args)?/t -> $f/of(/args)?/t
        # < for stretching %twin to support anyindex
        me.warn_argsity_of = &acgtWf{
            # W is the of column, nest it
            $cont = Cye(['eachofalone',1])
            me&fiu,cont,W;
            # warn of non of/t pushing (or whatever the %twin wants)
            me&ofargsity,cont (&of,args,t{
                $fo = me&fiu,f,of.t;
                args and fo = me&fiu,fo,args.t; ah(fo,'warn',"args-layer")
                $to = me&fiu,fo,t.t;
                args and me&zu,"hasArgs:",to
                toy&Q = t;
            })
        }
        # ac args: $Steu/of(/args)?/t -> $f/of/t%args[]
        # for writing as W.5
        me.Stearchish_to_twin = &acgt,Steu,f{
            $N = [];
            me&ofargsity,Steu (&of,args,t{
                $fo = me&fiu,f,of.t;
                $to = me&fiu,fo,t.t;
                tos&dige && tos&dige != ts&dige and throw "multiple diges ->"+to.t, t, toy&Q
                toy&Q = t;
                tos&dige = ts&dige;
                args and ac(to,'args',args.t)
                N.push(to)
            });
            return N
        }
        me.Stegroup_species = &acgtW,Steg{
            # sublate any species (share one $kt)
            #  $m:Dealap,$n:Dealap/js -> $m:Dealap/$n:js
            # < order by length of SteW/*.t, hier not fair
            $c = {yorigin:'Q',
                match:&mn{ return n.t.startsWith(m.t) },
                then:&mng{ 
                    g.t = gs&species = n.t.substr(m.t.length+1);
                    g.t && !g.t.includes('/') and 'ok'
                    else {
                        throw "species!grouping", m, n
                    }
                }
            };
            me&sublatile,W,Steg,c;
        }
      
      // y&origin leavers
        # rebuild and replace? $n/#$t
        me.Stereo = &acgtWt{
            !isC(W) and throw "!C W"
            W = Wy&origin || W;
            $eg = Cye(W);
            # to somewhere else
            isC(t) and $F = t
            else {
                # replacing
                $F = Wy&up;
                !F and throw "W!up"
                # ~t adding
                isst(t) and eg.t = t
                
            }
            egy&origin = W;
            return &y{
                y (W,eg);
                # places new thing
                !F and return
                $f = me&fiu,F,eg,8
                f && f != W && fy&origin != W and throw "knot sure", F, eg, f
                F and me&fiu,F,eg
            }
        }
        # regroup into each other
        me.sublatile = &acgtWtc{
            $into = t;
            c.yorigin ||= 'origin';
            me&ioty,W .map(&n{
                $g = Cye([n.t,2]);
                g.y [c.yorigin] = n;
                each im intos&z {
                    m == n || !c.match(m,n) and continue
                    c.then(m,n,g);
                    me&fiu,m,g
                    return
                }
                me&fiu,into,g
            })
        }
        
     // dunketha
      // outputs + 5 -> twin-form
        # have outputs
        $Sten = me&fiu,s,'n';
        $Steu = me&fiu,s,'u';
        
        # to output, nego into %twin
        $twine = me&fiu,s,'twine';
        # z first, leading up
        ss&z = arou(ss&z,z => z == twine,[]);
        ss&z.unshift(twine);
        
        # n
        $twn = me&fiu,twine,'n';
        # < various use cases for a wait-for-ok
        !me&fiu,Sten,'W' and return me&waits,"!W"
        
        me&ioty,Sten .map(&W{
            me&Stereo,W,twn (&W,eg{
            # schematic of what Q to place where
            $Steg = Cye(['g',1])
            
            if (W.t == 'W') {
                # make a pile of W%dige/[species%dige+]
                me&Stegroup_species,W,Steg;
        
                # each W make W.5 re this u/n configuration
                # make W.5 for each W grouping
                me&ioty,Steg .map(&m{
                    $f = Cye([m.t,9]);
                    # the 5.sc[$species] = dige, inc 1=Ws&dige
                    $spec = {1:m};
                    me&ioty,m .map(n => spec[n.t] = n);
                    each tn spec {
                        # the SteW/* is Qish: Q%string%dige without %of%args
                        #  which are implied by their placement in the Searchish
                        $Q = ny&Q;
                        f.sc[t] = Qs&dige
                    }
                    # re this u, flattening args
                    # < of:wjs -> of:w through the join?
                    #   see W|w: their species pool dige sensitivity
                    me&Stearchish_to_twin,Steu,f;
                    # f -> Qish q
                    $q = Cye(['5',2]);
                    qs&string = me&Lineso,f;
                    qs&dige = dig(qs&string);
                    # species thing fronting q as a writable of $W
                    me&fiu,m,q.t,8 and throw "already had a W.5", m
                    # into the Qish pile we began with
                    $n = me&fiu,m,q.t;
                    ny&Q = q;
                })
            }
            else {
                # copy anyway!
                me&warn_argsity_of,W,Steg;
            }
            
            # n... have %string etc from y&Q
            #  Steg structure y&Q -> g
            #  for something %%twin->Paving compatible re %species
            #  all other $of should just work?
            # < io resolving to y&Q, type checking
            me&indo,Steg (&sd{
                d.d <2 and return
                $p = d.la || eg;
                $v = sy&Q;
                !vs&dige and throw "notdiged",s,v
                v = d.la = Cye(v);
                # < doesn't keep the 
                vy&Steg = s;
                # t=$W/js -> js
                v.t = s.t;
                me&fiu,p,d.la
            });
            })
        })
        
        # n/W is now folded like %twin of/t
        #  with extra n/W/$species for Pave to realise exactly
        # checks others dont /args/
        # < %twin should learn anyindex:
        
        # < only for of:wjs?
        #   you might want the %twin|%Paving indexing to carry the args
        #   eg for watching lists,
        #    or anything but W|w which pool one big dige per thing
        # so in the .5 we know individual args,
        #  so reruns can more fully prepare eg of:wjs
        # yet for overall versioning,
        #  w:$t%dige is all Ghost/Know remembers
        #  will cover wjs:$t%dige(same)%args
        # W%dige covers W.js etc but not W.5,
        #  but W.5%dige covers W+W.js
        # < a ghost/w/wjs have the same %dige?
        
        # fold up all the u:
        # < wjs->w?
        # u... only have %dige etc (not even %args?)
        $twu = me&fiu,twine,'u';
        me&Stearchish_to_twin,Steu,twu .map(&to,{
            # drop deindexed info
            delete tos&args;
        })
      // outputs -> twin-linkage
        # looks for u/n stores behind/ahead of Travel
        # < complicated ideas
        
        # made a 5 about this s, added to itself,
        # added to n, to push via %twin
        #   W:Dealap will be a single yonder,
        #    though while this awake the 5 + js may update
        #   then Fingo should save asap
        
        each in ps&twinned {
            # < find t there, make &acty=3
            ns&remotes[0] != p and throw "aban"
            $r = ns&remotes[1];
            $h = r.t == 'Know' ? twu :
                r.t == 'That' ? twn : 0
            !h and throw "unremote", n, r;
            # for %MayGansp
            hy&release = s
            # Travely&p
            hy&host = p
            # Ghosty&pc&s
            hy&twin = ny&s
            # Knowy&p
            hy&remote = r
        }
    },'ift,D'],
   
   // Releasor/%MayGansp/%MayTwine+
    &{
    me.deboost = &acgt{
        $R = Cy&R;
        # < Babz: //= # !null-or
        Rs&boost == null and Rs&boost = -1
    }
    
    me.bin = &acgtk{
        $R = Cy&R;
        isst(k) and k = G&peel,k;
        each tv k {
            ah(R,'inheritscif','ball',t,v)
        }
    }
    },
    ['sleeping+wou_accepted','297',&acgtRs{
        # %wou must be there to access _accepted
        # < why w_a if no w when tunneling?
        me&rollbs,R,'wou'
    },'ift,D'],
    ['MayGhost','298',&acgtRs{
        me&reaw,R,'MayGhost,eph';
        me&bin,'MayGhost';
        $l = me.cby(R,'^^Releasor').length;
        l == 2 and s.t == 'twine' ? me&bin,'MayGansp' : me&deboost
        
        l <2 and return
        (Rs&boost||0) < 0 and Rs&thiding = me&ioty,s .map(z=>z.t)
    },'ift,D'],
   
   // %MayGansp - %twin find
    # %twin climb beings, to its idea of us
    ['MayGansp','298',&acgtRs{
    
        me&reaw,R,'MayGansp,eph';
        me&bin,'MayTwine';
        $S = me&inode,R;
        
        $g = me&case,34
        $twin = sy&twin;
        !twin and throw "!join to"
        gy&can('m','to').y.can('i',twin.t);
        
        $rs = sy&release;
        !rs and throw "!t->u/n bunch"
        !rsy&client and throw "release!client"
        # Ghost%%tw,host=from|yonder
        $host = sy&host;
        !host and throw "!join from"
        #hosty&s != sy&path[0] and throw "join from!this step", host, s
        # < %twin-like anyindex to anywhere
        $re = sy&remote;
        !re and throw "!remote host yonder"
        
        # < p only as Schema meta, make twin = s, sy&structure
        $tp = twiny&p;
        sy&structure = tps&structure;
        
        # Ghost%%tw=t.t,host=Travel
        me&twin_nodeo,R,twin,host,{tw:rs.t} (&n,t,zt{
            # %%found:Ghost/$zt, also found its Travel/$t
            # $n coming from Ghost%tw... has efrom=$zt, s=$t
            me&ha,R,{found:zt,t}
            $zt = ns&efrom;
            # which we remember from running it
            ns&s != rsy&client and throw "whose"
            # < $zt &settle $zt/*, so $zt/*/* changes ping
            me&settle,R,zt
        }) (&{
            # auto input Ghost/$zt
            #  this eto retracting when Ghost has it
            me&nodei,R,twin,{tw:rs.t,el:2}
        })
        
        $st = me&ollbs,R,'brackstable';
        me&zu,"olst",st
        
        me&ha,R,{twin}
        # bump Ghost when s/** settle
        me&ollbs,R,'brackstable' == 1 and me&ha,R,{waits:'heard',wants:twin}
        me&tsc,"mg",'','d'
        
        #(Rs&boost||0) > 0 and me&zu,"MayGansp.s",s;
    },'ift,D'],
   
   // twin|tw nodeo
    &{
    # the _nodeo c.t make %%(found|yonder)=$s,via=$z
    me.nodeo_foundha = &acgtRcqn{
        !c.t and throw "!t"
        !n && q.s and q[c.t] = delete q.s
        # < n.sc[c.k], returns what to iterate as $s
        q[c.t] ||= ns&s
        !q[c.t] and throw "foundrow !s"
        me&ha,R,q
    }
    # nodeo but with a perspective on a %twin
    # < tysc args: this is c||,=t(c)
    me.twin_nodeo = &acgtR,twin,host,c,t{
        isst(c) and c = {t:c}
        t and c = {q:c,t:t}
        $j = me&yfuture,twin;
        $q = c.q || c
        # %MayGansp &settles j/$zt once found
        #  is too specific to &settle j|Ghost itself
        q.host ||= 1;
        $N = me&zaa,j,q
            .filter(n => ns&host.t == host.t);
        return &per_thing,{
            N.length > 1 and return me&waits,"many:"+twin.t+"->"+host.t;
            N.map(&n{
                c.t and me&nodeo_foundha,R,c,{via:ns&efrom},n
                per_thing (n,ns&s,ns&efrom)
            })
            return &if_nothing,{
                !N.length and if_nothing()
            }
        }
    }
    # tw ^%%found -> %%found or %%almost,into
    # < &settle zp,z you might?
    # < tysc args: this is c||=t(c)
    me.tw_nodeo = &acgtRpsc{
        isst(c) and c = {t:c}
        # p has %%found
        $zp = me&zaa,p,c.q||c.t,1 [0];
        zp && !zpy&R and zp = 0
        if (zp) {
            # to be put in $zp/$z
            $z = me&fiu,zp,s.t,8;
            !z and me&ha,R,{almost:c.t,into:zp}
        }
        # they must node init
        # < occasion to force %%wants?
        z && !zy&R and z = 0
        z and me&nodeo_foundha,R,c,{s:z}
        return &per_thing,{
            z and per_thing(z)
            return &if_nearly,{
                !z && zp and if_nearly(zp)
            }
        }
    }
   
   // &otwin, &elnodes
    # use a %twin join, given Know|Travel..s
    # finds Travel|Know..s
    # < gives paths and takes directions like &jaa
    me.otwin = &acgts{
        # Know..s, find Know%twinned = Ghost
        $S = sy&path[0];
        $p = Sy&p;
        $N = [];
        each in ps&twinned {
            $twin = ny&R
            # Ghost eto the index:
            #  %%s:Know..$s
            #  %%inside:Ghost/$a
            #  %%efrom=Ghost..$z that found Know%%tw,s
            # < use with host:$p if tw, needs a direction to go
            me&jaa,twin,{s} .map(&n{
                # Ghost/$a <-> Ghost..$z%%inside
                $q = ns&inside ? {efrom:ns&inside} : {inside:ns&efrom}
                #N.push(q)
                N.push( ... me&jaa,twin,q .map(n => ns&s) )
            })
        }
        return N
    }
    
    # nodein %%el,tw requets +|- $s/#$e
    # < get flowing
    me.elnodes = &acgts{
        $R = Cy&R;
        me&jaa,R,'el,tw,efrom' .map(&n{
            $t = ns&tw;
            $was = me&fiu,s,t,8;
            ns&el == 2 and me&fiu,s,t
            else
            ns&el == 9 and me&fiu,s,t,9
            else {
                # < waits takes params?
                return me&waits,"unknown-e"
            }
            $cha = ns&el == 2 && !was
                || ns&el == 9 && was;
            if (cha) {
                # if we are a step, dont %onlyish
                sy&p and Rs&numberclicked = 1;
                # < wake s to init n, only, so adhere etc
                #   wants a pointer to not yet node
                me&ha,R,{waits:'elnode',elnode:ns&el,wants:s}
                #me&Rsync,R;
            } 
            # < %twin them immediately
            # sender must &settle Ghost**
        })
    }
    
    },
    
    
   // %MayTwine - %twin climber
    ['MayTwine','298',&acgtRs{
        
        me&reaw,R,'MayTwine,eph,activy';
        me&bin,'MayTwine';
        $S = me&inode,R;
        $mg = me.cbu(R,'MayGansp');
        $ms = mgc&s;
        
        $x = me&Jx,R;
        $ja = &c{ return me&ja,R,c };
        
        $li = sy&path.indexOf(ms);
        li < 0 and throw "!^^MayGansp"
        $l = sy&path.slice(li);
        li = l.length-1;
        $h = msy&structure[li];
        # t/of/t/species is pushed but not remembered
        !h and me&ha,R,'extra'
        else
        # a t/of/t, or any complete leg of index
        #  that we want to push a state to
        !msy&structure[li+1] and me&ha,R,'thing'
        
        # Travel/* <-> Ghost/$ms..$z <-> Know..$K
        $K;
        
        # twin|tw_nodeo: p%%found=$zt|$z / #$s
        $p = Ry&up;
        me&tw_nodeo,R,p,s,'found' (&z{
            me&jaa,R,'found',1 [0] != z and debugger;
            # we are %%found=z
            $zj = zy&R;
            !zj and return me&waits,"theyR"
            !ja('thing') and return
            # Ghost%%tw... again for the other side
            me&twin_nodeo,R,msy&twin,msy&remote,{tw:s.t},'yonder' (&n{
                # we are %%yonder=K
                # wake %MayGansp on Know..K connection
                !me&za,R,'yonder,via'
                    && me&ha,R,{waits:'foryondering',wants:ms}
            }) (&{
                # tell it to nodeo input a Know..%Pave
                $tp = me&tpath,s
                $tpz = me&tpath,z
                ~>5 nottwin: tpz, tp
                $may = me&jaa,zj,'may:input' .filter(n => !ns&eto)
                if (may.length) {
                    me&nodei,R,zj,{s,may:'input'}
                    # < then making sure Know/ finishes 
                    !me&za,R,'s,may:input'
                        && me&ha,R,{waits:'forKnow',wants:ms}
                }
            });
        })
        (&into,{
            # we are %%almost=found,into:zabove
            # not beyond the path
            me&ja,R,'extra' and return
            # i $into/#$s:z, remembering we did so
            ~>6 el2: msy&remote+'..'+s.t
            # < settle it before this. attend back here after|before,
            #    depending on the relativities of those wakers
            me&nodei,R,into,{tw:s.t,el:2},{dome:'awakes'}
        })
        
   // %twin->%Pave
        # < check %%extra are ready...
        # < Gansp's %%thing collection should become stable
        # < &settle (no other) - for all so far
        # < &settle cv, EXPR - EXPR||Ying-wide wait
        #   if lower cv settles await !
        # < x&ja,c,1 for:
        $K = me&jaa,R,'yonder',1 [0]
        $z = me&jaa,R,'found',1 [0]
        
        K && me&twin_nodeo,R,msy&twin,msy&remote,{s:K} (&n{
            # Know..K can find other Ghost..z
            ns&s == K and return
            me&ha,R,{otherz:ns&s,via:ns&efrom}
        });
        
        $twin = me&ja,mg,'twin',1 [0];
        if (ja('thing')) {
            !K and 'wait-for-climbing'
            elsif (me&settle,R,K ) {
                me&ha,R,{waits:'forK',wants:K};
                me&tsc,'..K'
            }
            else {
                # < flavours of waiting for something
        
                # Ghost..z has the Travel'd version, K may ~
                zs&dige = ss&dige;
                # < or perhaps only if it's not as K implies,
                #   requiring all changes of K%dige to offset all its twin..z
                #ss&dige == Ks&dige and delete zs&dige

                # can expect|%%actey-vate %Paving on things
                if (twin.t == 'Ghost') {
                    # should be as we u, or slightly old
                    !Ks&dige and me&ha,R,{waits:'Kdige',wants:K}
                    me&ha,R,'ready'
                }
                elsif (twin.t == 'To') {
                    # should be as it was
                    # < to %parent, if ~ since we Travel to replace it?
                    #   esp if it was W load+save
                    me&toPave,R
                }
                else {
                    me&zu,"weird_twin",twin
                }
            }
            # %MayGansp collects %%thing,ready?
            $q = {thing:s}
            ja('ready') and q.ready = 1
            me&nodei,R,mg,q
        }
        
        ja('extra') and me&toPave,R
        
        # < something to settle all %%thing,
        # < mark each then all %%wantpush
        
        #(Rs&boost||0) > 0 and me&zu,"MayTwine.s",s;
    },'ift,D'],
   
   // %MayGansp unit
    ['MayGansp','299',&acgtRs{
        
        $x = me&Jx,R;
        me&jaa,R,'thing',1 .map(&z{
            $j = zy&R;
            # should lead back here after rattle
            me&settle,R,z
            
            me&ja,j,'ready' and me&ha,R,{ready:z}
            else 
            me&ja,j,'wantpush' and me&ha,R,{wantpush:z}
            else {
                # < curio: match jam to lateral shunt
                if (0 && !me&ja,j,'yonder' ) {
                    me&nodei,R,z,{actey:3},{dome:'tilpushed-actey'}
                    $found = me&jaa,j,'found',1 [0]
                    if (found && me&ja,j,'eto,s,may:input'
                        # input done,
                        && me&ja,foundy&R,'eto,s,may:input'
                        # without That%%tw, no To%%tw yet:
                        && !me&ja,foundy&R,'eto,tw,s' ) {
                        # < unfreezable numberclicked That
                        # jy&up
                        #me&nodei,R,z,{actey:3},{dome:'tilpushed'}
                        me&tsc,z.t+"-may:"
                        $rp = sy&remote;
                        $r = me&yfuture,rp;
                        rs&numberclicked = 1;
                        me&ha,R,{waits:"may:input-shunt",wants:rc&s}
                    }
                    # then waiting for:settle-!down
                }
                me&ha,R,{waiting:z}
            }
        })
        # wait for all %%ready|wantpush
        # < periodically poke the $of of any %%waiting
        me&ja,R,'waiting' and return
        !(me&ja,R,'ready' || me&ja,R,'wantpush' ) and return
        # desend %%actey now they all must have succeeded
        me&za,R,'waiting' and me&dome_traction,R,'tilpushed-actey',{el:2}
        # wait for all %%ready after any %%maypush
        if (me&ja,R,'wantpush' ) {
            x.ro("push*") &&
            me&jaa,R,'thing',1 .map(&z{
                $jo = me&yfuture,z;
                # < slow dige-through only, user must see diffs
                me&nodei,R,z,{maypush:1},{dome:'tilpushed-push'}
                me&ha,R,{waits:'tilpushed',wants:z}
            });
            return
        }
        me&tsc,"Done!"
    },'ift,D'],
   
   // &toPave - Ghost|Know..n(.*)
        &{
        me.toPave = &acgtR{
            
            $s = Rc&s;
            # looking at the thing's W
            $extra = me&ja,R,'extra';
            $Kr = extra ? Ry&up : R;
            $K = me&jaa,Kr,'yonder',1 [0];
            !K and return me&tsc,"!K"
            
            $Paving = Ky&R;
            $species = extra ? s.t : 1
            $of = Pavings&Paving
            if (of == 'W') {
                # W have species
                $spQ = Pavings&species_Q
                !spQ and me&waits,"Paving!species_Q"
                $Q = spQ[species];
                # load a %Pave for any species that wants to be here
                !Q &&
                    me&nodei,R,Paving,{species},{dome:'tilpushed'}
            }
            else {
                extra and throw "extra for Paving:"+of, s
                $Q = Pavings&Q
            }
            !Q and return me&tsc,"!Q"
            
            # < excercise for determiniteness:
            # < give|take|note %%(Is|Pushable|Parent):$dige from Gansp,
            #   so Gansp<->Story knows if any u changed while running
            # < to wy&D = copy of Q%string,dige - enough to resume
            # Q+w|Live is the parent considered
            #  R %%Pushable %%ready are pushed
            #  R %%Parent !%%ready want push
            $w = Qc&s;
            me&ja,R,'Pushable' ? 'should still match:'
                : me&ha,R,{Is:Qs&dige,w};
            
            ss&dige == Qs&dige and return me&ha,R,'ready'
            
          // diff
            $q = {wantpush:1,Q,s};
            # < W may include them all in one request?
            #   ideally all these Qings would e W,
            #   prove compat (eg consensus, auth, parent|patch),
            #   and be merged, reversibly
            extra and q.species = species;
            # &nodei also puts %%wantpush in this R,
            # < though you might ignore it because %%eto
            # < conversely, pay more attention to %%efrom
            R == Kr ? me&ha,R,q : me&nodei,R,Kr,q;
                
            $g = me&opeolo,"Runthing",{walls:1};
            $pa = gy&can('m',Q.t);
            
            pas&mah = 30;
            #!pas&ope and continue

            Qc&el == 9 and me&mtsc,pa,'New!'
            else {
                $c = {t:Q.t,Zif:1};
                c.got = s;
                c.exp = Qs&P;
                $di = me&Ret,R,c;
                me&zN,di;
                me&Ring,di,{und:di,ov:314};
                me&zuct,pa,di;
                pas&dis = 1;
                each in dis&waits {
                    ac(R,'waits',n)
                }
                Rs&summary = dis&summary;
            }
            
          // push
            $Pave = Qy&R;
            !Pave && Paves&Pave and throw "pushQ!Pave"
            
            $go = me&rolltog,R,{maydo:'Push',once:1,tsc:'B'},0;
            go ||= me&ja,Kr,{maypush:1};
            # sticks while dige same
            go ||= me&sa,R,{Pushable:ss&dige};
            !go and return
            if (!me&rollbs,R,'sent_string' ) {
                # Q asks
                ~>3 push: R.t
                Paves&commitstring(ss&string);
                Rs&sent_string = 1;
            }
            if (Qs&string == ss&string) {
                me&tsc,'pushed';
                # it cancels the go
                go = 0
            }
            else {
                $pu = me&tsc,'pushing'
                # %Paving may update ss&dige = %%commit
                # < check extras have commit
                !extra and me&nodei,R,K,{commit:ss&dige},{dome:'tilpushed'}
                me.nto(R,pu,&{ 
                    ~>3 repush: R.t
                    delete Rs&sent_string })
            }
            me&ha,R,{Pushable:ss&dige}
        };
        },
        

]}