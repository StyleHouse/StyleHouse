# pile movie
me.Sch_Travel = &acgt{ return [
    =pod todo
    cm.getModeAt(pos
     < each step should Ring 2-9, try/catch

     nearly home
     &nodeo not found sends attention there:
      extra %twin &settle host makes it go,
      obscuring the probably still open:
       Travel%%tw making gets forgot:
       < %%eto dont land there reliably, is it:
        < coinciding &Yinge not lost
     < come back to %MayGansp,
     to:
     < &sleepic so %MayGansp may &settle all %%thing
     < sip: get node** %%thing to %%ok|%%wantpush,Q,s+
     < push remainders, til all %%ok

     for coming back to %MayGansp
     < using %acty levels to move readiness around?
       they must &settle at each one,
       transmitting to neighbours
        was an inspiration for nodei
     < &elnodes must visit any $p/$n we add,
        to make sure it gives %twmt
       Rsync not enough?

     and back to this,
     < Know..s%Paving must be set up in the remotes
        or Ghost..s can be trusted to &nodei them?
     < Ghost..s grows/shrinks and downloads s.sc
      < goners may gc Know..s if !ja,Ghost,{host:Know,s}
      < keepers may drop sc evident in Know..s
      < other Ghost..s may acquire sc, above in reverse

     ^ loosely around:
     < n must push to That..s
     < u must be as Know..s, or Ghost..s may acquire sc
    =cut
// Yingu - every frame
    ['Yingu','7',&acgtRs{
        
        me&reaw,R,'Yingu';
        me&tsc,"%Yingu",0,'B' .sc.dis = 1;
        n Yingito  R %Tool
        
        $Y = Rs&Ace;
        $f = Y.4[1];
        $Ying = fs&Ying;
        me&nu,'Ying',Ying;
        !fs&Outlog and return
        $la = fs&Outlog.slice(-5);
        each il la {
            $k = fs&Outlog.indexOf(l);
            $g = me&opeolo,k,{label:{walls:'bg'}};
            gs&dis = 1;
            $wake = me&bracko,R,l,'wake',1
            wake && wake.map(&n{
                isC(n) ? me&opeKm,g,n.t
                    : gy&can('nu',n)
            })
        }
        
        4s&intere and me&nu,'intere',4s&intere
    },'ift,D'],
    
// Detection - whats going on
  &{
  // &Yingate_2|8: %OutLog += $D-gate
    # Ying happens
    me.Yingate_2 = &acgtRc{
        me&reaw,R,'Outlog';
        $D = me&Outlog,R,'gate'
        Rs&Det = D;
        # Story signals
        me&YingelQup_2,R
    }
    # Ying/** happens
    # < take extra pictures 
    # < become RbitXarrive
    # < further tunneling, counts as landing the pointer in R
    #    all its limbs want to ok this before acting,
    #     unless they are separated by chunks of
    #     Story to see before the next steps
    me.Detection_2 = &acgtRpr{
    }
    # count as an awake step|node
    #  (step may be asleep if tunneling to nodes )
    # < extend/solve Dtunneling above
    me.Detection_7 = &acgtRpr{
        $D = Rs&Det;
        $c = {}
        rs&Det and c.Det = rs&Det
        
        $k = ry&up == R ? "step" : "node"
        $s = rc&s
        !s and throw "nos"
        c[k] = s
        
        me&bracki,R,D,c
    }
    # waits_8 noticing later[] etc woke this time
    me.Detectioned = &acgtRs{
        !Rs&Ying and throw "asYing"
        !isnode(s) and throw "!node"
        $D = Rs&Det
        $r = sy&R
        $k = ry&up == R ? "step" : "node"
        $c = {}
        c[k] = s
        return me&bracko,R,D,c
    }
    # receive what Ying wants to do
    me.Yingate_8 = &acgtRc{
        $D = delete Rs&Det
        Dc&be_time = Gtime()
        me&Dwakers,R,D,c
        me&Dtunneling,R,D
    }
  // &log -> %Outlog/$D
    # D -log
    me.log = &acgtRtqc{
        $D = me&Outlog,R,'log'
        Dc&s = t
        $sc = {}
        t and sc.says = t
        q and ex(sc,q)
        isnode(Rc&s) and sc.node ||= Rc&s
        hak(sc) and me&bracki,R,D,sc
        c and ex(D.c,c)
        return D
    }
    # accessor
    me.theOutlog = &acgtR{
        $Ying = me.cbu(R,'Ying')
        return me&rollbs,Ying,'Outlog',[]
    }
    # add a $D 
    me.Outlog = &acgtRtsc{
        $Outlog = me&theOutlog,R
        $D = Cye([t,1])
        Outlog.push(D)
        D.t += '-'+(Dc&i = Outlog.length)
        Dc&pi = t
        Dc&fe_time = Gtime()
        # knows Ying and the -gate its in
        $Ying = me.cbu(R,'Ying')
        $Det = Yings&Det
        Det and Dy&inside = Det
        Dy&Ying = Ying
        Ying != R and Dy&R = R
        return D
    }
  // &Dwakers, &wokerecently
    # detects looping wakers
    me.wokerecently = &acgtRsdq{
        $Outlog = me&theOutlog,R
        q = ex({}||q, {wake:s||1})
        return Outlog.slice((d||10) * -1)
            .filter(D => me&bracko,R,D,q )
    }
    # log wakers for the above
    me.Dwakers = &acgtRDc{
        # %%wake - for the next round
        # multiply by Ying rows wanting it
        # < vie for %terms or have to spread out processes
        # < group by %%wake in the refactored &waits_8
        #    ignore those in %%dome:later,
        #     el:9 when n input again with(out| different) %%dome
        #   then they would y&up their source
        $quiet = []
        c.wakers.map(&s{
            $l = me&jaa,R,{wants:s} .map(n => {Yingrow:n})
            !l[0] and l = [{}]
            $c = {}
            sy&quiet_wake and c.quiet = 1
            c.wake = s
            l.map(q => me&bracki,R,D,c,{},q ) 
        })
        quiet.length && c.wakers.length == quiet.length and throw "all!q"
    }
  // &Dtunneling
    # < merge in &Yingwhen, early sense e, how to %onlyish
    #  < how to gradually work when fed A leash
    me.Yingtunneling = &acgt{
    }
    # there's no way in without tunneling
    #  could be found before it happens (!tunnelout yet)
    # $e = ^^%tunneling, and maybe ey&up
    #  which would es&divawz = [e+] if tunnel diverges
    me.Dtunneling = &acgtRD{
        $poin = me.cby(R) .filter(r => rs&tunneling) .reverse()
        D ||= Cye(["Dtunneling",1])
        each ir poin {
            rs&tunneling == e and continue
            $e = rs&tunneling
            $c = {}
            # < -pi-ish on the one e, to many row per %%e
            r != R and c.r = r
            me&Delvis,R,D,e,c
        }
        # ^ climbs e:divawz, goes y&up-only to:
        # top e may /* about R
        $one
        e && ec&pack && me&ioty,e .map(&e{
            $r = ec&wake;
            r && rc&s == Rc&s and one = e
        })
        return one || e
    }
    me.Delvis = &acgtRDeq{
        $c = {e}
        q and ex(c,q)
        es&tunnelout and c.on = es&tunnelout
        # e:Qup|elQups update generally or:
        #  e/*.c ={ wake=aJRom, Intere=Qupe.c{Q,R=G&t-er} }
        each iQ ec&Qz {
            me&bracki,R,D,{Q}
        }
        me&bracki,R,D,c
    }
    
    },



// Travelty
    ['Travels',0.39,&acgtRs{
        # < wants to cautiously inode while adhere-ing,
        #   to see if we set up:
        Rs&twmt_only = &jz{
            return zs&W || 1
        };
        me&ha,R,"Travels,to:Morrocco";
    },'ift,D'],
    
    ['Travelty',0.298,&acgtRs{
        me&bin,'Traveltoid'
    },'ift,D'],
    # %%Go -> %play, without sticking in %Te
    #  for Peace 291 to personify
    ['Traveltoid',0.29,&acgtRs{
        me&inode,R
        me&ha,R,"Hazid"
        me&ja,R,'Go' and Rs&play = 1
    },'ift,D'],
        
    ['Travelty',0.39,&acgtRs{
        $x = me&Jx,R
        me&ha,R,"Travels,to:everywhere",{R};
        #!me&za,R,'fodder' ? me&ha,R,'fodder,lamp' : me&ha,R,'lamp'
        
        me&ha,R,"Travels,to:everywhere",{R};
        $le = me&zaa,R,"Travels",'to';
        
        # sends %pat as %%pat
        $pat = ss&pat ||= 'ology';
        me&nodei,R,xs&Duolish,{pat};
        me&nodei,R,xs&Duolish,{pat:'ex'};
        # returns %%raga
        me&jaa,R,{efrom:xs&Duolish,raga:1} .map(&n{
            le.push(ns&raga)
        })
        
        # sends
        me&ioty,s .map(z => me&nodei,R,z,{terspesia:"^"} )
        me&nodei,R,xs&Ligno,{terspesia:"^"}
        
        each in le {
            n = me&tsc,"land",n,'G';
            ns&dis = 1;
            ns&fs = 33;
            
            ns&hue = i*40;
            ns&blr = 9;
        }
    },'ift,D'],
    # finished Travels commit
    ['Duolish',0.303,&acgtRs{
        # unrelated
        me&jaa,R,"efrom,pat" .map(&n{
            $q = {};
            q.raga = ns&pat.split('').join('_');
            me&nodei,R,ns&efrom,q
        })
        # Travel/* forwards finisheds it to worriment device
        me&jaa,R,"e" .map(&n{
            $e = ns&e;
            $f = ns&efrom;
            $S = fy&path[0];
            ey&participant = Sy&p
            me&bal,"Re:"+e.t,e,'Releasor,MayGhost,eph'
        })
    },'ift,D'],



// Story ext
    
    
 // %Nodar views
  // doc
        =experiencing a:
        
        self,other are building,styling modes
        
        self nodes -> O <- meddling other
        
        many users other(&{...}) to iter O**
         may slep|steer around iteration semi-auto
          may only visit the top few C
         or
         may be from nodes iterating that we other
          each knowing the O it is
          < gonerism for partly awake O/*, what they emit
            when are things el:9|sleeping
            weird area. see Rc&X + %eph
         what they emit, as users, for O etc,
          may bring other users around,
           eg self must instantiate an O others want to be
          may be streaming somewhere
           eg brack rows upwards
           to fill indexes (merge branches), think on O
           similar to the slep landscape joinup and %%eto:1 hoisting
           getting extra %%O as the row leaves
        
        anyway,
        here, self visits Ying/*/* into O=Rc&s,
         which starts R/**%Nodaring we can tunnel/sleep
         as a kind of R%Nodar self tour
          usu there is a similar canonical other tour
          eg %Abodis others regularly to keep watch for ~self,
           as well as apply styles
         re-visiting parts of the self is elvised|tunneled from users:
        
        other
         visits anything as anything else,
          supposing self is complete (eg Display attached)
          so we can work some other process into it:
         knowing the self + others at O,
          a chance to slep and elvis any of them
          eg new/gone/diff 4/* can be noticed by any othering near it
         other may:
          bring inputs to slep themselves (see -balcurve)
          find selfs that should be because $s..$z
           stretching self beyond its starting shape,
            may have dim O between $s..$z, if never iterated (!node)
          include etc in the R:Nodar self tour
          
         self gc:
           when self wants to O/-O,
            other the effect of being gently phased out first
           %eph may $s/!$z, need to look in sy&R X-path to gc
         
         eg
           a node happening, wanting sy&Org
           making its language there happen
           eg blinking lights, looking %ope, incrementing time
         eg
           to express another thing through it
           showing several -seven in -balcurve/-seven/-n
            would be given to Nodar by the %Plot
            -n+ each knowing an O to style
           specifics|activity amplified across a bell curve,
            the intensity smoothly fading
            so the middle seems to burn open
           -balcurve would slep, like another self
            who in turn is othering its parameters
             which may self from some html controls
             and how they might interslep
            depending on the -balcurve resolving via other,
             may need different attention
              depending on its futurism
              eg being a %J native to another %J
             winding Y:pi cv-ov gaps should do (when !%J)
         
         so,
         may elvis for selfing if slep clued from other
         may stretch self further than Ying/*/* if pushed in
         R/**%Nodaring, we can tunnel/sleep
            whose selfs would hang around,
            able to style just by othering:
        sleping:
         either mode can notice change in things
         when near something else that is iterating
        
        so,
        < &ind moves in via &ind_twz
         < can slep last self as other with that,
          < or more if configured on Y:Dome
          
        =cut
   
  // selfs
    ['Nodar',0.299,&acgtRs{
        me&reaw,R,'Nodar'
        $x = me&Jx,R
        # these, we can tunnel/sleep
        Rs&Nodaring = 1;
        Rs&nofurtherDisplay = 1
        
        # < cloning spacers: i $s y- o xs&Ying/#*/#*
        # giving O=s makes this %ball the other
        $c = {beyond:0,within:3}
        $Org = me&indot,xs&Ying,s,c;
        
        # < ingoing refs -> X**,
        #   merges awake|not O.X
        $X = sy&X = {}
        # climbing
        # < Stepy&N having possibly connected things
        Rs&selfs = Org.self(&rOd{
            ~>4 selfs: d.ind, r.t, O.t
            me&X_t,X,r.t,O
            me&X_s,X,r,O
            Os&dopth = d.d;
            Os&coun ||= 0
            Os&coun ++
            return O
        });
        
        s&hue = 66;
        ss&couni ||= 0
        ss&couni ++
        each in ss&z {
            #me&bal,'n:'+i,n,'Yingate,eph,tightly'
            #$r = me&Ret,R,{t:"n:"+i,s:n,Yingate:1}
        }
    },'ift,D'],
  
  // others
  
   // to nodepile%ball
    ['Nodaring',0.299,&acgtRs{
        ah(R,'inheritscif','ball','Nodaring',2)
        Rs&Nodaring < 2 and return
        #me&tsc,"Nod",'','y'
        
        if (s.t == 'Ligno') {
            Rc&b && !Rs&tunneling and return Rs&sleeping = 1
        }
        
        (Rs&boost||0) < 1 and return
        me&nu,s
    },'ift,D'],
    
   // nodepile given -seven+
 
 // signals
  // %Teoptic - customise -eight etc
    # see configure to Te/togcon/$p-ology/$n
    # < -group* like io.ind, columns from $p.split(/\b/)
    #   these things split by -0
    # < of hoisting parts upward:
    #   to configure a view to carry onward,
    #   then unset after a while?
    #   it is &t wanting to know where $Q is
    #    in frozen time, in the case of This/*
    
    
    
    
    
    
    
    
    
    
    
    
    ['Teoptic',0.88,&acgtRs{
        me&reaw,R,'Teoptic'
        !Rs&sleeping and me&nu,"Te",Rs&Te
    },'ift,D,sleeping'],
  
  # L (visits|stays) (Plot|eight)y&Point
  # L%Nine <- %%Having,eight+
  // Plot%%Nine<->L%Nine init
    # Plot wants %%Nine to give to L
    # < de-mysteriate beginning (Ying in %SummerCat?)
    ['The',0.46,&acgtRs{
        $x = me&Jx,R
        $Plot = xs&Plot
        me&za,Plot,'Nine' ||
            # keep trying The..Nine
            me&wants,R,'Theing',ss&z[0]
    },'ift,D'],
    
    # Nine -> Plot%%Nine
    ['TheNine',0.44,&acgtRs{
        $x = me&Jx,R
        $Plot = xs&Plot
        me&nodei,R,Plot,{Nine:s}
    },'ift,D'],
    
    # Plot%%Nine just to bind the first L%Nine
    #  thence inherited, until a different Stori
    ['Plot',0.36,&acgtRs{
        $L = sy&Point
        if (L && !Ls&Nine) {
            Ly&l and throw "nonfirstL!%Nine"
            $Nine = me&ja,R,'Nine',0
            Nine and Ls&Nine = Nine
            # now L can async enough to:
            #  This/eight find L, send Nine, send %%Having,eight
            #  later L inherit oL%Nine, if not new Stori
        }
    },'ift,D'],
  
  // L%Nine <- %%Having,eight,L     &L_Streaming
    &{
    # L finds its This/eight +y&Point=L
    # any time we can read Stream[Page_in..out]
    me.L_Streaming = &acgtRLD{
        !Ly&initialis and debugger
        $N = Ds&z.slice(Lc&Page_in-1,Lc&Page_out)
        $was = Ls&Dome
        if (was) {
            heq(was,N) and return
            hak(N) < hak(was) and Ls&Domeshrinks = 1
            N[0] != was[0] and Ls&Domestart = 'diff'
            N[hak(was)-1] != was[hak(was)-1] and Ls&Domeend = 'diff'
        }
        Ls&Dome = N
        # claim each This/$eight for L
        each in N {
            $was = ny&Point
            was && was != L and debugger
            ny&Point = L
        }
    }
    },
    # L%Nine <- %%Having,eight(y&Point=$L)
    # < an &Accepting mode for these three,
    #   controlling and resulting some A
    ['theThis',0.297,&acgtRs{
        $D = Rs&Storystream
        $lastPoint = 0
        $last = Ds&z.length-1
        each in Ds&z {
            if (i == last) {
                !hak( me&ioty,n ) and continue
            }
            $q = {Having:1,eight:n}
            $L = ny&Point
            # may be before OPoint (L_Streaming finds n)
            #  or after the last L has Page_out
            !L and q.wander = lastPoint ? "off" : "in"
            L ||= lastPoint
            !L and break
            lastPoint = L
            
            # may be before Plot%%Nine -> first Ls&Nine
            !Ls&Nine and break
            q.L = L
            me&nodei,R,Ls&Nine,q
        }
    },'ift,D'],
  
  // The<->Plot %%Checkable    &Plot_Pageturn_Checkable
    &{
    # Plot%%Checkable,L <- This/* subset L%Dome completed !
    # as r:This othering a Page++!
    # < merge all Page_*... %Domes = D/*:eight{where},
    #   tell from eight if it's still streaming?
    #   or wait til there's a Page after it, as in:
    me.Plot_Pageturn_Checkable = &acgtRsrD{
        $dome = {dome:'pageturn'}
        $Plot = R
        # go through L+ considering new %Page
        each iL ss&z {
            # < Plot/L could exist before init
            !Ly&initialis and debugger
            # ignore Fuguery except L%Fugued itself
            Ls&Fugue || Ls&Fuguing and continue
            
            !Lc&Page_in || !Lc&Page_out and throw "L!&OPoint"
            $q = {Checkable:1,L}
            if (!Ls&ok && !me&ja,r,q) {
                ss&Page >= Lc&Page_in and me&L_Streaming,r,L,D
                ss&Page <= Lc&Page_out and break
                # L's pages now complete
                me&log,R,'Checkable',{L,Page_out:Lc&Page_out}
                ~>5 +Checkable: L.t
            }
            # %%Checkable -> Plot->/Point -> Nine
            # < ideally %%eto=L will work already
            if (me&jaa,r,ex(q,dome) .length > 1 ) {
                ~>5 multi This Checkable: L.t
                debugger
                continue
            }
            me&nodei,r,Plot,q,dome
        }
        
        # also through D/* considering y&Point=L or not
        # < twlic mode for this
        $D = rs&Storystream
        !D and throw "Storystream"
        $Lless = []
        #!G.afll and debugger
        me&ioty,D .map(&n{
            !ny&R and return
            $L = ny&Point
            !L and Lless.push(n)
            else {
                Lless.length and ~>4 LlessIgnored: joint(Lless), L.t
                Ls&ignore and me&nodei,r,n,{Ignored:Ls&ignore},dome
                Lless.map(n => me&nodei,r,n,'Ignored',dome )
                Lless = []
            }
        })
        
        # < allow it to empty?
        me&dome_traction,r,dome.dome,{el:2}
    }
    },
    # Plot %%Checkable,L -> /Point:L
    #  via here to ensure selfed before eto:L
    # < forwarding %%L here to /L can be faster if selfed?
    ['Plot',0.36,&acgtRs{
        me&jaa,R,'L,efrom'
            .map(n => me&nodei,R,ns&L,n )
    },'ift,D'],
    
    # L %%Checkable,L -> L%Nine
    #  when L%Dome completed
    ['Point',0.38,&acgtRs{
        $L = s
        # Point gets %%Checkable 
        $Ch = me&jaa,R,'Checkable,L,efrom'
            .filter(n=>!ns&Eigh)
        hak(Ch) > 1 and debugger
        Ch.map(&n{
            ns&L != L and throw "Confus"
            !Ls&Nine and return me&wants,R,"getNine"
            
            me&Point_nonCheckable,R,L,n and return
            
            me&nodei,R,Ls&Nine,n
        })
    },'ift,D'],
  
  // Nine<->Eigh->eight %%Checkable
    &{
    # < detecting limbs of %%Checkable pipe with eg %%expect
    # < retracting %%Checkable (from L?)
    #   fading out Eigh|-eight
    
    # < qualities on a jaa and what it wants todo
    # for %%Checkable,L +Eigh, +eight, +ready,ok
    #  pick which stage|form of this message to read
    #  tally them, etc
    me.brackstream = &acgtRs{
    }
    },
    # L%Nine %%Checkable,L -> /Eigh
    #  each L%Dome.$eight have become Eigh%got,
    #   so eighty&Eigh and Eighy&eight
    ['TheNine',0.45,&acgtRs{
        # upto is a length
        $x = me&Jx,R;
        # all results here
        me&jaa,R,'Checkable,L' .map(&n{
            # the ones arriving, not leaving
            !ns&efrom and debugger; return
            # not from /Eigh, sends vitals to keep Nine aware
            ns&Eigh and return
            # < ^ forward them once all Eigh%%ready
            #   should mirror the eight<->Eigh got via L%Dome:
            
            # L has Eigh+ to get to
            $L = ns&L
            !hak(Ls&Dome) and debugger
            $ready = 1
            $ok = 1
            $Eighed = Ls&Dome.map(&eight,{
                $Eigh = eighty&Eigh
                r = Eigh && Eighy&R
                !r and return ready=ok=0
                !me&za,r,'ready' and ready = 0
                !me&za,r,'ok' and ok = 0
                return Eigh
            }).filter(s=>s)
            !hak(Eighed) and return me&log,R,'NineCheckable-noDomes',{L}
            
            # %%Checkable -> Eigh
            # < include %%Eigh already?
            Eighed.map(&Eigh,{
                !Eigh and debugger
                me&nodei,R,Eigh,n
            })
            
            # all Eigh%%ready
            !ready and return
            
            # L <- %%Checkable,...,ready,ok <- Eigh
            # < return it from -eight instead of %Fin?
            me&jaa,R,{L,Checkable:1,Eigh:1,eight:1} .map(&n{
                me&nodei,R,L,n
            })
        })
    },'ift,D'],
    # Eigh %%Checkable,+expect=Nine/$t -> This/$eight
    #  $eight Yingates+Fin:
    #   half happens without it,
    #   -> Eigh%%Fin:$eight,dige checks it ...
    &{
    me.neaz = &acgtsy{
        $p = sy&up
        $z = ps&z
        $si = z.indexOf(s)
        si < 0 and throw "!neaz"
        if (num(y)) {
            return z[si+y]
        } 
        else {
            throw "either direction until y()?"
        }
    }
    },
    ['TheEigh',0.35,&acgtRs{
        
        $x = me&Jx,R
        $Nine = Ry&up.c.s
        $t = Rs&exp
        $eight = Rs&got
        !eight and return
        # each L%Dome.$eight have become Eigh%got,
        #  so eighty&Eigh and Eighy&eight
        # eight:z now knows Eigh
        eighty&Eigh = s
        sy&eight = eight
        $L = sy&Point = eighty&Point
        
        me&Eigh_nonCheckable,R,L and return
        
        $r = eighty&R
        $Ch = me&jaa,R,'Checkable,efrom'
        hak(grepout(Ch,n => ns&Eigh)) and debugger
        hak(Ch) > 1 and debugger
        
        # can be manually
        !hak(Ch) && x.ro("check",{}) and Ch[0] = 'Checkable'
        if (!L) {
            $l = me&neaz,R,-1
            l and l = lc&s
            $oL = l && ly&Point
            if (oL) {
                # previous one was found
                # < type in t%L=L.t
                #    or 
                if (x.ro("+")) {
                    me&fiu,Nine,[s.t,1,{},{L:'further'}]
                }
                # < or stretch l%Pages
            }
        }
        # disregard actual
        
        Ch.map(n => me&nodei,R,eight,n,{},{expect:t} )
    },'ift,D'],
    # Eigh%%ready -> Nine
    ['TheEigh',0.37,&acgtRs{
        $x = me&Jx,R;
        # then once got storable (via &acceptable)
        # ! Eigh wants:gotready is very important...
        #   stops Nine pushing while we are pushing to it
        #   at some critical moment?
        me&da,R,'ready'
            && me&wants,R,'gotready',Ry&up.c.s
        # %%Checkable...+Eigh,eight,ready,ok back to Nine
        #  once all %%ready then they pipe all %%ok over to %%L
        me&jaa,R,{Checkable:1,eto:s} .map(&n{
            $q = {}
            # add on:
            q.Eigh = s
            q.eight = sy&eight
            q.ready = me&ja,R,'ready',0
            q.ok = me&ja,R,'ok',0 
            me&nodei,R,ns&efrom,n,{},q
        })
    },'ift,D'],
  
  // about Qup
    &{
    # log but dont e:elQups
    me.YingelQup_2 = &acgtR{
        4s&noQup = &e{
            ~>4 ige: e.t
        }
        4s&noelQups = &e{
             $D = me&log,R,'no-e:'+e.t
             me&Delvis,R,D,e
        }
    }
    # catch e that wake:Ying
    me.Yingwhen_e = &acgtRe{
         if (e.t == 'elQups') {
             $D = me&log,R,'e:elQups',{e}
             me&Dtunneling,R,D
             debugger;
             return 1
         }
    }
    me.PaveelQup_5 = &acgtRs{
        $Q = Rs&Q
        $was = me&jaa,R,'isready',1 [0]
        $also = me&ja,R,'isready',0
        also != was and throw "wasi"
        $is = Qs&ready ? 1 : 0
        !(was == null || was != is) and return
        me&ha,R,{isready:is,dome:'isready'}
        me&log,R,'Q~'+is,{Q,node:s}
    }
    },
    ['noGump+Paving',0.55,&acgtRs{
        me&PaveelQup_5,R,s
    },'ift,D'],
 
 // Plot/Point tie most thing together
    ['Plot',0.298,&acgtRs{
        
        # < TEST see &OPoint Plot 298 init too early
        #me&bewind,R,Ry&up.sc.z and return
        # < all this in one:
        me&reaw,R,'Plot'
        $S = me&inode,R
        $go = me&acting,R,'Plot'
        ah(R,'inheritscif','ball','Point',1)
        
        # for This
        me&Plot_Pageness,R,s
        
        # init something to do
        !hak(ss&z) && me&Plot_Default,R,s
    },'ift,D'],
    
    # This %%Checkable,L -> Plot/Point:L 
    # comes here to say:
    #  ok:
    #    then do some act with-into the next plot point
    #  not:
    #    become Story/** hacking session, resume?
    ['Point',0.34,&acgtRL{
        me&reaw,R,'Point'
        me&inode,R
        Ls&ok && me&sleepic,R and return
        me&OPoint,R,L
    },'ift,D'],
    ['Point',0.37,&acgtRL{
        $go = me&acting,R,'Point'
        # L%ok from  %%Checkable,Eigh
        $Eighs = me&Point_Eighs,R,L
        Ls&ok and s&bgh = '041'
        # act onwards
        Eighs and me&Point_then,R,L
        # L%* shown
        me&Point_ology,R,L
    },'ift,D'],
    
    ['Plot',0.38,&acgtRL{
        # and finally
        !Ls&alldone and return
        me&ha,R,'alldone'
        me&da,R,'alldone' and me&log,R,'Plot-Done'
        me&tsc,"Done",0,'G'
    },'ift,D'],
 
 &{
 // Plot gen Point
    # R%Point is the last of something,
    # < see Around-ness (time collection)
    # < trace back to -Will
    me.Point_alldone = &acgtRL{
        if (0) {
            # or keep going...
            #con("Wander",1,{Pages:99,trail:3})
            me&log,R,"Wanderoff"
        }
        $x = me&Jx,R
        $Plot = xs&Plot
        $This = xc&This
        Plots&alldone = 1
        me&wants,R,"alldone",Plot
        me&log,R,'allDone'
        if (L) {
            me&nodei,R,Ls&Nine,'alldone',{dome:'forever'}
        }
        delete Ploty&Point
        Thiss&pause = 1
    }
    =pod
     make L of Nine/$t
        mostly by $t%L=L.t
      
      carryon%enNine=1|Nino.t - loads, runs a Nine
      -Will has the list of Nines you want:
       =1 pulls one from that list
        eg did Nine to get ready for Nino
       =W.t pushes this particular one
      
      Nino may return to more Nine, via -Will
      
    =cut
    # parse Nine:s/$t+ into L+
    me.Plot_PointoNine = &acgts,oL{
        $x = me&Jx,R
        $The = xs&The
        $getNine = &t{
            $Nine = me&fiu,The,t,7
            # Test/Nine
            Nine = Niney&Nine
            !Nine and debugger
            return Nine
        }
        $Plot = xs&Plot
        $Story = xs&Story
        # n = t,c,sc
        $N = []
        $req_L_sc = peel('enNine,Go,check,ignore')
        me&ioty,s .map(&ti{
            ts&L and $L = Cye([ts&L,1])
            i == 0 && !L and throw "first t not %L"
            each kv t.sc {
                req_L_sc[k] && !L and throw "must be with %L: "+k
            }
            # Eigh in last L
            !L and return
            
            # Eigh that starts a new L
            if (!oL && i == 0 && ts&Go) {
                # L%Go first, preceed with a startup ignorer
                #  will be ranged for beginning,startStory
                N.push(Cye(['startStory',1,{check:0}]))
                # will then have a page of mumbling,
                #  up to the 'Going'-log
                $sudden_Go = 1
            }
            N.push(L)
            # %check defor 1, can be 2 to check checking
            ts&check and Lc&check = ts&check
            ts&ignore and Lc&check = 0
            # another Stori->Nine
            $en = ts&enNine
            if (en) {
                en == 1 and en = Thes&about[1]
                # start The/Test looking for that Nine (to Stories/$Test)
                Lc&init = &LR{
                    me&log,R,L.t+'-init'
                    me&nodei,R,The,{Nine:en},{dome:'forNine'}
                }
                Lc&able = &LR{
                    $Nine = getNine(en)
                    Lc&nextc = {Nine}
                    Lc&intoaNine = Nine
                }
            }
            if (oL && oLc&intoaNine && i == 0) {
                # oL is &then()..consum()..here
                $also_init = &LR{
                    Ls&Nine != oLc&intoaNine and debugger
                    Ls&Nine != s and debugger
                }
            }
            $Go = ts&Go
            if (Go) {
                Go == 1 and Go = s.t
                Lc&init = &LR{
                    $Tra = xs&Travel
                    # by now, stuff (Story...Point++...)
                    if (sudden_Go) {
                        # kept in le-3, shut, ignored
                        Ploty&namePages = Ls&Nine
                        me&Pageturn_suddenly,R
                    }
                    else {
                        # could be swept into the last Page?
                        #me&Pageturn_pretendnow,R
                    }
                    me&log,R,'Going',{Go}
                    # < Travel%%Go=$Go -> Travel/$Go
                    $Eas = me&fiu,Tra,Go,7
                    me&nodei,R,Eas,'Go',{dome:'forGo'}
                }
            }

            # < L.c.* merging as an ah() field (Index)
            if (also_init) {
                $was_init = delete Lc&init
                Lc&init = &LR{
                    also_init(L,R)
                    was_init and was_init(L,R)
                }
            }
        })
        return N
    }
    me.Plot_Default = &acgtRs{
        # < based on Stori/* rhythms
        # < 300ms impatience for getting somewhere
        # < get Gump, protoJ for Ying
        
        # an L is always followed by L%checking
        #  generated in &able
        $x = me&Jx,R
        $The = xs&The
        $Plot = xs&Plot
        $Story = xs&Story
        $This = xc&This
        $D = Thiss&Storystream
        # Plot 298 init too early yet appears this time
        !D && !Rc&b && Rs&Plot and return me&waits,"enPlot"
        
        # The%about=[start.t,etc.t]:
        #  etc pulled by start's L:carryon%enNine=1|etc
        $start = me&ioty,The [0]
        start = starty&Nine
        start.t != Thes&about[0] and throw "start not"
        !me&ioty,start .length and throw "start/!*"
        
        # Nine/* should have %L=L.t etc
        $N = Ploty&incoming = me&Plot_PointoNine,start
        #N = [N[0]]
        me&Plot_incoming,R
    }
    # starts|continues generating L
    me.Plot_incoming = &acgtRq,oL{
        $x = me&Jx,R
        $Plot = xs&Plot
        $N = Ploty&incoming
        
        if (oL) {
            # connected to the last Point
            if (oLc&intoaNine) {
                # load Points from the Nine
                #  any N[Point+] potential now happen after it
                N.unshift(... me&Plot_PointoNine,oLc&intoaNine,oL )
            }
        }
        $n = N.shift()
        !n and return me&Point_alldone,R
        
        q and ex(n.c,q)
        $L = me&OPoint,R,[n.t,'-Point',n.c,n.sc]
        
        me&Point_addcheck,R,L
        
        return L
    }
    # L:oL gets subsequent L%checking,
    #  moves oL&able,&then to L
    me.Point_addcheck = &acgtRL{
        $x = me&Jx,R
        $Plot = xs&Plot
        $This = xc&This
        
        $able = Lc&able
        $checks = defor(Lc&check,1)
        Lc&able = &LR{
            # once L%%Checkable, in|for Page=3
            me&log,R,L.t+'-able'
            able and able(L,R)

            if (!checks) {
                Ls&ignore ||= 'nocheck'
                return
            }

            # fire continuation after checking
            $then = delete Lc&then
            $check = me&OPoint,R,['ok:'+L.t,'-Point',{},{checking:L}]
            if (checks == 2) {
                $thenafter = then
                then = &L,R,nothing{
                    # usually nothing
                    !Ls&resumed and return
                    # once L%Fuguing, never %%Checkable
                    #  so may never call &able
                    # keep on after the ok:ok:L.t
                    me&log,R,L.t+'-then%resumed'
                    # from the perspective of L%Fugue, accept:L.t
                    #  instead of the ok:ok:L.t 
                    $Fuguing = Ls&Fuguing
                    !Fuguing and debugger
                    debugger
                    # < the L:carryon nodei doesn't get it ready
                    #   by the time it becomes %%Checkable...
                    thenafter(Fuguing,R)
                }
                checkc&able = &L,R,thenvia{
                    Ls&resumed and debugger
                    me&log,R,L.t+'-able'
                    $ch = me&OPoint,R,['ok:'+L.t,'-Point',{},{checking:L}]
                    chc&then = thenafter
                }
            }
            checkc&then = then
        }
        $then = Lc&then
        $oL = L;
        # this &then may be moved onto L%checking
        Lc&then = &LRq{
            # when we realise L&then
            # we are in a small page between Ls

            # rename|number between Nine
            # eg &able is moved to L:(ok:)+carryon
            $re = oLc&intoaNine
            re and Ploty&namePages = re

            Ly&atPage = &R{
                # now the next page|L starts
                #  with no mention of the previous L
                $q = {Page_in:Plots&Page}
                oLc&nextc and ex(q,oLc&nextc)
                $uL = me&Plot_incoming,R,q,oL
                # < why without this, L:carryon has !Niney&Nine 
                me&wants,R,'Lup',Plot

                then and then(L,R)
            }
            Ls&ignore and Ly&atPage(R); delete Ly&atPage

            This = me&yfuture,This
            $la = me&ioty,This,'Yingates' .slice(-1)[0]
            # previous L wants that small page ignored
            #  we may be L%checking by now (&then may be moved)
            $Ignorable = 'pagebetween'
            me&nodei,R,la,{Ignorable},{dome:Ignorable}
        }
        return L
    }
    
    
 // Plot about Pages
    # This uses Ploty&Pageturnable, etc
    me.Plot_Pageness = &acgtRs{
        $x = me&Jx,R
        $This = xs&This
        # sense wanting quiet,wake
        # < to asap an L finishing
        sy&Pageturnable = &acgtr{
            #  may be Ying     ^
            # when Story/* is blank:
            !This and return
            $r = Thisy&R
            rs&pause and return 0
            $L = sy&Point
            # before Page++
            $i = ss&Page + 1
            $is = L && i && Lc&Page_out < i
            !is and return 0
            if (Ly&R && me&ja,Ly&R,'Checkable,L' ) {
                ~>5 still Pageturnable: L.t, Lc&Page_out, '<', i
                return 0
            }
            me&log,r,'Pageturnable',{Page:ss&Page,next:i,L,Page_out:Lc&Page_out}
            ~>5 is Pageturnable: L.t, Lc&Page_out, '<', i
            return 1
        }
        # title the next page
        # < name after Lf
        sy&Pageturning = &acgtrD{
            $i = Ds&z.length
            ss&Page ||= i
            ss&Page != i and ss&wanderi = ss&Page+'Page!='+i+'Stream'
            $name = 'le'
            $i = ++ss&Page
            $Nine = sy&namePages
            if (Nine) {
                # re-name|number subtests
                # < there would be a leading L
                #   more ideal place to coord this
                #   is not entered yet. allow before &init
                #    and naming them 00-name|desc
                name = Nine.t
                Niney&Pageturns ||= 0
                i = ++Niney&Pageturns
            }
            return name+'-'+i
        }
        # r:This has turned page from D:Stream/-2 to -1
        sy&Pageturn = &acgtrD{
            rc&s != xs&This and debugger
            me&Plot_Pageturn,R,s,r,D
        }
    }
    # This othering a Page++ (async)
    me.Plot_Pageturn = &acgtRsrD{
        $Plot = R
        $L = sy&Point
        # has incremented:
        $i = ss&Page
        me&log,r,'Pageturn',{i,L}
        if (!L) {
            # no Point until Story** on this page
            i != 2 && i < 6 and debugger
            return
        }

        # spring act, may &iPoint
        Ly&atPage and Ly&atPage(r,i); delete Ly&atPage
        
        me&Plot_Pageturn_Checkable,R,s,r,D
    }
    # R:Point demanding a new page, without %%quiet
    #  or the above &Plot_Pageturn responding to it (no &atPage)
    me.Pageturn_suddenly = &acgtR{
        $x = me&Jx,R
        $This = xs&This
        me&log,R,"Pageturn_suddenly"
        $D = me&yyt,This,'Pageturn'
        !D and throw "This!&Pageturn"
        $Plot = xs&Plot
        $L = Ploty&Point
        Lc&Page_in += 1
        Lc&Page_out += 1
    }
    # GONER R:Point demanding a clear page
    #  Page's stuff so far swept back onto lastPage
    # < may naff out Y:Dome
    #    eg drop empty: lastPage will already be gone
    # < slep D/*/*?
    me.Pageturn_pretendnow = &acgtR{
        debugger
        $x = me&Jx,R
        $This = xs&This
        $D = Thisy&Storystream
        $Page = Ds&z.slice(-1)[0]
        $lastPage = Ds&z.slice(-2)[0]
        # these are not input, mere ac z
        lastPages&z.push(... Pages&z)
        Pages&z = []
    }
 
 // Point
    # creation of $L=Plot/Point**
    #  may be This othering via &Pageturn handlers
    # < may be Plotted in advance, de-%eph now
    # < lowL between Ls, until quiet, to check l%ok
    #   allowing pages for acts, pages for checking
    #   < if not two async Yings
    # either causing immediate:
    #  Ploty&Point = L, having:
    #   Lc&Page_out for &Pageturn to complete it
    me.OPoint = &acgtRL{
        $x = me&Jx,R
        $Plot = xs&Plot
        $This = xc&This
        $D = Thiss&Storystream
        # Plot 298 init too early yet appears this time
        !D && !Rc&b && Rs&Plot and debugger
        !Plots&Page and throw "!Page"
        !D and throw "!D"
        
        # creation
        isar(L) and L = me&fiu,Plot,L,2
        !Plots&z.includes(L) and throw "!Plot/L"
        !Ly&R and me&wants,R,'Linit',Plot
        
        me.neigh(L,&lr{ Ly&l = l; Ly&r = r })
        $l = Ly&l
        if (l) {
            # later not created before this solves
            # < unless lowL, handling accepting
            #!ls&ok and return L
        }
        # L init: binds to Pages
        if (!Ly&initialis) {
            # inherit %Nine
            Lc&Nine and Ls&Nine = delete Lc&Nine
            l and Ls&Nine ||= ls&Nine
            l && !Ls&Nine and throw "L2!Nine"
            
            Ly&initialis = 1
            Lc&init and me&wants,R,"L-init",Plot
            
            # usu after the last L's Pages
            Lc&Page_in ||= l && lc&Page_out+1 || 1
            # usu Point%ok at the end of this Page
            Lc&Page_out ||= Plots&Page + (Lc&Pages||1) -1
            !Lc&Page_in and debugger
            !Lc&Page_out and debugger
            
            # for another L
            $oL = Ls&checking
            if (oL) {
                oLs&checked && oLs&checked != L and debugger
                !Plots&z.includes(oL) and debugger
                oLs&checked = L
            }
            
            # silently become Ploty&Point
            me&log,R,'Point++',{oL:Ploty&Point,L}
            Ploty&Point = L
            
        }
        
        # any time we can read Stream[Page_in..out]
        me&L_Streaming,R,L,D
        
        return L
    }
  // Point@37: L&init(), L&able(), L%ok <- Eigh-tally
    # R:Point 3ing, %%Checkable|L%resumed get L%ok
    #  returns true when ready to act on the state of L%ok (null until)
    me.Point_Eighs = &acgtRL{
        # asap, once
        me&ccb,L,'init',1,L,R
        # %%Checkable has two layers:
        # checking begins, going to - able to be checked
        me&da,R,'Checkable,L' and me&ccb,L,'able',2,L,R
        
        # checking completes, with each Nine/Eigh
        $Eighed = me&jaa,R,'Checkable,L,Eigh,efrom'
        
        # L%resumed acquired on commit of L/* in ReNine+unity
        #  are L%ok based on no !ok in empty Eighed
        Ls&resumed and me&Point_resumed,R,L; Eighed = []
        else
        !hak(Eighed) and return
        
        # L receives %%Eigh%%ready,ok?
        $ok = !hak(Eighed.filter(n => !ns&ok)) ? 1 : 0
        Rs&before = Ls&ok != null
        Rs&wasok = Ls&ok
        Ls&ok = ok
        !ok && Rs&wasok and Ls&became_notok = 1
        
        return Eighed
    }
  
  // Point%resumed to continue anyway
    # when R:ReNine+unity pushes (Eigh related to) L
    me.ReNine_pushed_Point = &acgtRL{
        !Ls&resumed and me&wants,R,"L-resumed",L
        Ls&resumed = 'ReNine'
        me&nodei,R,L,{Push:'resumed'},{dome:'resumed'}
    }
    # < &Pointness these two could be
    #   says each thing once - domes it into -Point
    #    links to other entanglements of
    #    notices if it changes across b-Rin-R7-R8:b
    #   knows where can do what
    #    wires in the y&Eigh|eight for Eigh@35
    #   our L%checking is waited for: R%nonCheckable
    #    or going weird: R%Fuguing
    #   &Effect collaboration
    # Point@38 may stop n%%Checkable signal getting to Nine
    me.Point_nonCheckable = &acgtRLn{
        if (Ls&ignore) {
            me&log,R,"%ignore-passed",{L}
            !Ls&resumed and me&waits,'ignored'
            # becomes L%ok:
            Ls&resumed = 'ignore'
            return 1
        }
        
        $ch = Ls&checking
        if (ch) {
            # this L%checking=lL%checked=L (lL,L)
            # not yet
            chs&ok == null and return me&tsc,"check..",0,'g'
            # not ok
            !chs&ok and return me&tsc,"Fuguing",0,'g'
            # without L%checked=rL%checking=L (L,rL)
            if (!Ls&checked) {
                !Ls&resumed and me&waits,'acheck'
                # becomes L%ok:
                Ls&resumed = 'acheck'
                me&ha,R,{Checkable:'acheck',L}
                return me&tsc,"acheck",0,'g'
            }
        }
    }
    # Eigh@35 may stop n%%Checkable signal getting to $eight
    me.Eigh_nonCheckable = &acgtRLn{
        !L and return
        Ls&ignore and return me&tsc,"Ignore",0,'g'
        
        $ch = Ls&checking
        if (ch) {
            !chs&ok and return me&tsc,"Fuguing",0,'g'
        }
    }
    # how L%Fugu(ed|ing)%resumed may recover (act onward anyway)
    me.Point_resumed = &acgtRL{
        $x = me&Jx,R
        $Plot = xs&Plot
        $This = xc&This
        # always has a later L%Fugue
        $Fugue = Ls&Fugued
        # may have an L%checking in between
        $ker = me&ioty,Plot .filter(ker => kers&checking == L) [0]
        if (Fugue && Fuguec&Page_out == 99) {
            # un-sinkhole -Fugue
            Fuguec&Page_out = Plots&Page
            Fugues&resumed = 1
            Thiss&pause = 0
            me&wants,R,'L-de-Fugue',Fugue
            if (ker) {
                # the L%checking may now &then
                kers&resumed = 1
                me&wants,R,'L-de-Fugued',ker
            }
        }
    }
  
  // Point@37: L%ok -> L&then(), acts onwards
    # if &Point_Eighs
    me.Point_then = &acgtRL{
        $x = me&Jx,R
        $Plot = xs&Plot
        $This = xc&This
        if (Lc&pi == 'Point') {
            if (Ls&ok && !Rs&wasok) {
                Rs&before and Ls&became_ok = 1
                # act onwards
                $say = Lc&then ? "..." : "!"
                me&log,R,"L-ok"+say,{L}
                
                $ch = Ls&checked
                # unblocks Point@38: %%Checkable L%checking
                ch and me&wants,R,'L-checked',Plot
                
                $oL = Ly&r
                #oL and me&OPoint,R,oL
                me&ccb,L,'then',2,L,R and 'then something'
                else
                oL and "more coming"
                else {
                    # Point: last one OK
                    # simply run out of &then
                    # is one way to end, or usually:
                    #  avoided by being %acheck, not made ok itself
                    #   oL&then will call L&then,
                    # and onward somehow, depends
                    me&Point_alldone,R,L
                }
            }
            elsif (!Ls&ok) {
                # oL%checked%Fugued
                # L%checking%Fuguing - ignored (even !%Fuguing?)
                #     -Fugue%Fugue   - not usually there
                
                # L%checking do no -eight til %%Checkable,
                #  avoided completely if %Fuguing, unless %resumed->%ok (above)
                Ls&Fuguing and debugger
                # throw merging test resumer
                if (!Ls&Fugued && !Ls&checking) {
                    # L 1, ch 2, Fugued 3 (may be instead of a ch 3, or extra)
                    $Fuguing = me&OPoint,R,['accept:'+L.t,'-Fugue',{}]
                    $ch = Ls&checked
                    ch and chs&Fuguing = Fuguing
                    Ls&Fugued = Fuguing
                    Fuguings&Fugue = L
                    # ^ becomes %resumed instead of %ok
                    me&wants,R,'Plot-en-Fugue',Plot
                    Fuguingc&Page_out = 99
                }
                if (Ls&resumed) {
                    me&tsc,"Error." .sc.fs = 20
                }
                else {
                    me&tsc,"Error?" .sc.fs = 40         
                }
                Thiss&pause = 1
            }
        }
        elsif (Lc&pi == 'Fugue') {
            me&tsc,"Accept-progress"
            #Thiss&pause = 0
        }
        else {
            throw "L!pi", Lc&pi
        }
    }
  
  // Point cosmetica
    # for R:Point
    me.Point_ology = &acgtRL{
        # sublate some R/%fix
        Rs&nofixfor = peel('Page_in,Page_out,Dome,Nine,ok,'
            +'checking,checked,resumed,had_ccb')
        Lc&pi == 'Point' and Rs&nofixfor.pi = 1
        Rs&goPoint and delete Rs&nofixfor
        
        # for the info
        $D = Cye(["Show",1])
        $ha = &c{ me&bracki,R,D,c }
        # when adding strange info, to insist open
        $strange = &c{ Ds&strange = 1 }
        # L has range, etc
        ha({Nine:Ls&Nine})
        each in Ls&Dome {
            ha({Dome:n})
        }
        if (Lc&Page_out && Lc&Page_in) {
            $Pages = 1+(Lc&Page_out*1)-(Lc&Page_in*1)
            ha({Pages,i:Lc&Page_in,o:Lc&Page_out})
        }
        # whether hungry?
        if (Ls&ok != null) {
            Ls&ok and me&tsc,"OK",0,'g' .y.cv = 0.01
            Ls&ok != 1 and strange()
            ha({ok:Ls&ok})
        }
        # which Lc&init|able|then have been called
        each tn Ls&had_ccb {
            ah(R,'fixablestyle',t,{opa:0.67})
        }
        # also says 'acheck' (Point@38) when not followed by a %checking (avoid loop)
        $l = Ly&l
        if (Ls&checking) {
            me&tsc,"check",0,'g'
            Ls&checking != l
                && strange(ha({checking:Ls&checking}))
        }
        if (Ls&resumed) {
            Ls&resumed != 'acheck'
                && strange(ha({resumed:Ls&resumed}))
        }
        
        # OK pseudo-Points, unless freakish, avoid ology
        # < one boost to lum them all
        #   eg know already if ology is boosted
        Ls&ok && (Ls&checking) && !Ds&strange and return
        
        #Ls&checking && !hak('checking,resumedme&bracki,R,D,{resumed:Ls&resumed}
        
        me&pibrackology,R,L,{D} .y.gog(&g{
            gy&cv = 0.8
            gs&dis = 1
        })
    }
    # for a relative (eg $eight or Eigh)
    me.Pointness = &acgtRs{
        $R = Cy&R
        $s = Rc&s
        if (Rs&TheEigh) {
            $z = Rs&got
            $L = z && zy&Point
            !z and me&tsc,"!%got",'...',"y"
        }
        else {
            $L = sy&Point
        }
        
        L ? me&tsc,"L.t",L.t,"y"
          : me&tsc,"L-less","L?","y"
        
        return L
    }
 },
// Gump - Know|That %%cha -> Travel
    ['Gumptio',0.5,&acgtRs{
    
        me&reaw,R,'Gumptio'
        
        me&jaa,R,'chag' .map(&n{
            # Know..$z
            $z = ns&efrom;
            # Travel..$n
            $N = me&otwin,z
            N.map(&n{
                $t = me&tpath,z
                me&zu,t,n
            })
        })
        
        # any new narrative is filled with the %%chag of now
        me&jaa,R,'narrative',1 .map(&i{
            $dome = 'v'+i
            me&ja,R,{dome} and return
            me&jaa,R,'chag' .map(&n{
                $z = ns&efrom
                n = ns&n
                me&otwin,z .map(&t{
                    me&ha,R,n,{dome},{cha:ns&cha||'?',t:t}
                })
            })
        });
        # < manage the Travel/$t
        # < %%chag instability before commit,
        #    see %Compiling
        
      // testable
        return;
        uniq( me&jaa,R,'chag','efrom' ) .map(&Z{
            
            # Know..$Z
            # Travel..$z
            $N = me&otwin,z
            
            $c = {};
            #z.t == 'Easiness' and me&zu,"from",z;
            c.from = me&tpath,Z;
            c.to = [];
            me&otwin,Z .map(&z{
                #me&zu,z;
                $b = {to:me&tpath,z ,from:[]}
                c.to.push(b);
                me&otwin,z .map(&v{
                    #v != z and me&zu,"diff",v
                    $path = me&tpath,v
                    b.from.push(path)
                    v == Z and b.from.push("== from")
                    ##path == 'That/W/Easiness' and me&zu,"^from",v
                })
            })
            me&zu,"fro",c
        })
        
    },'ift,D'],
  
// Duolish/%Releasor <- Travel
 # < de y&p %twin
   // %Releasor
    =pod see %Compiling
      a %Compiling in its push-phase,
       can decide to redo, because CBing, already
    
     Travel%%tw=$t should match:
     Ghost%twin/$t, giving (/of/$kt)
     Know%%tw=$kt same in reverse
     # on the inside of the join:
      Ghost..$t may know %%tw,s,host=Travel|Know already
     # on the outsides:
     Travel|Know p are %twinned by Ghost,
      Ghost providing queries from their perspective
       on Ghost p %structure, [C:t,C:of,C:t]
     
     Then we should end up with...
     < sheets of $t..$kt to apply to the joins:
       u towards Know:
        should still be that version
       n towards That:
        
       
     < other Ghost..$z joining Know..$kt etc,
       all have a %dige on Ghost..z, not:
       must have their truth shrunk onto the join,
       since we are replacing the shared record of something
       this is like getting pinned at a version, 
     < some even more complex Zave-tuition
    =cut 
    ['Releasor','298',&acgtRs{
        me&reaw,R,'Releasor';
        $S = me&inode,R;
        # to %ball/* from y&tw over s&z
        Rs&childy = 'tw';
        # Travel is %twinned to other steps
        $p = sy&participant
        # Travel/$t == sy&client (the experience)
        py&s != sy&client.y.up and throw "parts!client"
        !p and throw "nop"
        #$tr = Ry&up;
        #tr = trc&s;
        # < stop using y&p
        #$p = try&p;
        #!p || tr.t != 'Duolish' and throw "Travel?"
        
        # s was e, replaced on shunt
        # is the reality (Re:$t), beside the thing itself ($t)
        
     // func
      # < io this easy
      // y&Q leavers
        # $Steu/of(/args)?/t -> callback
        me.ofargsity = &acgt,Steu{
            return &y{
            me&indo,Steu (&sd{
                d.d <3 and return 's/of'
                $more = me&ioty,s .length
                more and return 'is an /args/ layer'
                $l = me.cby(d,&d{ return d.d <3 }).map(d => d.s);
                $t = l.pop();
                t != s and throw "confu";
                $of = l.shift();
                $args = l[0];
                # may not have args
                y (of,args,t)
            });
            }
        }
        # warn of args: $Steu/of(/args)?/t -> $f/of(/args)?/t
        # < for stretching %twin to support anyindex
        me.warn_argsity_of = &acgtWf{
            # W is the of column, nest it
            $cont = Cye(['eachofalone',1])
            me&fiu,cont,W;
            # warn of non of/t pushing (or whatever the %twin wants)
            me&ofargsity,cont (&of,args,t{
                $fo = me&fiu,f,of.t;
                args and fo = me&fiu,fo,args.t; ah(fo,'warn',"args-layer",1)
                $to = me&fiu,fo,t.t;
                args and me&zu,"hasArgs:",to
                toy&Q = t;
            })
        }
        # ac args: $Steu/of(/args)?/t -> $f/of/t%args[]
        # for writing as W.5
        me.Stearchish_to_twin = &acgt,Steu,f{
            $N = [];
            me&ofargsity,Steu (&of,args,t{
                $fo = me&fiu,f,of.t;
                $to = me&fiu,fo,t.t;
                tos&dige && tos&dige != ts&dige and throw "multiple diges ->"+to.t, t, toy&Q
                toy&Q = t;
                tos&dige = ts&dige;
                args and ac(to,'args',args.t)
                N.push(to)
            });
            return N
        }
        me.Stegroup_species = &acgtW,Steg{
            # sublate any species (share one $kt)
            #  $m:Dealap,$n:Dealap/js -> $m:Dealap/$n:js
            # < order by length of SteW/*.t, hier not fair
            $c = {yorigin:'Q',
                match:&mn{ return n.t.startsWith(m.t) },
                then:&mng{ 
                    g.t = gs&species = n.t.substr(m.t.length+1);
                    g.t && !g.t.includes('/') and 'ok'
                    else {
                        throw "species!grouping", m, n
                    }
                }
            };
            me&sublatile,W,Steg,c;
        }
      
      // y&origin leavers
        # rebuild and replace? $n/#$t
        me.Stereo = &acgtWt{
            !isC(W) and throw "!C W"
            W = Wy&origin || W;
            $eg = Cye(W);
            # to somewhere else
            isC(t) and $F = t
            else {
                # replacing
                $F = Wy&up;
                !F and throw "W!up"
                # ~t adding
                isst(t) and eg.t = t
                
            }
            egy&origin = W;
            return &y{
                y (W,eg);
                # places new thing
                !F and return
                $f = me&fiu,F,eg,8
                f && f != W && fy&origin != W and throw "knot sure", F, eg, f
                F and me&fiu,F,eg
            }
        }
        # regroup into each other
        me.sublatile = &acgtWtc{
            $into = t;
            c.yorigin ||= 'origin';
            me&ioty,W .map(&n{
                $g = Cye([n.t,2]);
                g.y [c.yorigin] = n;
                each im intos&z {
                    m == n || !c.match(m,n) and continue
                    c.then(m,n,g);
                    me&fiu,m,g
                    return
                }
                me&fiu,into,g
            })
        }
        
     // dunketha
      // outputs + 5 -> twin-form
        # have outputs
        $Sten = me&fiu,s,'n';
        $Steu = me&fiu,s,'u';
        
        # to output, nego into %twin
        $twine = me&fiu,s,'twine';
        # z first, leading up
        ss&z = arou(ss&z,z => z == twine,[]);
        ss&z.unshift(twine);
        
        # n
        $twn = me&fiu,twine,'n';
        # < various use cases for a wait-for-ok
        !me&fiu,Sten,'W' and return me&waits,"!W"
        
        me&ioty,Sten .map(&W{
            me&Stereo,W,twn (&W,eg{
            # schematic of what Q to place where
            $Steg = Cye(['g',1])
            
            if (W.t == 'W') {
                # make a pile of W%dige/[species%dige+]
                me&Stegroup_species,W,Steg;
        
                # each W make W.5 re this u/n configuration
                # make W.5 for each W grouping
                me&ioty,Steg .map(&m{
                    $f = Cye([m.t,9]);
                    # the 5.sc[$species] = dige, inc 1=Ws&dige
                    $spec = {1:m};
                    me&ioty,m .map(n => spec[n.t] = n);
                    each tn spec {
                        # the SteW/* is Qish: Q%string%dige without %of%args
                        #  which are implied by their placement in the Searchish
                        $Q = ny&Q;
                        f.sc[t] = Qs&dige
                    }
                    # re this u, flattening args
                    # < of:wjs -> of:w through the join?
                    #   see W|w: their species pool dige sensitivity
                    me&Stearchish_to_twin,Steu,f;
                    # f -> Qish q
                    $q = Cye(['5',2]);
                    qs&string = me&Lineso,f;
                    qs&dige = dig(qs&string);
                    # species thing fronting q as a writable of $W
                    me&fiu,m,q.t,8 and throw "already had a W.5", m
                    # into the Qish pile we began with
                    $n = me&fiu,m,q.t;
                    ny&Q = q;
                })
            }
            else {
                # copy anyway!
                me&warn_argsity_of,W,Steg;
            }
            
            # n... have %string etc from y&Q
            #  Steg structure y&Q -> g
            #  for something %%twin->Paving compatible re %species
            #  all other $of should just work?
            # < io resolving to y&Q, type checking
            me&indo,Steg (&sd{
                d.d <2 and return
                $p = d.la || eg;
                $v = sy&Q;
                !vs&dige and throw "notdiged",s,v
                v = d.la = Cye(v);
                # < doesn't keep the 
                vy&Steg = s;
                # t=$W/js -> js
                v.t = s.t;
                me&fiu,p,d.la
            });
            })
        })
        
        # n/W is now folded like %twin of/t
        #  with extra n/W/$species for Pave to realise exactly
        # checks others dont /args/
        # < %twin should learn anyindex:
        
        # < only for of:wjs?
        #   you might want the %twin|%Paving indexing to carry the args
        #   eg for watching lists,
        #    or anything but W|w which pool one big dige per thing
        # so in the .5 we know individual args,
        #  so reruns can more fully prepare eg of:wjs
        # yet for overall versioning,
        #  w:$t%dige is all Ghost/Know remembers
        #  will cover wjs:$t%dige(same)%args
        # W%dige covers W.js etc but not W.5,
        #  but W.5%dige covers W+W.js
        # < a ghost/w/wjs have the same %dige?
        
        # fold up all the u:
        # < wjs->w?
        # u... only have %dige etc (not even %args?)
        $twu = me&fiu,twine,'u';
        me&Stearchish_to_twin,Steu,twu .map(&to,{
            # drop deindexed info
            delete tos&args;
        })
      // outputs -> twin-linkage
        # looks for u/n stores behind/ahead of Travel
        # < complicated ideas
        
        # made a 5 about this s, added to itself,
        # added to n, to push via %twin
        #   W:Dealap will be a single yonder,
        #    though while this awake the 5 + js may update
        #   then Fingo should save asap
        
        each in ps&twinned {
            # < find t there, make &acty=3
            ns&remotes[0] != p and throw "aban"
            $r = ns&remotes[1];
            $h = r.t == 'Know' ? twu :
                r.t == 'That' ? twn : 0
            !h and throw "unremote", n, r;
            # for %MayGansp
            hy&release = s
            # Travely&p
            hy&host = p
            # Ghosty&pc&s
            hy&twin = ny&s
            # Knowy&p
            hy&remote = r
        }
    },'ift,D'],
   
   // Releasor/%MayGansp/%MayTwine+
    &{
    me.deboost = &acgt{
        $R = Cy&R;
        # < Babz: //= # !null-or
        Rs&boost == null and Rs&boost = -1
    }
    
    me.bin = &acgtk{
        $R = Cy&R;
        isst(k) and k = G&peel,k;
        each tv k {
            ah(R,'inheritscif','ball',t,v)
        }
    }
    },
    ['sleeping+wou_accepted','297',&acgtRs{
        # %wou must be there to access _accepted
        # < why w_a if no w when tunneling?
        me&rollbs,R,'wou'
    },'ift,D'],
    ['MayGhost','298',&acgtRs{
        me&reaw,R,'MayGhost,eph';
        me&bin,'MayGhost';
        $l = me.cby(R,'^^Releasor').length;
        l == 2 and s.t == 'twine' ? me&bin,'MayGansp' : me&deboost
        
        l <2 and return
        (Rs&boost||0) < 0 and Rs&thiding = me&ioty,s .map(z=>z.t)
    },'ift,D'],
   
   // %MayGansp - %twin find
    # %twin climb beings, to its idea of us
    ['MayGansp','298',&acgtRs{
    
        me&reaw,R,'MayGansp,eph';
        $S = me&inode,R;
        
        $g = me&case,34
        $twin = sy&twin;
        !twin and return me&mtsc,g,"!twin",'','g'
        gy&can('m','to').y.can('i',twin.t);
        me&bin,'MayTwine';
        
        $rs = sy&release;
        !rs and throw "!t->u/n bunch"
        !rsy&client and throw "release!client"
        # Ghost%%tw,host=from|yonder
        $host = sy&host;
        !host and throw "!join from"
        #hosty&s != sy&path[0] and throw "join from!this step", host, s
        # < %twin-like anyindex to anywhere
        $re = sy&remote;
        !re and throw "!remote host yonder"
        
        # < p only as Schema meta, make twin = s, sy&structure
        $tp = twiny&p;
        sy&structure = tps&structure;
        
        # Ghost%%tw=t.t,host=Travel
        me&twin_nodeo,R,twin,host,{tw:rs.t} (&n,t,zt{
            # %%found:Ghost/$zt, also found its Travel/$t
            # $n coming from Ghost%tw... has efrom=$zt, s=$t
            me&ha,R,{found:zt,t}
            $zt = ns&efrom;
            # which we remember from running it
            ns&s != rsy&client and throw "whose"
            # < $zt &settle $zt/*, so $zt/*/* changes ping
            me&settle,R,zt
        }) (&{
            # auto input Ghost/$zt
            #  this eto retracting when Ghost has it
            me&nodei,R,twin,{tw:rs.t,el:2}
        })
        
        $st = me&ollbs,R,'brackstable';
        me&zu,"olst",st
        
        me&ha,R,{twin}
        # bump Ghost when s/** settle
        me&ollbs,R,'brackstable' == 1 and me&ha,R,{waits:'heard',wants:twin}
        me&tsc,"mg",'','d'
        
        #(Rs&boost||0) > 0 and me&zu,"MayGansp.s",s;
    },'ift,D'],
   
   // twin|tw nodeo
    &{
    # the _nodeo c.t make %%(found|yonder)=$s,via=$z
    me.nodeo_foundha = &acgtRcqn{
        !c.t and throw "!t"
        !n && q.s and q[c.t] = delete q.s
        # < n.sc[c.k], returns what to iterate as $s
        q[c.t] ||= ns&s
        !q[c.t] and throw "foundrow !s"
        me&ha,R,q
    }
    # nodeo but with a perspective on a %twin
    # < tysc args: this is c||,=t(c)
    me.twin_nodeo = &acgtR,twin,host,c,t{
        isst(c) and c = {t:c}
        t and c = {q:c,t:t}
        $j = me&yfuture,twin;
        $q = c.q || c
        # %MayGansp &settles j/$zt once found
        #  is too specific to &settle j|Ghost itself
        q.host ||= 1;
        $N = me&zaa,j,q
            .filter(n => ns&host.t == host.t);
        return &per_thing,{
            N.length > 1 and return me&waits,"many:"+twin.t+"->"+host.t;
            N.map(&n{
                c.t and me&nodeo_foundha,R,c,{via:ns&efrom},n
                per_thing (n,ns&s,ns&efrom)
            })
            return &if_nothing,{
                !N.length and if_nothing()
            }
        }
    }
    # tw ^%%found -> %%found or %%almost,into
    # < &settle zp,z you might?
    # < tysc args: this is c||=t(c)
    me.tw_nodeo = &acgtRpsc{
        isst(c) and c = {t:c}
        # p has %%found
        $zp = me&zaa,p,c.q||c.t,1 [0];
        zp && !zpy&R and zp = 0
        if (zp) {
            # to be put in $zp/$z
            $z = me&fiu,zp,s.t,8;
            !z and me&ha,R,{almost:c.t,into:zp}
        }
        # they must node init
        # < occasion to force %%wants?
        z && !zy&R and z = 0
        z and me&nodeo_foundha,R,c,{s:z}
        return &per_thing,{
            z and per_thing(z)
            return &if_nearly,{
                !z && zp and if_nearly(zp)
            }
        }
    }
   
   // &otwin, &elnodes
    # use a %twin join, given Know|Travel..s
    # finds Travel|Know..s
    # < gives paths and takes directions like &jaa
    me.otwin = &acgts{
        # Know..s, find Know%twinned = Ghost
        $S = sy&path[0];
        $p = Sy&p;
        $N = [];
        each in ps&twinned {
            $twin = ny&R
            # Ghost eto the index:
            #  %%s:Know..$s
            #  %%inside:Ghost/$a
            #  %%efrom=Ghost..$z that found Know%%tw,s
            # < use with host:$p if tw, needs a direction to go
            me&jaa,twin,{s} .map(&n{
                # Ghost/$a <-> Ghost..$z%%inside
                $q = ns&inside ? {efrom:ns&inside} : {inside:ns&efrom}
                #N.push(q)
                N.push( ... me&jaa,twin,q .map(n => ns&s) )
            })
        }
        return N
    }
    
    # nodein %%el,tw requets +|- $s/#$e
    # < get flowing
    me.elnodes = &acgts{
        $R = Cy&R;
        me&jaa,R,'el,tw,efrom' .map(&n{
            $t = ns&tw;
            $was = me&fiu,s,t,8;
            ns&el == 2 and me&fiu,s,t
            else
            ns&el == 9 and me&fiu,s,t,9
            else {
                # < waits takes params?
                return me&waits,"unknown-e"
            }
            $cha = ns&el == 2 && !was
                || ns&el == 9 && was;
            if (cha) {
                # if we are a step, dont %onlyish
                sy&p and Rs&numberclicked = 1;
                # < wake s to init n, only, so adhere etc
                #   wants a pointer to not yet node
                me&ha,R,{waits:'elnode',elnode:ns&el,wants:s}
                #me&Rsync,R;
            } 
            # < %twin them immediately
            # sender must &settle Ghost**
        })
    }
    
    },
    
    
   // %MayTwine - %twin climber
    ['MayTwine','298',&acgtRs{
        
        me&reaw,R,'MayTwine,eph,activy';
        me&bin,'MayTwine';
        $S = me&inode,R;
        $mg = me.cbu(R,'MayGansp');
        $ms = mgc&s;
        
        $x = me&Jx,R;
        $ja = &c{ return me&ja,R,c };
        
        $li = sy&path.indexOf(ms);
        li < 0 and throw "!^^MayGansp"
        $l = sy&path.slice(li);
        li = l.length-1;
        $h = msy&structure[li];
        # t/of/t/species is pushed but not remembered
        !h and me&ha,R,'extra'
        else
        # a t/of/t, or any complete leg of index
        #  that we want to push a state to
        !msy&structure[li+1] and me&ha,R,'thing'
        
        # Travel/* <-> Ghost/$ms..$z <-> Know..$K
        $K;
        
        # twin|tw_nodeo: p%%found=$zt|$z / #$s
        $p = Ry&up;
        me&tw_nodeo,R,p,s,'found' (&z{
            me&jaa,R,'found',1 [0] != z and debugger;
            # we are %%found=z
            $zj = zy&R;
            !zj and return me&waits,"theyR"
            !ja('thing') and return
            # Ghost%%tw... again for the other side
            me&twin_nodeo,R,msy&twin,msy&remote,{tw:s.t},'yonder' (&n{
                # we are %%yonder=K
                # wake %MayGansp on Know..K connection
                !me&za,R,'yonder,via'
                    && me&ha,R,{waits:'foryondering',wants:ms}
            }) (&{
                # tell it to nodeo input a Know..%Pave
                $tp = me&tpath,s
                $tpz = me&tpath,z
                ~>5 nottwin: tpz, tp
                $may = me&jaa,zj,'may:input' .filter(n => !ns&eto)
                if (may.length) {
                    me&nodei,R,zj,{s,may:'input'}
                    # < then making sure Know/ finishes 
                    !me&za,R,'s,may:input'
                        && me&ha,R,{waits:'forKnow',wants:ms}
                }
            });
        })
        (&into,{
            # we are %%almost=found,into:zabove
            # not beyond the path
            me&ja,R,'extra' and return
            # i $into/#$s:z, remembering we did so
            ~>6 el2: msy&remote+'..'+s.t
            # < settle it before this. attend back here after|before,
            #    depending on the relativities of those wakers
            me&nodei,R,into,{tw:s.t,el:2},{dome:'awakes'}
        })
        
   // %twin->%Pave
        # < check %%extra are %%ok...
        # < Gansp's %%thing collection should become stable
        # < &settle (no other) - for all so far
        # < &settle cv, EXPR - EXPR||Ying-wide wait
        #   if lower cv settles await !
        # < x&ja,c,1 for:
        $K = me&jaa,R,'yonder',1 [0]
        $z = me&jaa,R,'found',1 [0]
        
        K && me&twin_nodeo,R,msy&twin,msy&remote,{s:K} (&n{
            # Know..K can find other Ghost..z
            ns&s == K and return
            me&ha,R,{otherz:ns&s,via:ns&efrom}
        });
        
        $twin = me&ja,mg,'twin',1 [0];
        if (ja('thing')) {
            !K and 'wait-for-climbing'
            elsif (me&settle,R,K ) {
                me&ha,R,{waits:'forK',wants:K};
                me&tsc,'..K'
            }
            else {
                # < flavours of waiting for something
        
                # Ghost..z has the Travel'd version, K may ~
                zs&dige = ss&dige;
                # < or perhaps only if it's not as K implies,
                #   requiring all changes of K%dige to offset all its twin..z
                #ss&dige == Ks&dige and delete zs&dige

                # can expect|%%actey-vate %Paving on things
                if (twin.t == 'Ghost') {
                    # should be as we u, or slightly old
                    !Ks&dige and me&ha,R,{waits:'Kdige',wants:K}
                    me&ha,R,'ok'
                }
                elsif (twin.t == 'To') {
                    # should be as it was
                    # < to %parent, if ~ since we Travel to replace it?
                    #   esp if it was W load+save
                    me&toPave,R,R,K,s
                }
                else {
                    me&zu,"weird_twin",twin
                }
            }
            # %MayGansp collects %%thing,ok?
            $q = {thing:s}
            ja('ok') and q.ok = 1
            me&nodei,R,mg,q
        }
        
        if (ja('extra')) {
            # &toPave (uses %MayTwine of
            #     |may %%wantpush,Q,s,eto=) the non-extra thing
            $K = me&jaa,Ry&up,'yonder',1 [0]
            me&toPave,R,Ry&up,K,s,{species:s.t}
        }
        
        # < something to settle all %%thing,
        # < mark each then all %%wantpush
        
        #(Rs&boost||0) > 0 and me&zu,"MayTwine.s",s;
    },'ift,D'],
   
   // %MayGansp unit of push
    ['MayGansp','299',&acgtRs{
        
        $x = me&Jx,R;
        
        me&jaa,R,'thing',1 .map(&z{
            $j = zy&R;
            # should lead back here after rattle
            me&settle,R,z
            
            me&ja,j,'ok' and return me&ha,R,{ok:z}
            me&ja,j,'wantpush' and me&ha,R,{wantpush:z}
            else {
                # < curio: match jam to lateral shunt
                if (0 && !me&ja,j,'yonder' ) {
                    me&nodei,R,z,{actey:3},{dome:'tilpushed-actey'}
                    $found = me&jaa,j,'found',1 [0]
                    if (found && me&ja,j,'eto,s,may:input'
                        # input done,
                        && me&ja,foundy&R,'eto,s,may:input'
                        # without That%%tw, no To%%tw yet:
                        && !me&ja,foundy&R,'eto,tw,s' ) {
                        # < unfreezable numberclicked That
                        # jy&up
                        #me&nodei,R,z,{actey:3},{dome:'tilpushed'}
                        me&tsc,z.t+"-may:"
                        $rp = sy&remote;
                        $r = me&yfuture,rp;
                        rs&numberclicked = 1;
                        me&ha,R,{waits:"may:input-shunt",wants:rc&s}
                    }
                    # then waiting for:settle-!down
                }
                me&ha,R,{waiting:z}
            }
        })
        # wait for all %%ok|wantpush
        # < periodically poke the $of of any %%waiting
        me&ja,R,'waiting' and return
        !(me&ja,R,'ok' || me&ja,R,'wantpush' ) and return
        # desend %%actey now they all must have succeeded
        me&za,R,'waiting' and me&dome_traction,R,'tilpushed-actey',{el:2}
        # wait for all %%ok after any %%maypush
        if (me&ja,R,'wantpush' ) {
            x.ro("push*") &&
            me&jaa,R,'thing',1 .map(&z{
                $jo = me&yfuture,z;
                # < slow dige-through only, user must see diffs
                me&nodei,R,z,{maypush:1},{dome:'tilpushed-push'}
                me&ha,R,{waits:'tilpushed',wants:z}
            });
            return
        }
        me&tsc,"Done!"
    },'ift,D'],
   

]}