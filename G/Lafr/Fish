# A emixer
$fi = self.fi = {}
self.isA = A => (A.y && A.y.A == A || A.y == A) && A.c && A.sc
 // f
    # ex with array merge
    #  eg s|c.via=[one|two] -> s.via=[one,two]
    self.mex = &scq{
        q ||= {}
        if (q.ek) {
            # fatal to want change
        }
        c = exable(c,s)
        return ex(s,c)
    }
    # defor... inverted
    self.oneor = &ckv{
        $is = c [k]
        is == null || !is || is == 1 and return v
        return is
    }
    
    
    
    
    
    
    
    
    
    
    // sion
 // X
   =pod
    the new X
     space for spaces of matter (its2)
     forming over and against any other|prior experience
     
     each X is for an A: X.A=A, A&X=X
     < merge X into A?
     < make X C, X now being X.sc
     
     a beach where traces hang up ways in
      a photographic field where A can know itself,
       at any level between A(.*)+ and A/C, even A/type/C
       and any moment, supposing indexing includes $moment
        or you would simply make another X
      with individual fronds of X.*
       networks of types and measures,
        in an expanse intersected by a curve
     
     A loads X with things approaching C
      X.t.$t = x, x.z/C, C.t=$t
       is a simple load of things for J
       x.z can handle dupes, see 'ressur concluded'
        other indexes|slope should be found to separate them
       that C might have no meaningful C.t, etc
        be just C.sc, eg &brackX for X.k.$gk...
        separatable by other lateralism:
       having extra coordinates for the same C|refs|etc in X...
        the X.t.. produces A/C tuples
        may share C with various X.*.... producing:
         legs of twinning:
          e wanting C/$partofC/connects:to/C:D/because
         you may specify these, as i|o things
          so you are notified|involved
           as soon as X notices rows come into that view
          and thence &ha|&n, even &increment
           may see if they start|have|stop involvement in whatever
            creating the memory of a search for fitting a formula
            which would be the ultimate thing to optimise
         so it decides to write various things about it,
          including was-something-e-wanted
         
     so they attach C,
      any ways they want
      then start walking around it
      assuming things it didnt see arent there, see 'ressur concluded'
     to X, which is also attaching to itself:
     A tends to have identifiables (At path) anywhere it spreads out:
       Aip - subnets repeating
       At - path (mind+Ct)
      along with its own X
       to arrive X into X&A.up&X (upward)
        so it acquires X.V, the supposed last version of this X
        as resolved by At+Aip, etc
       see 'A@1 scans itself'
       every X has a value for At, for X.A
        like x has a value for X..x
         they are $k (X.$k index name)
          + $ark:$v pairs for columns of that index...
          could be in x.had.$ark=$v,
           warn if another different 
         eg X.had.At="u:Blah", as in X.up.At."u:Blah".z/$X
         
         < x also knowing the index its in, its values
           x.karkv.$k.$ark=$v
            for X.$k with ordered hash of ark|columns with value
           may even track x.z/$r being input to other indexes
            a &t context may have many &Xint etc
           perhaps on X.rk = &X_s $r, &X_t $k
            so the x per $r track what X.$k.. that $r is in
         < similarly, we may X.kr = &X_t $k, &X_s $r
           may useful knowing an index appears|empties
            see xq
           with the same devicing that notices things doing the same
            of X.k.* space like X.k..x.z.* space
           an &Xint for what is &Xint-ed
     
     so X.had|karkv knows where|what|which A is in A.up&X (|V)
     and X.* in general indexes A/**:
      A/A, become X.At when they &X
      other A can be met: X.oAt
       in objects in a call in A:a, eg &ha,C(y&A:b)
       with a,b either way around
        perhaps being more o to the A:b&X above, etc
        which thing goes into the other,
         how they slope etc. all might matter
       extra how|when|why indexing may pile up here:
        X.iAt.ha.$At.z/A for where &ha,C came from, etc
       in a few steps,
        A:a may other A:b for its own ends
        and|or|which-is become elvised, imposed into there asap
        depending on what function is crossing what lines, etc
      A..A eg $dome is itself
     
     we would assume most x.z/$C
      
    so
     it can put away like &brackX,
      for multiple n%*
      while noticing refs anywhere already
       thistimes, esp something duplicating
        esp becoming complete in some way (-group) of:
       thattimes, have recyclables
        have goners eventually:
        can be 'ressur concluded' at some point
         trad match t+i @17, see &arriveRbitX
          %Te only match t, so all i are the same to it
          %Te want to accept pointerbits
           and get named (Te.t) more elabourately
           per thing we need to separate
            the arrival of qua to
           we may be able to say C:Thing/-suchapi
            cutting down on At-ness between C...$pi
            expecting any|one|many -suchapi with any name
             or some name, qua besides c&pi='suchapi'
              and not, etc. an assertion.
            delivered from any point in the slope,
             where it makes sense, is grouped...
             drops into the was-implied section of %Te/** growth
           which is the compression
            of X back into C, basically
            the 'I want this and that somewhere in here'
            from sparse tendrils of implication 
            into the tidiest job sheet possible
          
       we may be doing only some of the channel
        which should re-emerge in perfect sequence...
        they will partition by ny&act=T.act,
         see 'ressur concluded', other lateralism
         and &twlic etc, does list gapality
        
     it is used to find e-pointers
      which is often about deducing how simple it can be:
      &CX: X.t for t-path (the J..C..), having C
      &brackX:
        finding pointers to rows is new
         we tend to &brackstill the overall k:v concat
          while it is considered one big undivisible instant
          then group rows into C when it moments, eg -brackology
           from here we could generate a better-typed likeness for:
        
        could match as simple as &ja,'such,had,keys'
         might have to be all the keys (of a class)
         or be pattern matches that &voice
          &voice climbs trees of mind (the EXPR)
           while climbing chunks of the world
           the basic do sub depending on values loop
           it should walk out over X, measuring distances...
          pattern matches for &voice being transportable
          they would be pointer composing
         or match row cloned from such a row &Xout,$row
         or any other lateralism:
          row from|haswayto a certain A
           eg $dome, or Aip|At bits
           or n-ward to brack without coordinates, from a:
           or u-ward to them -> -groupology get names (in C)
            of the Km.t, having Kmc&rows
          any other X-ing the r is in
          match cloning (&ha,$n,...) from such a row, eg in V.rowrefs
           currently the only way to drop recycled domebits
            when they regenerate
            to have the osc C consistently in memory
           similar to row from certain A
         they could all be turning into an &Xout,{...},{...}
          that Te would instruct
        
        conversely, 'ressur concluded':
         the row might el:9 when these things go unmatched
         resolving the set of seemingly coming+going things
          to changes to their insides,
           when supposed together by homology|similarity:
           it may just have a key changing, becoming el:3
          to minimise overall change given extra expression and context
           things can be told apart by lateral inquiry:
            thing from same dome (A), that D^^A of ours
           or in|through-row|n-ward C having uniqueness
            compared to others in the ambigroup
        
        and be able to notice|react when it next &ha
        
        may adjust their names?
        
    as the X grows it becomes a V
     &ja|&za read each
     parts of V could be
      virtually
       read from many sources, eg &t
       appearing in X already
      actually
       prepared, eg %dome
       preplanted in X already
     by the time
     then parts of X are parts of V
    
    &a-pprehending brack leading into:
    &Kmish
     D&X -> D/** of Km, Kn starting at Dc&brackin
       can now read xq for structures
      they would be via
    %singletter
     elvis that undoes the last input character,
      before inputting another
      so anywhere the meaning of that letter went,
       must be retracted, redone with the new one
       meaning catching the first letter type event,
        multiple times (el2,el3+)
       the oscillator decides to i,-i based on o
      smudge over time to sing
   =cut
    
  // frontend
   =pod
   lang has instances of cultures at levels
   they share s,c,q
    q mostly, which talks of the whole trip:
    
    use: &ha|&ja|... sc,shade,mix
     perspectives, for most local expressions of truthseeking
     configures probably one:
    front: &a A,s,c,q||={}
     handles that family of types doing what they do
     make many calls, each get it takes
     to something like:
      &Xio,{i:'brack',X||=A},s,c,q
       each spec q.Xio|Xq.t, source X|A
       may change s,c,q completely
       each &Xio translates to:
    middle: &bracki X,s,c,q
     defining with each &qas, climbing them 
      each $n first, then $k|v...
      we can assert|check index is how we expect (down to a point)
     and climbing whatever it needs
    back:
     &qis,X,o,s,c,x <- many $s,$c travel x|X
      read+write X..x as per $xt, with $s, for $c
      s.sc bind params
      s,c new at backend|micro
       re an op on $xq (the index)
      o.xq|Xq...
      o.s|c|q were middle|macro level
       < o.c|q might hook by $xt to ex &qis..c, etc
      are individual to the $xt
   
   the theme of everything taking s,c,q (y,c,sc reversed)
    they may compile as they cross each layer, esp middle
     s.. is likely to be iterated by the middle,
     c+q are likely
      search|thing (what, reality)
       what we implant+excavate
      configurance (how to)
       io spec, complex WHERE, etc
      question
       shared over all layers,
        per use or at least frontend lifecycle
        < track each other over time
          frontend doesnt know what use it is for
          unless they are &h calls (G.h(acgt...)) which G&B...
       may make arbitrary lowlevelations
        may be copying (translating) to another X|x
        may el:9 everything at the backend
        may want to check all X/$n.sc same asap
         see 'the q.still variation'
       limit|replace certain x, who knows what.
    
    leads you to describe the thing you are in
    X is life+death crossing over, once matured
   =cut
    
    # us doing stuff
    fi.live = &acgt{
        $i = 5
        $c = exts({},'sit','t')
        c.oth = 1
        #4s&Bthing = Gc&B
        4s&Bthing = eny(c)
        #u Dealap
        # < see I change
        4s&Athing = A
        #As&selfpin = me&t,R,{of:'wjs',args:'ar,J,s'},'Fish'
        #As&selfpin = me&t,R,{of:'wjs',args:'flonk,J,s'},'Fish'
        while (i--)
            ~>5 Fiseh: 3
        fi&a,{fuselage:3}
    }
    
    # {i|o:$Xqt...} {thing} {how} {}
    # could be any medium|indexing (Xqt)
    # per direction (write+read) (Xio)
    fi.Xios ||= {}
    fi.Xio = &acgtescq{
        # q.Xio|Xq.t <- e = {i:'brack'} || 'brack'
        typeof e == 'string' and e = {i:e}
        !e.Xio and e.Xio = haks(e)[0]; e.Xq = e[e.Xio]
        isst(e.Xq) and e.Xq = {t:e.Xq}
        q ||= {}
        # q.Xq already may know a previous &Xio
        
        $X = delete e.X
        # < Babz
        #X ||= delete e.A
        X ||= A
        
        # become A&X
        isA(X) and X = Xc&X ||= {A:X}
        
        # < ac q.allXio.$Xqt
        ex2(q,e)
        
        # know Xq.t by name
        $Xqf = fi.Xios[q.Xq.t]
        !Xqf and throw "!Xqt:"+q.Xq.t
        # of the ways (i|o|etc) at the ground
        $Xqfio = Xqf[e.Xio]
        !Xqfio and throw "!Xio:"+q.Xq.t+"."+e.Xio
        
        return Xqfio (A,C,G,T,X,s,c,q)
    }
    
   // GOING &Xint|&Xout,X|A,s,c,q||$t:Xqt,q (&middle is $Xqt)
    # Itivity of s+c
    fi.Xi = {}
    fi.Xo = {}
    # i|o {thing} {how} {}
    # could be any medium|indexing
    fi.Xint = &acgtXscqe{
        return fi&Xstru,fi.Xi,X,s,c,q,e
    }
    fi.Xout = &acgtXscqe{
        return fi&Xstru,fi.Xo,X,s,c,q,e
    }
    # CRUDJ(oin)D(iffer) on indexes
    # < q may make this into an iterator around here
    fi.Xstru = &acgtIXscqe{
        # specify X.Xq.$Xqt as q='word', q.Xq='word' or q.Xq.t
        # < expets() almost does this. or is it mightexpe(), mightpeel()?
        isst(q) && !peelish(q) and q = {Xq:{t:q}}
        q = peel(q)
        isst(q.Xq) and q.Xq = {t:q.Xq}
        # also
        e and ext2(q,peel(e))
        
        # we become A&X
        isA(X) and X = Xc&X ||= {A:X}
        else {
            debugger
        }
        
        # s is the unknown, used
        # c is mostly talking to the Itivity, may c.where, c.sort etc
        # q.Xq for the ongoing structure,
        # q.* talks lower-level Itivity and to &X_* (storage mechanics)
        #  q.for.t={el:9} should delete the X.t.*.z/$n?
        #   you should provide deletes about * + $n,
        #    over an interface that can receive el:6 (moves) etc
        #  maybe sorting|weighting
        # an Itivity (Xint|Xout) interprets per structure
        isst(I) and I = fi[I]
        $y = q.Xq && I[q.Xq.t] 
        !y and throw "!q.Xq.t:"+q.Xq.t
        return y (A,C,G,T,X,s,c,q)
    }
 
  // &t
   =pod
    &t
     write search down - Qish as brack c
     find any things (rows) matching c
      go for the smallest set as the one
     write what we read, inc nothing
      do things to get, keep thing
     reads a thing!
     
    //    for &t - little X:parts relativity
          see X:new/$reks
          
          < intro to &clusp?
           def 'u some' -> A.1/u/some
            as a batch (until 'n using..' or &clusp)
            we mix up a %J:
             tv sort|replace $C** as usu
             named by joint(uN,'+'), source list
              cached at $sNorm=A.5/u/some+Normal, lent to others
            $sNorm can have W:Normal dependency
             that we want to make sense of through backroomish &t
            we mix them together like a %J
             also fully state any $of different to u:Normal
          
          X:anI underlaps:
           X:someu has some $n W:some
           X:Normalu has underlapping $n W:Normal
           &clusp
            mix them into
             C:some+Normal/$of**
              re-use C:Normal/$of
               trust that mind will not be tampered
               C refs would be different if changed within:
                sub-mind having been oscillated
                 or loaded from <script>
              new C:$of** if mixing
               because in &voice, we $ofs&z=[D+] around
                expecting lowlevel integrity of C** hardwirings,
                 < unify &voice iterators as X, later
                   swathes $of=common/%sc=rare could be indexed, jumped over
             X:sNu/$of
              knows all /$of
               re-use switches -> X:Normalu/$of/**
               new also has /$of/** 
              to become X:anI:
           X:anI/$of
            if re-use
             rowing switches -> X:Normalu/$of**
             x.Xorm? into the same /$of-ness there
            etc
           so
            first $of from X:anI (then X:Normalu)
             while &t at A**.I=X:anI (climbing slope)
          
          X:whicheverI @Search:
           having X:best, X:maybe, X:sorta
            for three grades of stuff
           goes for the first /$of found
            so eg X:best/$of would be a coherent bunch
             which may mean being mixed with Normal/$of 
          
          &t, while at A**.I=X:anI
           can find each $of from X:someu|Normalu
            ie without having to re-C everything from X:Normalu to X:anI
            see 'X:anI underlaps'
            &T changing a mind, pulls it closer
           
           A.5/u/Normal is W:Normal and Normal.js?
            or some u:some left as a cache
           A.5/n/Normal also,
            is our attempts to push|pull things
            the who|what we want them to be, etc
           
           5/u searches W:u/*
           5/n searches W:*
            may
             push W:u/Normal
              so 5/u gets it
             push W:Anything
              so 5/n gets it
           
           from a distance|angle
            n means production
            u means consumption
             
            
   =cut
    # Tthing that can wait for it various ways
    # c.modes of async
    fi.t = &acgtsc{
        # s,c may be $of,$t or 'I',$t
        isst(s) && !c and s = {of:I,t:s}
        s = exts({},s,'of')
        c = exts({},c,'t')
        c.t != null and s.t = delete c.t
        # s{of,t} c{el:2}
        $I = A.I || A.1.I || A.4.I
        $t = fi&Xint,s,{},'quest'
    }
    # Itivity of s+c
    # s is Qish quest - look for a thing
    # c can el:9, el:2...
    fi.Xi.quest = &acgtXscq{
        fi&qas,X,q,'k'
        each kv s {
            # the keys
            $kx = me&X_t,X,k,n,'k'
            # have their values via unique id
            me&X_s,kx,v,n,'ref'
            
        }
    }
    fi.Xo.quest = &acgtXscq{
    }
  // way
    # throw if no

  // apprehend (&ha, &ja...)
   =pod brackio
    do as &bracki|o do
      we create a new $n picturing:
      s.s|shade|mix
      s.s=C might be cloned,
       %%dome and all the usual effects
      n.c knows of other stuff:
       row is recycled
       was entered by some A...
        there is an inside, &ha while Dome is 3
        must be siphoned into the self sometimes
        instruments producing brack when acted on
         other bracks below the line
    
    mere Ds&z=[$n+] (and &brackX) becomes:
     
     X/$n and X/$k|v|ks
     
     X/$n = xn - ground everything else
      an index for $n itself,
       that also for x.z/$n, out there
        these two 'for' resolve $n to each other
         usu effortless|already done
          as in &bracki rows causing all the x
           they are positing the x as inhabited
          or a part of your process
         maybe coming,
          or partly out of control
          esp if working from analogue distances
           of beyond one X|A etc
          like we put things in the big A.c
           to make them famous
           a kind of nobility is supposed,
            creating a wave of negation out there
      
      join X/$n from x/$n
       to get its sequence, and more:
       
       X/$n/$ks may exist
        or
       X/$ks can be made to look like it
        with $n-clausation
         being $ks/$n but sorting $n/$ks
       
       on the two /$n senses:
       
       X/$n is X.n[vi]=xn, uniques $n, type='s'
       x/$n is x.z[i]=$n, dupey $n, type=~'z'
       interesting. to write:
        x.z/$n, we def mean the latter
        x/$n, may join x.z/$n to X/$n
         or maybe,
          x.n[vi]=xxn ?
      
      any x/$n should also be in X/$n
       (for both those /$n senses)
      you join X/$n to get its sequence
       any X/$n/... are also there, indexed per $n
       
       X/$n/$k or $n-clausation slomo
        vis. X/$n = xn, xn/$k
        basic premise:
         having $n*, wanting $k*
         may be specified or wide open
        exists:
         xn/$k = xnk
          a copy of what it contributes
          xnk != xk (X/$k)
          might even link:
           xnk.xorm=xk (with other $n)
           to get to X/$k
           see 'x.Xorm'
          at least clues $k index
         X/$k = xk
          knowing already some xnk.z/$n
           amongst others in xk.z/$n
        else:
         simply grep $n in X.k..xk.z/$n
         so:
          it always works
          see 'X/$n/$answer already written down'
        so:
         we carry the $k from xn to X
          or the $n from|to any x.z/$n
       
       X/$n:spec/$k/$n
        $n:spec could be found in X/$n
         or we might grep $n in X/$k.z/$n
        either way some lowlevels appear
         its position in:
          X/$n - where to get to the row before, etc
          X/$k - keys defined by any node in order
          X/$k.z/$n - nodes defining keys in order
        so:
         we can always get more|less $n|$k|etc
         and join that rowsense somehow
         use whatever X.** mechanisms
        solving:
         eg X/$n:spec -> xn && xn.k
          means we can xn/$k = xnk
          carry the $k: X/$k = xk
           xk.z/$n:other
            $n:other having any particular $k that $n:spec had
            sorted by $k
             $n duping would be avoided,
             < rowsmush would squish blobs to fit things between
          swimming
           around to wider|narrower spaces
           how to traction one view on another
        
       about: parallel spaces and subselecting
        x is posited as inhabited by various $n
         x.z/$n specifically found it
         
        can always find an index to|from $n
         simply looking at any x.z/$n
         and applying it to other x.z/$n
        
        ie, having the X/$n/$answer already written down
         or falling back to grep for it
          or even invoke &answer to generate it
           modulating an index full of answers
            waiting to be needed
            lazy evaluation
        
            note on X|x/$n sequencing getting mingled:
                     because xn groups by $n
                      X/$n -> X.n[$nsi] = xn # per unique $n
                      x -> x.z[$i] = $n (not xz) # dupey, all &a...$n
                     sequence loss into X/$n:
                      n1, n2, n1 -> xn1(x2), xn2
                     restorable by join to something in order:
                      o X.z/$n o xn.z/$n
                       X.z=[$n+] every &qis c$n ever
                      see conflating of which $n
                      and unlocking assuredness
                       about the vectors
                     
                     X.perience/$n of its own order
                     X.z/$n ordered by time of &qis (supposable?)
                     X/$n once per $n, in order of appearance
                      order might impose to X.n but not X.nv (refers)
                       from X:old->X:new
                     #   s/ns/nv/ for plurality of n values
                     
                     eg
                     X/$k/$n out there can find their X/$n/$ks
                      $n being the join around X.**
                       ie $n cluster at found x
                        many x join many x/$n, out and back
                        x/$n finds $n finding x 
                     X/$k/$n/$ks
                      may work for notation
                       from a $k*s $n*s $ks
                       knowing to join by $n back to:
                     X/$ks where $n
                      X/$n/$ks might clue|copy a lead on $ks bits
                      or take X/$ks and grep for .z/$n
                     easy.
                     
                     waves of X..x come as per $n
                     
                     how much of what is an artifact of iteration
                      and how to de-warp it when per-somethinging
                       what to take as now
                        in the midst of the machine that changes
                        ie might want everyones %colours
                         to make a palatable difference
                     
                /note
     
      exact X/$n coming around again is to el:3?
    
    < dev
     < &bracko as usual.
      not for the moment needing to:
     < io paths
      the boundary / crosses may be:
      s.N/$n - an array of $n
      x/$n - the rows with something at x
      x/$n/$k -  joins to X/$k by $n
      $n+$k may be specified or wide open
       ie cause where as well as select
       they are notated like bind params
        say what index|column to join to
         since it is no longer always 'z' (tv climbing)
      < brack has $u%n = $n hierarchies, sorta
        would be $n:lower/$u:higher
    
    also:
      the q.still variation on any middle:
       &Xio:i:brack s.N/$n q.still=1
        we would pass all our rows
         to refresh the index,
          either in place or by making X:diff
         like &brackstill, simple as for speed?
          each X/$n (row) remembers the many {k,v} it had
          each $n again:
           resolving $n is easy (ref)
           alt xq.i(...) makes list of new {k,v}
           if cha,
            T.whack out of &bracki to:
       &Xio:i:brack s.N/$n q.still=2
        checks bunch of $n for re-read
   //    resolving $n is easy (ref), or: (+ X/$ks name pooling)
         starting with more specific X/$ks (name pooling)
          expressions
           shared by many|one $n
           there is usu a way to refer to an exact $n
            eg '%part=4'
             smooth variety of %part across $n is interesting
              the i X/$k/$v would notice
               having many x.z/$n last few of its x were .z.length==1
               conflating the possibility of using $ks
            eg '%%what,it,is', whole + ordered
             # sorting by $k may detect renames amongst a few 
            # probably conflating:
            eg '%%what,it,is...', parts (ordered but not /^/)
            eg '%what,is', parts (ordered?)
            eg '%', having sc at all
            eg '%%', being brack, as wild space blends with C
            and more expressions
             eg '%%what,it,is..' is leading into is (and whole)
            anything &brackology can make string
           anyway
            generates many X/$ks per $n
             a bunch of usuals,
              like t, t+cv, and see below
             until finding with no ambiguity
              X/$ks.z.length == 1
             finally give up with:
              X/$ks='%%same,things'/[8] -> sequenced
              X/$ks='[8] %%same,things'/[0]
               like footnotes
                and a multitude|point controller (%Cit) to you
               extra nametagging
                from an alien language
                 since our closest $ks is still ambiguous
                 and our $n-sequence within it
        so X:old
        emerging new in X:diff (partly?)
         with X/$n|k|v|ks like X:old
          since X:diff being q.$moded from some middle,
           we end up with their structure+order through &qis
         each X/$n** fully like X:old
        the create as
        we notice things,
         sooner or later (resolving $n)
         makes X:diff/$el=1-3,9/$n|sc|k|v probably
         maybe X:diff/$alterity measures
        so we can have little X:parts
         putting hypothetica, structure embeds
          on branches
        
        sequencing $n across things
         &qis $n is a dome
          with &qis $ks|etc before the next &qis $n
         &qis can be
          reading|writing any other index
           with each $n|$ks it is given
           ie in a loop that may be dimensioning around,
            middle|back could tail call
             and other &voice lateralism
           as neighbours (particularly in sequence) arrive:
            o $n:new/$ks o $n:old/$ks
             not knowing $n:old at first
              join by X:old/$ks
              which $n:old can be found in relation to,
               ie select $n/$ks from $ks/$n
                sort by X:old/$n
              making sizups:
            i $pairs/$n:new/$n:old
             as in '. appears to be the new .'
              then fill out
            i $similar/$pairs/$metrics
             each degree $similar (sort|dividable)
              per $pairs,
               specifically $metrics
            would make picking most similar pairs,
             satisfying all X:new/$n
            see resolving $n
        
   //    resolving $n
           eg X:diff.finds/$n:new/$n:old/$ks|$k
            these are our neighbours|similars
            all new $n,
             having $ks|$k
             remember old $ks|$k
             leading to pluralities of $n it could be
             all lining up ok
             by being the most ideal:
              sort by homology of $k|etc,
               making (maybe many) guesses at $n/$n
                maybe many shouldnt happen if you $tv:n
             if maybe many
              each $n/$n guess
               weighs into $n/weigh/$n/**
                incubates strategies for
                $n being the future of $n
                which itself gets measured for complexity
                 of $k etc change
                 it making $n/$el=9/$k microbits etc
                  like the A:diff miles below this indentation
                  but already wrapped in individuation (one $n/$n)
                 so it is easy to draw it out,
                 producing X.** with a shape
                and places motile plans for changing what was (lv)
                 where sequence is a big clue, re el:8
                  and a bunch of impressions of sequence
                   might be looming around
                   like reading a random list (A:new),
                    noisily remembered from A:old
                    notice groups of loose|tight sequence
                    and when their order|direction changes
                    see 'have their $n in the others gappy order'
                 where order changes:
                  putting new at old
                   notice $n before|after $n factfluctuation
                   12, 23, 34, continuity buildup is good
                    would conduce when a $k is moving between $n
                     otherwise that ^
                     would have the $n swapping histories
                     to remain with $k-continuity
                  < &T substraction, break down into ...
                  sequence materialising somewhere
                   at &a q.seq=$seq
                    is seq eventually X.seq?
                    is it $seq/$X/$n?
                     each $X:old|new
                      have their $n in the others gappy order?
                       then x.n.$i to X:new.n.$i
                       form groups from pairs of $n in the same order
                        by simple x.n.$i+1 to X:new.n.$i+1
                         having the $i from $n, to put $i in X:new.n
                        ie $n:oldy&nexty&future == $n:new
                      might form $m - groups of $n in an order
                       suppose $n could mean bunch of $n:
                     
                     may calculate some facts: (see 'weigh')
                      $n/$fore:n or $n/$aft:n
                       $n < $n or $n > $n, list-wise
                      $n/hops/$n
                       $n crossing $n might happen|matter
                      $n/$distance/$n
                       looking for small distance
                       consider magnitude of fluctuation of distance
                       are we spraying pixels between bulbs?
                      $n/van/$n
                       neighbour change (lost|became $distance=1)
                       named for summer travels aspect
                      $n/neigh/$n
                       the nearest in any direction
                      for lazy:
                       evaluation, when io calls for it
                       calc for continuous groups $m
                        rather than $n
                       divisibility is a big thing
                       more $m in|amongst|over other $m:
                        given an error margin to group by
                         cell dividing before the error margin slopes right off
                          lum per $n
                     
                     delimiting bunches of $n (lv)
                      with the few $n we mention
                      could move the lot around
                      eg lv el:6...el:8
                       finding the $n for el:6 that begins it,
                        until the $n for el:8 being after it
                       new 'position implied'
                        usu after last el:8 etc
                        may nc&from=$xpath|$ks
                         which may be a part of lv** we are yet to wake
                         may correspondingly el:9 over there,
                          if further|slopier than some amount
                          this is like being introduced as from somewhere
                          that somewhere able to answer for your leaving
                      eg lv el:4
                       renamey, non-moving
                        eg X.$tv:n, changing an n.t or ny&cv
                       old 'position implied'
                        usu after last el:8 etc
                        may nc&renamed=$tv|$ks stringifiable
                         then we could move as well,
                          to the 'position implied'
                      so:
                       el:6 + el:4 (move and rename)
                       and making a 'position implied'
                        that resets or changes direction,
                        could be as simple as:
                         el:8 moves pointer back to that:
                         we el:4, el:8 to where it goes,
                          el:6 it there with that new name
                        each thing should rename only once
                         per parent el:8, which can be inflated
                          to get smooth layouts of sets of change
                  
              sort $n/$n guess
               at some point
               with weigh in it
                inc what has happened to the order
                lv-friendly cursoring or not could be fast to compute?
               should be most intelligent to each $n
               anything not perfectly divisible|reasoned should &T 
               
               and having already done that for the last $n,
                so sequencing may reacquire itself
                  q.seq also connected to $dome, Dome
                   so we can continue it
                   so could be super-&a
                  so:
                   < array diffs with moveless or identity economy
                   < Xio.lv $C $N alluded to
            
            so: ref easy, name(s)...
              finding $n usu same ref easy,
               may have to find ny&up=$n by the time X:old
               they can be checked while held in a dome etc
               they get lost every time they exists
               have to know a unique name for them
                perhaps X/$ks - a pile of autogen names for nodes
                 they could divide themselves by adding to their names
                  ~ what &brackology is supposed to display a field of
                 they could easily find themselves apart,
                  with a sequence number after envelope
               yet like linear sequences,
                would call a stream of them wanderable
               anyway
               we probably have x.z=$n still,
               or resolve $ks to an $n
                < or go by homology,
                 another dimension of similarities in deeper ..x sprung?
                 or sequence conservation
            also:
             resolving $n with a namechange is a big deal:
              must be preserved carefully across many X
               eg X:new/$reks
                recent|most-likely $ks that changed
                translating pointers of X:old
                 for e running late, get el:4 round trip, retry
                low priority
            
   //    rand + sum resolving $n
         rand
          from revoked imagination of:
           $h = a hypothetical /$n x
            they might h&commit at the end
            to be revealed at the end:
             soundscape of z|zh
              electric and gas
              the point the letter changes
               pronounces boundaries as sound disconuity
                whose country imports these
                 who takes the art home
          
          see X:new/$reks
          
          X:specialeffects extend:
            it could be bound to rewriting wholer chunks
             eg X:anI serving each $of from several index
            it could make an interspersal only
             pulling up facts on how they change order
          
          X:selfscape
            many of its parts taken together
            correlate to parts of other
            wide angle lense on morphology
          
          if you needed more name
           (unique stringable discernment of eg $n)
            see resolving $n
           and those names could include X** pointers,
            but dont|cant include X.n.$i,
           no enough entropy in X.**
            you would &T up the intensity of $n** -> X.**
              growing projections inside $n, of local types
              engaging possible introspection|expansion
             their detailings would all be subject to process etc
              being actual occasions
                    
               to split atoms by whatever is keyish()
                eg '%same,things:C' using X/$k=things$visC
                 providing the bool isC() to draw -brack@101
               # with a note on sequencing, X&ip
               
              cant find any index to 
               might be played upon in the chat room
                ie things you create similar to otherses,
                 appearing mergey with both codes trying to patch in
            
         sum resolving $n
          usu find one $n:old for each $n:new
           everything is lost and reappears
            cant trust /$n sequence
           X/$ks may do this if keys arent moving
            $ks has a few codified names for the thing (strings)
           X/$k|v can find+sort $n with most in common
          based simply on the ideal name for a thing
           $n == $n:old most ideal, native
           the enclosing X:osc/$n you are likely to encounter
          
         finding a match for $n
          happens while we ...
          try reasonable combinations of old<->new $n
          then pick the least X:diff-icult
            having its 
             for $n, as we have probably limited,
              find X:old/$n by X:both/$ks or etc
             then A:diff/$n arrives, where it always was
               ~ bless
               along with A:diff/$n/$was,
                about knowing a previous version of itself
            
            genera standards and 
            this pressumes light into places
             to be passing qualities between $n in its conscious mode
              the seeming cellular exchanges of %these
               and their depths and approximate shapes
               play identity swaps
              vectorial qualia like things
               make infinite fields of X:diff for C
          some spaces will have things to reset
           when boundary conditions on the k,v etc
      
   //    X:diff - proper &brackstill
         we have an X:old rebuilding to X:diff for $n**
           re-indexing C users might have altered
            you should e C alterations
             esp if A far away (like they notice)
            usu Dome_7 do so
             warn when cha surprise
              brack rows not supposd to change?
            everything should use a thing that X|A interacts
            ie you osc in remote things,
             change them,
             have changes returned
          
         compare thing for key|value of X.**
          making the standard X:diff
         alt xq.i(...) finds and compares X/$n|$k
          see resolving $n
          compares may be expressed with X.variations
           sets of meaning
            like &a Xq.t='brackdiff'
          X/$el=2/$ks
           meaning it got a name unique to it
          X/$el=3/$ks
           one of its names changed
          X/$el=3/$k
           one of its keys changed
            maybe independent, if renaming sc.*, to:
          X/$el=1/$v
           one of its values changed
          X/$el=9/$k
           vanishing keys, must have a values disappear?
          X/$el=9/$n
           vanishing $n
           X/$el=9/...
            has everything it had
          
         
          X:diff.* might become X:new
           at the end:
            backend replication of X.**
            grouped by $n
             making X:new/** come out in sequence
             though it is mostly X:old
           or even when you o for it
            X:new/$search/$Xpath = X:old|diff
            X:new entirely outsourcing content:
             X:old = entirely
             X:diff = the updates
           
   =cut
    # &ha el:1, &ja el:7 (this-time), &za|da el:8 (the-time)
    # &da should emit nearly lv
    # < &bracki|&bracko
    fi.a = &acgtscq{
        # may be &a,sc,c?,el
        s = peel(s)
        num(c) and c = {el:c}
        c = peel(c)
        num(q) and c.el = q; q = null
        q = peel(q)
        c.el ||= 1
        
        # s can be a row, pipelined
        isC(s) and s = {src:s}
        else
        # exts s as sc unless stated (+ others...)
        !s.sc and s = {sc:s}
        
        # s.sc ||= s.src.sc
        
        c.el <3 and fi&apprehension_1,s,c,q
        elsif (c.el == 3) {
            # < el:3 could src=$n, sc=changes?
            #   or with s.src|sc to change, s.new|diff|gone=sc
        }
        elsif (c.el > 6) {
            # looking for something
            q.rowt = 'looking'
        }
        else {
            # < el:9 would disaffect|disconnect u|n
            #   the pipe would know how fast different patches dry up
            #    if they hold water by sheer existence, etc
            #    output of a computation fading away
        }
        
        # have a row, even for questions
        $n = s.n = Cye([q.rowt||'abrack',1])
        n.sc = s.sc || {}
        
        # row pipelined around
        s.src and ny&up = s.src
        ny&brack = A
        # < does anything ny&R?
        ny&A = A
        T.act and ny&act = T.act
        
        c.el <3 and fi&apprehension_2,s,c,q
        
        # enter|rummage
        # < fi&oi,s,c,q ({i:brack}) develop a query with multiple mediums
        #   s,c,q making waves of conversions, for arks deduced from pi
        #   these are sc,c,y of course
        c.el <3 and fi&Xio,{i:'brack'},s,c,q; return n
        else fi&Xio,{o:'brack'},s,c,q; return q.N
    }
   // s.* for &a
    # < rename a_i_1, etc?
    fi.apprehension_1 = &acgtscq{
        s.shade && isst(s.shade) and s.shade = peel(s.shade)
        s.mix && isst(s.mix) and s.mix = peel(s.mix)
        
        if (s.src) {
            $src = s.src
            if (!s.sc) {
                $sc = s.sc = ex({},src.sc)
                # < retransmit only such classes of sc
                $mix = s.mix
                if (c.noeto || mix && mix.nodeial) {
                    mix and delete mix.nodeial
                    delete sc.efrom; delete sc.eto
                }
            }
            else {
                # < el:3 could src=$n, sc=changes?
                #   or with s.src|sc to change, s.new|diff|gone=sc
                throw "src+sc"
            }
        }
        
        q.rowt ||= 'apprehension'
    }
    fi.apprehension_2 = &acgtscq{
        $n = s.n
        # mix mix -> n.sc
        each kv s.mix {
            n.sc[k] = v
        }
        # mix shade -> n.sc for a while
        s.shade || s.src and me&brackshade,n,s.shade,s.src
        # < el:2 makes its %%dome not expect redo,
        #    can replace it into there, certainly if el:3
        #     curently only if s.src'd from a c&recycled one:
                # < indexes enough to conclude that it's that
        ns&dome and me&dome_bracki,j,n
    }
   
   // Xi brack
    # index n by n%*
    #  X/k/ref(s) enumerate columns and their values
    # ongoingly to index N-news into X
    fi.Xios.brack ||= {}
    fi.Xios.brack.i =
    fi.Xi.brack = &acgtXscq{
        # binds to q.Xt
        $qas = fi&qas,X,s,c,q
        
        # z all rows, in order
        $Xn = qas('n','z')
        
        # each .sc.$gk as a name had
        $Xk = qas('k','t')
         # all via different xo are to the same xo-space?
         $Xv = qas('v','s',{via:[Xk]})
        
        # < inflating an A with millions of 'string'.length
        $N = s.N
        N ||= s.n && [s.n]
        !N and throw 'brackin?'
        each in N {
            Xn.i({n},{n})
            each kv n.sc {
                # the keys
                $kx = Xk.i({k},{n})
                #$kx = me&X_t,X,k,n,'k'
                # have their values via unique id
                $vx = Xv.i({v},{n},kx)
                #me&X_s,kx,v,n,'v'
            }
            # all our t x.z/$n anded might lead us to similar sets
            # so will s, earlier use might get to know about later
            X.z && X.z.length > 1000 and throw "Giant brack",s
        }
        return X
    }
   // Xo brack
    =pod
     e
    =cut
    fi.Xios.brack.o =
    fi.Xo.brack = &acgtXscq{
        # s.n - u-ward, what has this as n
        # s.u - n-ward, what has this as u
        # are two types of row-row linkage,
        #  that don't require the row to know %%n anymore?
        
        
    }
    
  // &qas enters|uses an X schematic for &Xio for $Xqt
   =pod &qas,...context -> qas(..schema) -> qis(..bits)
     ' entering an X schematic
     when the thing is as vague as it gets
     windows of noise manager
     traces of unique identity are named:
    X.Xq.$t = Xq
     Xq knows about ways into X:
    Xq.has.$k = xq
     xq describes index at X.$k
     xq.depth ||= 1, eg X.k.$scgk = x
     explicit notice of plurals
       eg X.ref refers to X.refs
      and other contrivances|hierarchies
     so we can find all $n in an X
      for generalised what-is-here
     and it may stage|re-stage changes
      el:2 or el:3 modes
     
     X itself is universal,
      names, keys and values (&X_refer) index between X..x
      many of them at once
      may converge on the same x.z.* via many paths
       < changing the set of columns per coherent set (&brackology2)
         tree-like thing, adding y&... walking
      puts its self-knowledge under X.Xq
       < once X is C, X.sc=X, X.c=X.Xq?
         so any X.c.*.has are Xq, else other c.*?
         then X.sc.t|y|c|sc.* are about some C.sc.* existing
          without isC(X.sc), since isC(X)
          so we can have C-like indexes
         since any keys, including C nks,
          can be used as the something
          the only place to not mistake 
          and X.sc wouldnt be mistaken for a CX can then know X.y|c|sc without being mistaken
      may have hooks, input handlers
       could affect anything, starting from X
        to get to the voicings
       notice them in X.*:
        X.ih=C for &nodei etc instructions
         how to clone|construct given C
        X.e (or y&A&X&e-ward from anywhere)
         est. elvising here
          &n may autovivify them
          eg bringing %ope etc
          can pointer to un-A|C-ed space,
           using whatever X.* the thing is in,
           leading through many layers of X
         staging changes to things
         is 
     Xq  per high level indexing org (Xq)
     xq  per index at X.*, how to get to x
     x   at the end of the index,
       having a bunch of values pile up there
     
     guide to X..x, and what x.z is, etc
      < conflict with structure|names already there,
        separate A to forward rename
     
     
      devolved to limbs they used to work with
      fear & greed controlling the world
      escaping the reality through intoxicating substances
      the main audience is 18-29 year olds
      so they can get involved in the projects
      an eye opener
      a situation with a way out
      to set up an animation studio
      low key independent 
     '
   =cut
    # est org at X.Xq.$Xqt = Xq
    #   for highlevel $stru-cture sharing (Xq)
    #  Xq.has.$k = xq, about X.$k
    # returns an xq creator with Xq context
    #  
    #  observe|comply to parameters of the index
    
    fi.qas = &acgtXscq{
        X.Xq ||= {}
        !q.Xq.t and throw "!q.Xq.t"
        $Xq = X.Xq[q.Xq.t] ||= {}
        Xq.t = q.Xq.t
        Xq.has ||= {}
        # < Xq beyond just {t:'brack',has:...}
        hak(q.Xq) > 1 and throw "&qas...q.Xq.* instruction"
        q.Xq = Xq
        Xq.up = X
        # may bump into e pointers from here
        # A.1.Te%catch.A.Xqt[Xq.t]
        #  which we would then go and find out more about
        #  every time we begin to ... at X space
        # pointering Te to things begins with the Xq we found it in
        #  probably finds the attachment type satisfied
        #   by a higher level connection|trigger than Xqt
        #    eg &ha would Te%catch.h.ha = Tq
        #     Tq then has indexing matching $n
        #   be used to notice how many whats are going on
        return &hue{
            # already inside Xq.t, eg 'brack'
            #  h.t -> u.t, X.$xqt base name for index bits
            #  u.t -> u.type, &X_$type index building function
            # both are required
            isst(h) and h = {t:h}
            isst(u) and u = {type:u}
            # hu are cq, for Xq+xq
            u.t && h.t and debugger
            u.t = delete h.t
            !u.t and throw "qas()!u.t"
            !u.type and throw "qas()!u.type"
            
            # some culture|habit can org there
            Xq.has ||= {}
            $xq = Xq.has[u.t] ||= {}
            xq.Xq && xq.Xq != Xq and debugger
            xq.t && xq.t != u.t and debugger
            xq.Xq = Xq
            xq.up = X
            # < find same xq.t amongst Xq.t
            # < hook up data smush patterns|memory for these *->u->xq
            
            # xq.type may be known, may compose many?
            # isfu(is) made more complex if %Te wants
            $is = fi.xqtypes[u.type]
            is and ex(u,is)
            
            # e more for xq
            if (e)
                ex(u,peel(e))
            
            # array merging, for Xq.via
            # < immutables: mex() q.ek, etc
            mex(xq,u)
            mex(Xq,h)
            
            # compute how it is
            # xq.sc - ordered hash of arks,
            #  to qis() s.sc, which may then be out of order
            isst(xq.sc) and xq.sc = peel(xq.sc)
            # xq.N - list of arks
            xq.N and xq.sc = hashkv(xq.N)
            # usual depth of one, must be keyed by xq.t
            xq.sc ||= hashkv(xq.t)
            xq.d = hak(xq.sc)
            !xq.d and throw "no size for xq:"+xq.t
            
            # value entry
            # at Xq+xq, micro to the &Xint|out s|c|q
            $o = {Xq,xq,s,c,q}
            xq.i = &scx{
                return fi&qis,X,o,s,c,x
            }
            
            return xq
        }
    }
    
    # what can be known about fi.Xf.t|s|z
    #  mix xq.* for xq.type
    #  xq.hashy|array - index material
    #   length of ^ based on:
    #  xq.sc - what qis(s.$k) (arks) to want
    #   default s[xq.t], eg s.t=$t
    #  xq.refers
    fi.xqtypes ||= {}
    fi.xqtypes.t = {hashy:1}
    fi.xqtypes.s = {array:1,refers:1}
    fi.xqtypes.z = {array:1,selfin:'multix'}
    
  // &qis climbs X for $s for $xq, doing $c
    =pod qis(..bits)
         supplied arks as s.sc is io usual
          doing without the odd one should work
          having the index in a few shapes
          so a row can have gaps, wildcarded at x|X
           eg S Rhythm o $had/$hadnt/$has, when we can find had and has
            since X space isnt singular,
             we may be climbing two structures towards each other
              as in KnowThee
              where nesting io expressions (in|from eg S o ...)
              pull things towards each other for zapping to bits
               in X:Rhythm (re-selecting)
                X for rows forming,
                finding x (real or wild, here or there)
                 for some vectors of climb+exp
                having vectors of Xspaces involved
                  and other qualities like %mot, %may:el2
                of the solving branches
                of many parallel X..x (via loop, on $q?)
                 in rows,
                  which is expected to perceive 4d
                  X:Rhythm joining x:Match to maybe x:Found
                   it having no $hadnt x:Found ranks in x:Match
                    not-iterating, unless e handler for:
                     the few io exp in an S exp make a schema
                     it may have a sub-S to handle low-matches
                     or simply &nodei %%may:el2 for simple
                     or emit %mot:2 across that S exp of schema,
                      to whatever is almost connected to a possible $hadnt
                       leading to more possible %mot:2 desirees
                     so the S exp
                      made of io exp
                       arks|thingnesses are from params or other io exp
                       and how they relate. thus, networking
              
              X:Rhythm
               keeps track of any warp,
                such would slow the process for e introbility
                sorting by well-sorted-ness usually,
                 and what that sorting is
                as it makes X.. -> rows for io
                a process similar to:
               some x could include other x
                alt .. of X..x
                 perhaps into|with an other X|A|J also,
                 bringing an X into a %mot-or
                shuffling the fronds:
               
               X..$xy/$x connects another X..$x to there
                ie xy.z/$x, as opposed to $n
                 meta X.xqy[xy.t] = $xo
                  $xo informing of:
                   $xy having $x separating from its origin
                   how $xy differs to a normal $x
                   ie xo.zis='x' means xy.z/$x
                    all x having z index to the real item
                    might involve replacing all [old_x+] with [new_x+]
                   < have|index where clauses for the found $x(.z/$n, etc)
                 and|or:
                 meta X.xepart..$xo,$xy,$x for more complex vec
                  $xo must track places $x propagates into $xy
                   could be along X..$xy.. somehow
                  could leave the X|A|J
                   with &e facilitating wiring to versions, downstreaming
                   very any-pointey:
                    could be relating to multiple others
                     with ways in between, leading out, etc ad inf
                 so
                 you can call in your X.xqy mind if you detect any of that
                  eg to simply delete downstream x-propagations
                   may slow to examine X..$xy
                   an xy may contain weighty evidence etc
                
                seems usey for condensing %Te pointers to those x
                 by ..xy, tussled until consistent
                 knowing xy.xq is how we coord our selection of it,
                 xy.up=X=x.up
                 x.xq is how they coord themselves,
                  which we would get interested in
                 might have some traces of processes involved, why not.
                  they may be findable via x they leave around...
                 eg
                 so X.t.$t = x, x.z/$n
                  is primary (C.t index)
                  the x.up=X and x.xq describes X..x
                 so X.allx.$i = $xy, xy.z/$x = X.t.$t
                  following an x entails el:9 when+how etc
                   by some protocols gathering on x by xq
                    the various "collecting", "breakdown-of" set order
                   and being able to restate those chunks of spacetime,
                    through the time+name system
                    from the X perspective,
                     and across the network with other objects (&Supe*)
                      that are making %mot:2 etc
                     tracing its will to do anything.
                  complementary legs
                 so X.allX.$Xi.allx.$xi (two xq.type=s) also
                  for X knowing another X contains x
                   X&A and x&A can slope around
                   how to follow through time,
                    X living longer than x it knows about
                  the downstreams could be pointed to,
                   given a storable climbing-X|A exp,
                   with snapshots, many-X-shaped diff making...
                 
                 these could point further, have more index(s):
                  many X.** include various properties to X
                   eg having rows to include at some distance into X
                    eg x:wild, hops multitudes across gaps
                   eg do hooks, where|when they are located
                    their locationing becoming more specific
                   eg alternative views through schemas
                    of rows rearranged from main thing of X.*
                    very one-many spaces
                  constellations of X.**, cluster to put separate:
                   relatings to rowlegness|reason|positions
                    of more of these X.** structures
                     eg X.leg/t/$t/$xb.ness/'rowleg'/$xc
                      leg specifies eg the rowleg-ness, for row-smush
                       is for X.t/$t/$xa, has all the intent in $xc
                        which may not include any r (smush-config)
                       just to inflate to $xb gets us $xa,
                        $xb.reason, simple or complex: to $n:D joining this
                        $xb.positions of $xc involved, maybe classes in between
                        $xb.voicing of anything climbable with &voice
                        $xb.ioing of A&op - should from A:S climb into
                         the io exp and any state a downstream io might pry
                    so, having those qualities on a thing,
                     generated by the matching in io
                     that relates to where|how the match happens
                    and indexing some of them,
                     splitting up by desired uniqueness
                      usually to speed up or compress information
                  to become notions of light (x.r+)
                   travelling through space (X..x)
                   to be retracted from a downstream, eg X:Rhythmatics
                    at the &Xout el:9 level?
                     hooks would bring it up
                  
                waves become nested:
                 short lists of $very/$specific/$mediation/$before/$thing
                 become long lists of $vague/$pile/$thing
                   X.fqdn>2name>1name
                    verbosities for calling uniq items by attributes
                   X.tv>tw, tv>z
                    for which index can deduplicate others
                 
                 correlating variations on the path:
                  to thing, x.z/$n
                   $n (row) may be in many x
                    per its traces of stuff in Xspace
                  to complement,
                   eg X.align.abc.ac looking at Xspaces (rowspace?) to align
                    X.abc is a longer trip than X.ac
                     X.ac..x might talk about X.a that are binding to X.c,
                      with x.$clue for finding X.a|c,
                       selecting within them and imposing anything to u|n there
                       an ongoing theme, this ^
                     X.abc could be that relating through time?
                      has an as-time and through-time element|X-ness:
                       having proxima (types of nearness, quantified)
                       modulating, graph labeling over local extent
                     adding dimensions|layers of X perceiving X+
                   that there is a meaning possible
                    to be believed in
                    eg X.dome[r%dome].z/$n partitions $n elsewhere
                     making groupable how they are available through X.*
                     by aft-X..x filtering of x.z
                     this maybe-$n, ever-$x awareness
                      must line up with:
                       eg expecting to find history for structures
                        we have started taking apart or replacing
                        ie at what point do your limbs dreams
                         stop getting implanted in the over-limb
                   being equated|aligned and
                    what it is to mean is a whole other X
                  X..x being varying lengths
                   and qualities to A
                   bunches of it being grabbed at:
                  %dome recycles $whole X and replaces a $part of it
                   the old $part going somewhat offline
                    via our A and its new X perspective on what is at $whole
                    only available in certain senses once dome begins,
                     to those wanting to remember what it was
                   pushing stitched up X:$whole
                    A harvester
                   < generalise from per-n%dome
                     eg x** cursoring any areas of X.** we are to re-get
                     a where clause
                   $whole is like a git tree
                   its index contains all $parts
                   some being supplanted by newer $parts
                    existence of newer $parts comes via A
                     usu r%dome specifies which ..$parts are being stated into
                     having previous $whole..$parts to work from
                     being able to CRUD individual $parts..$part
                      as in lv, yet X.**-arbitrarily
                    being able or willing to CRUD X:
                     redo $whole for $parts (new X..x hashes)
                     delete $whole/$parts (X.. tidied)
                    depending on mergibility (Dome@3)
                   you must figure that by some x.z/$n being %domed 
                    and knowing its a certain X..x from before,
                     possibly amongst a set of dupes (hak(x.z)>1)
                      that arent duping anymore (due to sleepy processing)
                     what gets you into sleepy processing
                      ie C-pointing $part to adjust
                      must also say only that $part of $parts changes
                       more developing needed when T.dup
                       may be A:e to a name that is now a plurality
                       convention to leave the first one,
                        or does name@1 split into name@11,name@12
                   anyway, can redo parts of X..
                    for given pointer|ranges,
                     which become|avoid ambiguity
                 that seems to be including space we can re-include...
                 and when|how to propagate &Xout el:9
              
              the bits being the found things between X..x
               always broken down by thingnesses we can string up
               at the end of each rigid geometry thinger X..x
                x is coorded already, is itself, how it is coorded
                x.up = X
                x.X = x.top = X
                 a degree of slope (climb x.top)
                x.xq = xq = X.Xq.*.has.$xqt
                 xq.Xq = Xq = X.Xq.$Xqt
                 are the &Xstru and &Xthe x was created in
                 include some more index
                x.z are things here [r+]
                 these may provide an insider r&A?&X to mount r/*
                 eg J, having a commit X + X it might build + etc 
                  things may keep rowing from inside and out
                   forming with each other a diff pattern
                   might be T-d apart and together
                x.* (knowing x.Qt)
                are things in an x coordinated as above,
                 as distinct from ways to 
             we may %mot to el:2 the $hadnt
            
            x:had.wild.not = x:wild
             x:wild knowing pa.t=hadnt is not found
              track other x:wild from other $had (multix)
             onwards:
              x:wild.xs = [x:has]
           
           x..x:wild are things that break the type system of x
            yet include further Xspace anyway
            x:wild.t usu null|undef, may error code, have qua
             relatively against match for some reason,
              < indexed by reason, eg X.not_quite_sc.$scgk.$dist
                with the amount off.
                 these could be el-ish,
                  may compute from from several sc|etc
                   so it seems some y() -> ..x-positions
                    form the registers
                 or quanta, distance between
                to search for a blip of sound with such size|qua
                which we may then transcend the problem with,
                 by fading into another sound in the same key, etc
             how you can keep going is interesting
              usu relates to an el:2-ability being inferred
              what is needed to create, %feature magnets
             usu negate iteration through S o ...
              yet it may have a sense for whats going on
              S seeds the ways into creation
           to be able to have rows joining to rows,
            aligning or guessing through the index
          
         the thing arrives
               it could be stated as an emptiness (el:5?)
            which you mix into rows X
            at wildcarded X|x, row  the gap to yonder columns
             and mix in x as x-row selection,
              meta that the column 
           that you classify your way into,
            and mergeselect your way out of
           might often return the nearest selection to something
    =cut
    # context: Xk.i({t},{n})
    #  s.sc.$key=$value, along X..x, only ark usu xq.t
    #  c.n is what to est there
    # off the end of $x if provided
    #  is s.x, separate since s.* scooped into s.sc.*
    fi.qis = &acgtXoscx{
        $xq = o.xq
        s ||= {}
        c ||= {}
        # s.N might be either if array
        isar(s) and s = {N:s}
        else
        isar(c) and s.N = c; c = {}
        else
        # scoops s.* into s.sc.* if vague
        !s.N && !s.sc and s = {sc:s}
        # s.x = x to x..x
        x and s.x = x
        # s gets us there, c arrives with...
        
        $depth = xq.d
        $keys = xq.N || haks(xq.sc)
        s.N && s.N.length != keys.length and throw "key length"
        
        # while xq belongs to X,
        #  our notion of Xspace (where to build X.*)
        #  is subject to starting at $x,
        #   and xq.via.includes(x.xq)
        if (s.x) {
            $x = s.x
            !x.xq || !x.z and throw "s.x !x"
            !xq.via.includes(x.xq) and throw "s.x not via "+xq.t,{x,xq}
            $Xspace = x
        }
        else {
            $Xspace = X
        }
        # by name
        $index = Xspace[xq.t] ||= xq.array ? [] : {}
        $nx = index
        # the housing thinks everything is a key
        each ik keys {
            xq.N && s.N and $key = s.N[i]
            else
            s.sc and $key = s.sc[k]
            else {
                throw "qis() s.* vague", s
            }
            if (xq.array) {
                # array allows keying by values, may uniquely
                $value = key
                nx != index and throw "array d>1"
                # mirror eg xq.t='ref'
                #  X.ref[vi]=x <-> X.refs[vi]=s
                $refst = oneor(xq,'refers', xq.t+'s')
                $refs = Xspace[refst] ||= []
                # corresponding array to hold x per value
                # < should probably index={refs[v+]<->ref[x+]}
                #   other array schemes|tools might live there
                $is = refs.indexOf(value)
                if (xq.refers && is >= 0) {
                    # uniquely, find same x
                    $vi = is
                }
                else {
                    # repeat, new x
                    $vi = refs.push(value)-1
                }
                $nex = nx[vi] ||= {}
                nx = nex
                
                # link many x by value
                if (is >= 0 && is < vi) {
                    $ox = nx[is]
                    # share array of same-valued x
                    # usu must join X.** with point-nested pointers
                    x.multix =
                    ox.multix ||= [ox]
                    x.multix.push(x)
                }
            }
            else {
                # may travel multiple layers of hashes
                !iskeyish(key) and throw "keying !string"
                $nex = nx[key] ||= {}
            }
            typeof nex != 'object' and throw "X{!object", {xq,i,key,keys,nx,nex}
            nx = nex
        }
        
        $x = nx
        # always:
        x.z ||= []
        x.up && x.up != Xspace and throw "x.up ~"
        x.xq && x.xq != xq and throw "x.xq ~"
        # < x.top? of a group of dimensiona
        x.up = Xspace
        x.xq = xq
        xq.lastq = q
        
        # magic relationising atoms (C)
        c.n and x.z.push(c.n)
        else {
            throw "no qis c to put"
        }
        
        # some x.t.$t.x.t.$t, which is 2* d=1
        #  carry on from x nowish, while playing loop with others
        #  indexing for things connected in this way and others
        #  here is where we climb X..x*..X between As
        #  and need to hang up a line to be able to call them back
        #  ie the self|other task
        return x
    }
  
  // &X_t|s|z lowlevels
      =write or read (autovivificatorialy)
        X.$someindex ||= x += $n
       leading to x, another|inside X via $someindex
       x remembering what indexes it is in?
        joins|varies by x.z/r,
         the members being added to x locatable space
      =cut 
        
        # the X/$t += r
        # t must be string, r could be anything
        # in &RbitXarrive it is R, &brackX it is a row
        fi.X_t = &acgtXtrk{
            k ||= 't'
            X[k] ||= {}
            
            $x = X[k][t] ||= {};
            x.z ||= [];
            r && x.z.push(r)
            return x
        }
        # the X/uniq($s) += r
        fi.X_s = &acgtXsr,kf,kfs{
            kf ||= 's'
            kfs ||= kf+'s'
            # by id of the value
            $fs = X[kfs] ||= [];
            $vi = fs.indexOf(s);
            vi < 0 and vi = fs.push(s)-1
            $f = X[kf] ||= {};
            $x = f[vi] ||= {};
            x.z ||= [];
            r && x.z.push(r);
            return x
        }
        # the X/$s += r, $s repeatable
        #  no x will have more than one r
        fi.X_z = &acgtXsr,kf,kfs{
            # to avoid conflict with x.z
            kf ||= 'lizt'
            kfs ||= kf+'s'
            # by id of the value, each time it occurs
            $fs = X[kfs] ||= []
            $vi = fs.push(s)-1
            $f = X[kf] ||= {};
            $x = f[vi] ||= {};
            # each x knows the others
            # looser matches for others may be done above
            $is = fs.indexOf(s)
            if (is < vi) {
                $ox = f[is]
                # usu must join X.** with point-nested pointers
                x.multix =
                ox.multix ||= [ox]
                x.multix.push(x)
            }
            x.z ||= [];
            r && x.z.push(r);
            return x
        }
        
  // tues

# < see Bscape
fi&live,1

# use this to serve &t

n t  s:vefge
n t 3 s:brackets
n enee 3 s:brackets

