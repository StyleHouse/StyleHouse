# A emixer!!!!3131
$fi = self.fi = {}
# &Xio uses mediums and with i|o|etc
fi.Xios ||= {}
 
 // f
    self.isA = &A{
        return A && A.c && A.sc
            && (A.y && A.y.A == A || A.y == A)
    }
    self.isJ = &J{
        return isA(J) && J.1 == J
    }
    # all values set to 1
    # < rename ksaf ksat?
    self.allone = &sc{
        !isob(s) and throw "allone!hash"
        c and throw "< ksaf"
        return hashkv(haks(s))
    }
    # < make uniq()
    self.uniqe = &Nc{
        c ||= {}
        isfu(c) and c.y = c
        c.map and c.y = c.map
        arrefs(c)
        each iv N {
            $bit = c.y ? c.y (v) : v
            c.addref(bit,v)
        }
        # 
        # in order of appearance
        # {bit:[v+]+} - must iskeyish(bit)
        return c.map ? hashkv(c.ref.map((l,i) => [c.refs[i],l]))
            # [[v+]+]
            : c.all ? c.ref
            # reduced to first: [v+]
            : c.ref.map(l => l[0])
    }
    # see 'arrefs'
    # organise many v by bit (may be object)
    self.arrefs = &c{
        c ||= {}
        c.ref = []
        c.refs = []
        c.addref = &bit,v{
            $mi = c.refs.indexOf(bit)
            mi < 0 and $first = 1; mi = c.refs.push(bit)-1
            $l = c.ref[mi] ||= []
            l.push(v)
            return first
        }
        c.maprefs = &y{
            c.ref.map((l,i) => y(c.refs[i],l))
        }
        return c
    }
 
// A
    =pod
     just creation
     whatever it takes to load the rest of the fish
      there is a microfish inside:
       &Xsim co prototype &Xio
        to merge when both testable
     plenty of let go
     runny types of A|C
     &A create+wind?
       if too other to wind
        create to merge later (e)
       
       
       
       widely used self|othering portal:
         A self|other creation|winding
          self - inside the A we are now (V)
          other - outside V**/A or V.1 == A.1
          creation - spawn A
          winding - which &voice to c.ov
         &voices separately?
         args are ...
          &A,Y,{ov:3} - wind another
          &A,{ov:3} - wind self
          &A,{import:1},{ov:3} - wind self
           and acquire A.sc.import?
          &A,3,{t:'floor'} - wind self
           and acquire A&t = $mind_to_voice
          &A,C,'n' - create Cy&A, A&t = 'n'
    =cut
 // &A
  // &A
    fi.A = &acgtV{
        V ||= A
        !isA(V) and throw "!A"
        $A = ex({},V)
        A.y = A
        A.up = V
        A.c = {}
        A.sc = {}
        
        # incremental
        A&ip = [...(Vc&ip||[])]
        Vc&ipi ||= 0
        A&ip.push(Vc&ipi++)
        A&sip = A&ip.join(' ')
        
        return A
    }
    # make A and arrive $At
    fi.Atsomewhere = &acgtAt{
        A = fi&At,t
        !A.up.up and ac(A.up,'z',A)
        fi&Ariv,{}
        return A
    }
   
  // etc, &J
    fi.Atopleast = &acgt{
        $Y = A
        $A = {t:'top',c:{},sc:{}}
        if (Y) {
            A.7 = Y.7
            #A.4 = Y.4
        }
        A.y = A
        A.top = A
        
        $A = fi&At,'least'
        delete A.up
        A&X = {A}
        # it would usually 
        A&again = &{
            A&V = A&X
            A&X = {A}
        }
        return A
    }
    fi.AtopJ = &acgtAt{
        # make J:Four
        $J = fi&At,t||'Four'
        
        J.1 = J.2 = J.3 = J.4 = J
        A.1 = A.2 = A.3 = A.4 = J
        return J
    }
    
    fi.AtJ = &acgtAt{
        # acquire J:Four...J:$t
        $J = fi&At,t||'Three'
        # have A needing? commit
        return J
    }
   
  // &At, &Ariv, &had Xsim
    # as above with c -> A.t, A.c.*
    # < pronounced acgtivic. extra intellectual suffixualism
    fi.At = &acgtVc{
        !isA(V) and c = V; V = null
        $A = fi&A,V
        isst(c) and c = {t:c}
        c.t and A.t = delete c.t
        ex(A.c,c)
        A&X = {A}
        return A
    }
    # Ac&b = old life
    fi.Ariv = &acgtc{
        $b = fi&had,pex(c,{At:A.t}),{n:A}
        !b and return
        A&b = b
        !bc&X and return
        # V(iew) meaning readonly
        #  may be limiting a plumbed actual last A&X
        #  also may many potential b
        #   waiting for further match
        A&V = bc&X
    }
    # i Y&X/$At/$n:A
    # o Y&V/$At/$n:b
    # < and the plurality of before+now
    #   b may not match only on sequence
    fi.had = &acgtsc{
        $Y = A.up
        
        $Neu =
        fi&Xsim,Y,'X',[],s,c
        fi&Xsim,A,'X',['had'],s,c
        $Nld =
        fi&Xsim,Y,'V',[],s,{}
        
        $sequence = Neu.length - 1
        $b = Nld[sequence]
        return b
    }
  
 // &X*
  // Q
   // Q action
    fi.AoQ = &acgtAQq{
        q ||= {}
        $oftN = fi&Xsomp,A,Q.c,{},q
        # < shades of uniq() by .n
        #   they may|not have believe/...
        #   no telling which of/t/n were there
        #    before|after of/t/believe/... was attached
        #     might x/$near:n/believe
        #      a x/$n-aligned map of other places with /$n
        #      which would reveal that one of these was async
        oftN = uniqe(oftN, xc => xc.n)
        # < notice if uniq by r.x
        # if we dont uniq by r.n,
        #  we find the same /believe... for each (two) of/t/n
        oftN.map(&xc,{
            # if got via &Ath, these xc.n=Q
            xc.N = fi&believeoQ,xc.x,0,{rows:1},q
        })
        return oftN
    }
    fi.AiQ = &acgtAQq{
        q ||= {}
        # wantedness /$of+$t
        $oftx = fi&Xsimp,A,Q.c,{},q
        # become latest /believe/.../$Q
        $belx = fi&believeiQ,oftx,0,Q,q
    }
    
   // Q believe-ish Xsim
    # look up believe/src/version/$Q
    # sort by believe/$Q, usu return latest one
    # see Attendance: 'to order $Q over any $src|$version'
    fi.believeoQ = &acgtxscq{
        q ||= {}
        s ||= fi&Qbel,0,q
        c ||= {}
        # wildcarding hash slice, usu believe:1 anyway
        $first = hashkv(haks(s)[0])
        
        fi&bug,'bel-somp' and $un = fi&ibug,'somp'
            $N = fi&Xsomp,x,s,{norder:first}
        un && un()
        
        c.rows and return N
        $xc = N.pop()
        c.row and return xc
        # Q
        return xc.n
    }
    fi.believeiQ = &acgtxsQq{
        q ||= {}
        s ||= fi&Qbel,Q,q
        $first = sex({},s,haks(s)[0])
        fi&Xsimp,x,first,{n:Q}
        return fi&Xsimp,x,s,{n:Q}
    }
   
  // Xsomp middle
    # 1-spheres in X..
    fi.Xsimp = &acgtXscq{
        c ||= {}
        # X..x..x..x is long,
        #  X..x + X..x + X..x is wide
        c.long = 1
        # without t=[], X.$k as each s.$k
        $x = fi&Xsim,X,'X',[],s,c,q
        return x
    }
    # rowing arks, returns [r+]
    #  simpler (no arrefs, qas...) prototype of Xio
    # < rename xc r, have r.sc for arkv, rc&io=o
    fi.Xsomp = &acgtXscq{
        c ||= {}
        c.long = 1
        q ||= {}
        $N = [X]
        $arkN = [{}]
        $ks = haks(s)
        while (ks.length) {
            $k = ks.shift()
            $v = s [k]
            v == 1 and c.wild = k
            else delete c.wild
            $M = []
            $arkM = []
            each ix N {
                $arkx = arkN[i]
                !arkx and debugger
                # each possible x continued along path
                fi&bug,'somp' and debugger
                $vx = fi&Xsim,x,'X',[],hashkv(k,v),c,q
                if (!vx) {
                    # doesnt x/$k:v...
                    continue
                }
                # non-wild completes path into point (x)
                !c.wild and vx = hashkv(v,vx)
                # always X|x.$k(.$v=$x)+
                each vx vx {
                    $arkv = ex({},arkx,hashkv(k,v))
                    # also each x on the way
                    arkv.arkx = ex({},arkv.arkx||{})
                    arkv.arkx[k] = x
                    M.push(x)
                    arkM.push(arkv)
                }
            }
            # tos become froms
            N = M
            arkN = arkM
            !N.length and return []
        }
        
        # arks + final x from eg x/$src/$version(/$n)?
        $M = []
        each ix N {
            $arkx = arkN[i]
            !arkx and debugger
            each in x.z {
                # eg {src,version,n,x}+
                $xc = ex({},arkx,{n,x})
                M.push(xc)
            }
        }
        N = M
        
        # order the single expanse of rows
        c.norder and N = fi&Nxcnorder,N,c
        
        return N
    }
    # order a single expanse of rows
    #  higher(/$n)/$over/$other/$n (over turns out to mean later)
    # < rename xc r, so Nr?
    fi.Nxcnorder = &acgtNc{
        !c.norder and throw "!c.norder"
        $M = []
        # each believe (xords) has many /... (xordz)
        $xords = []
        $xordz = []
        each kv c.norder {
            each i,xc N {
                $xord = xc.arkx[k]
                !xord and continue
                $xi = xords.indexOf(xord)
                xi < 0 and xi = xords.push(xord)
                xordz[xi] ||= []
                xordz[xi].push(xc)
            }
        }
        !hak(xords) and throw "!norder"
        each ix xords {
            # in the order of believe/$n
            
            $norder = (x.z||[]).slice().reverse()
            $xcorder = (xordz[i]||[]).slice().reverse()
            $inside = []
            each in norder {
                each i,xc xcorder {
                    # suck out believe/.../$n rows
                    xc.n != n and continue
                    inside.push(xc)
                }
            }
            # starts from the end|newest, which matter more
            each i,xc inside {
                M.includes(xc) and throw "test multiple q.norder.*"
                M.unshift(xc)
            }
        }
        # any not in believe/$n, meaning very historic?
        #  see $n...$n gc
        N.filter(xc => !M.includes(xc)).reverse()
            .map(xc => M.unshift(xc))
        return M
    }
    
  // Xsim back
    # 2-sphere, in k='X' named|after t=[...]
    fi.Xsim = &acgtXktscq{
        isA(X) and X = X.c[k] ||= {A:X}
        c ||= {}
        $N = []
        $lak = haks(s).slice(-1)[0]
        each kv s {
            
            $ok = typeof v == 'string' || typeof v == 'number'
            !ok and throw "Xsim!string:",k,s,c
            # long builds x..x
            $hs = c.long && x || X
            $ux = hs
            # t keys X.[ex.tra.lev.els]...$s/
            each il t {
                hs = hs[l] ||= {}
            }
            # X|x.had is usually here, is arks for &qis:
            #  to make it seem: x.had.have = {k,v}
            #   grepping for $n in: x.had.have.k.v=x
            #q and hs[k] = v; continue
            $vs = hs[k] ||= {}
            c.wild == k and return vs
            $x = vs[v] ||= {}
            x.z ||= []
            x.up ||= ux
            x.up != ux and throw "xup!X"
            
            # long puts only the final ..x/$n
            c.long && lak != k and continue
            c.n and x.z.push(c.n)
            N.push(x)
        }
        c.long && N.length > 1 and debugger
        c.long and return N[0]
        # $n:A at everything we s.*
        # < used for brack
        return fi&xzand,N
    }
    fi.xzand = &acgtN{
        $M = []
        each ix N {
            each ii,v x.z {
                others: if ('others') {
                    each iii,xn N {
                        !xn.z.includes(v) and break others
                    }
                    # in all the others
                    !M.includes(v) and M.push(v)
                }
            }
            # its in all the others
        }
        return M
    }
 
 // live
    =pod
      A:n arrive, $At with $Ct
       maintaining a path to things
        through osc - which may rename|route them
         eg e:more@BakedGoods -> e:again@Bakery
      A:J hold A, wait completion
       in J&X, the last 5-min|30 changes hang in $At+$sip etc,
        including (up to 15?) A for the future
        these might redo from $C pointers
         discarding unfinished A each time, until done sync
          eg so A.4 &t loads can get back to it,
           yet having fresh A:n experience when ready
        wanting to merge together e**?
        may be mutex if changing same data
         same data: probably grouped by $n
         return to senders to ffwd if ~situation since e
       
       they A.1.up = A.2, a parallel A fall
       the up-most A to est A.1 = someJ is JA, usu A:n c&J|W
        osc puts J%top = C&A:n
       so:
        &t of=res,t=thing
         comes from a $dome, etc of some J&X..$A
       giving us pointers to relive for new &t input
        (opo. more &t input, an interation)
       causing osc to zip things together efficiently
      
      so using this to trace &t
       sidenote: species of &t:
         &Jt t=given looks around A^^<3, also of:J ($Jt?), or die
          roughly equivalent to &Jx, with a name patchbay
       what you &t
        must relay onto A.1-5 if from|to A.5
        eg 1c&X/$dome/$Ct/$pip+$At/..$t/$A
         $dome|$Ct may none-many, any order
          $dome is basically a C that melts
           merging insides to outsides
          $Ct name C we can focus on, merge into $dome
           climbing through A:n with c&e is like %tunneling
            but they can also ~wake up on the way
            so we may be able to re-A:n deeply
             with an early copy of the C
             or simply by the enclosing Y:n regenerating many A:n,
              which we then focus on a $Ct of
               as e:points do now:
                for a trail of $Ct-ish up to the last J
                 or was it last W? think so. not very fine
                R are a lot more controlled,
                 their "early copy of the C" are &reaw R.sc gk
                  to copy from a completed R to a new one
            the A:n**
             coming together, recycled or new
             ~wake up to do tractioning
              eg updating group tallies when A:n/** added to
             which leads into osc
              which reapplies the same theories
         $pip+$At tries to get to an A
          may be for interests sake
           which turns out to be important for debug
          may be warn if changing
           perhaps we dont understand what we are doing
            eg bunch of the A we want to use didnt turn up in Y&X.aye
            and should dev more $dome-ish A-separation
          usu redo deepest .../$Ct**
           may be taught to find $Ct/...$etc**,
           supposing its pipe to osc is usable
            ie we may use the ground for nothing but namespace
             taking no further work
              unless you are the particular $etc
             then patch everything into
              a directed reimagining (osc)
        
        usu redo deepest .../$Ct**
          then re-$dome
           may have A:n process to carry on,
            which would be able to osc%defer
          which leads into osc
           which reapplies the same theories
           re-osc 1
        
        osc%defer
          A:n** unable to complete
           may be piled up as such
           on a micro-version osc
            to make a package of %%wants etc
            to keep winding up and eventually having completed
            to try to make happen with another potential osc somewhere
          "happen with"
           is an important nature of the osc
           harvested inputs can be gone through
           in patterns across multiple osc
           as suggested by io exp:
            eg i my/$work y { &embed,$yin,$yang }:work
               o some/:yin o the/:yang
             can have osc doing the lowlevels in tandem,
              may stop|explode at one of the $yang,
               and everything can save there
                noting a cursor in exp to resume from
                 another, linear|next-ward type of A:n** chasing
                 could have either end not support that cursor
                  and simulate the selection with doming sense
                   avoiding extra &embed and recycling the previous $work,
                    supposing an entire i my/... must happen
                     ie no recoverable state to continue
                    eg things doing in the garden
                     eventually need doing again
               since osc can control itself
                and make recipes for that control
                 to satisfy having unfinished work
        
        so 1c&X/$dome/$Ct/$pip+$At/..$t/$A
         are the parts we can redo
         pick a $target to tunnel to
          usu a C
           tending to redo all the A within a C
            is what people will expect
          deepers would %ein to capture our e:tention specifically
           eg overlay controls are $Ct-arranged and qua-inducing
            affecting other $C|A.** they would know about
             so we could go watch the information arrive at the place
             eg how %Te-ing a %dl (depth limit), applied at a high level
              should cut the stack of cards a certain way
               something we want to study as sequencing $n...
         and do everything from there
         continuing osc
          to bring together the arts
          
         you may get pointing to a part of an A&ip: $pip
          hopefully stablising under your $target=C
           ie determinite
          or able to be selected for rewind|continue|forkability
           eg realising $At=only as %Te affects them all,
            in place, the A seek the point of themselves to redo
             eg A have $dome in stages along a transform
              so if it then knows $dome, they may be pointable
               since $dome implies forkability around it...
              yet tending to redo all the A within a C
               is what people will expect
          $At clashing after $pip..$t match is warn?
           being indeterminite
           perhaps decomposing too far how to Act
            needing things brought on by an enclosing activity
             which we tunneled through
           should show up while building e-able processes
            and the missing links must be included somehow
            eg as $dome pipe, which may take from the V-layer
             
           clue potential lack of $dome-ish around A** things
            ie pushing bamboo into a system wobbly at the edge
           as if redoing a part of thing to generate it,
            maybe missing separation of what-is to a specific us
            so as to make cannonical domings
            for a cannonical doming of 
      
      V
          V-layer
           refers to the entire network of X at time-1
            that it made and finished the last time
           for recycling sleeping things from
            finding yourselves in
            transfiguring X-networked truth systems
          V is the X&A&b&X
            ie it is the space your A&b is in
           their new life (X) builds up
           eventually supplanting it somewhere as "now" (1s&top&A&X etc)
            which immediately becomes "then" (A&V to you) when you redo
           has more or less of the same stuff as X now

          V below here in this write means osc,
           an agent of history collapsing down to a point
           a book keeper
           the outward relating A:n&X into A:osc&X
            A:n&V was only beginning to suspect
           confuse
            should The Fish be <>< ?
        
      The Fish:
          begin, middle, end acts:
           A1 reads many
           V  relates things back to one
           A2 writes many

          being able to patch bits of A1 through V,
           causing osc to zip things together efficiently
            by knowing the occasional border-crossing:
             eg $n:something%%nearby=$n:other
            or bounding into domes into processes:
             eg all %of=such -> W:of encoder
           domes in, domes out
           giving them three chances to sleep:
             (sleep = avoid unnecessary processing)
            A1 - may be the same
            V  - may be only changing what we ignore
            A2 - may be the same
          anyway,
           we would then have taken that input
           and produced no new output
       
       A I did - usu another tail, making A:n**
       V there is - matter affected
       A that was - matter effected
        eg lv-mode of .js encoding
         with wholly replacing C%of that changed
          < say which previous versions it replaces
            so catching up from lv1, when you see lv45
            can skip intermediate patching that was redone since
             if eg changing mostly the same C%of over and over
              can be lv1+lv45
              or maybe if C:other%of was changing too,
               lv1+lv33+lv45
                lv33 having the latest version of C:other%of
             these fugues of shapely dynamism
              reveal ideal page boundaries
               to be imposed after the fact,
               to make a log break into bursts of activity
      
       it takes input
       figures out what to do
       outputs what is
       
      anyway
        no I, only fi
        serve &t
          which means:
           lineating some A, that keep looking the thing up
           telling other A when thing changes
           whole loop of that, using only things in here...
        output benice:
         a list of A in Cit...
    =cut
   
   // Attention
    # want to have a thing
    #  A/$t+$of/$n=..A percolates, trailing:
    # we eventually request+receive creation of:
    #  5/$t+$of/believe/$src/$version/$n=Q
    # see Coffle '#I'
    fi.Ath = &acgtAsc{
        $xc = fi&wantbelieve,A,s,{}
        
        if (!xc) {
            # haven't got a Qlue
            fi&com,"none",{s}
        }
        else {
            # have the answer, 
            A&Athx = xc
            $Q = xc.n
            fi&com,"got",{s,Q}
        }
        # and looking, engaging with quest handler
        # have item ready or tell enclosing scope to bail
    }
    # over slope
    fi.wantbelieve = &acgtAsc{
        # put A/$of+$t/$n=inA|A
        $inA = c.inA || A
        $wantx = fi&Xsimp,A,s,{n:inA}
        
        # < belief-lockin may reuse V/$t+$of/believe...
        #   lots of things are and
        #   you must read the code
        # x/believe/$src/$version/$n=Q
        # later greater $version, most relevant $src
        $beliefs = {believe:1,src:1,version:1}
        $xc = fi&believeoQ,wantx,beliefs,{row:1}
        if (!xc) {
            # go further upwards
            if (A.up) {
                xc = fi&wantbelieve,A.up,s,{inA:A}
            }
            else {
                # we must be at the gateway
                xc = Ac&oftserve(s,wantx)
                # < it may now /believe if sync read
                #   eg localStorage
                xc and debugger
            }
            if (xc) {
                # threading back down to ..A
                #  towed in by the resyncing A:more
                $es = sex({},xc,beliefs)
                $Q = xc.n
                !isC(Q) and debugger
                es.x = fi&believeiQ,wantx,es,Q
                es.n = Q
                xc = es
            }
        }
        return xc
    }
   
   // Attendance
    =pod
     as &elvising handlers
      N merge for same c, see &emergible
     
     &Athinger,A,N,c
      takes strings to things
       N[s] - Qish states to become
        s.* splits into Q.c (name) and Q.sc (qua)
         see 'Q lifecycles'
       c - specifics on the becoming
      making requests|responses for a thing
       &oftserve may send requests sync
        or via 4s&todo[], which is like:
       or
        some xhr.done() -> G.and[C] -> G.tick()
      
     &Athinging,A,N[Q+],c
      make lv to chase ~Q into A**
      nodes above|with el:8|6 and %QN=[Q+] affected
      < inc $versions skipped over since the last A:least wake
        ie cluing possibly downloadable versions between old-new
         for chat scrollback
      A/** wake still having wabe (see below)
       yet having the Q their &Ath will get
       which must figure out what to dome
        which is just more A** chasing in disguise
       &Ath in doming should wabe to habe
      $Q lead to:
      $R chasing affected $n=inA, big rollout
       having a bunch of $r:
        rows of */believe/* change
       each thing, here and there and down the slope
        for a src-connected differable pipe thinging
       that can wander through A:n** applying itself
        being stretched with news before completion
         and present that as loop hazard, etc
         
     
     so A:most &Ath A:least &oftserve... A:loading
      then comes back in reverse
     
     structure mirrors around:
         A (loading)
          /$of+$t = havex
           havex/believe/$src/$version = habe /$n=Q
            places the latest Q
         A.up (least)
          /$of+$t = wantx
           wantx/$n=inA
           wantx/believe/$src/$version = habe /$n=Q
            given by A:loading
         inA (most)
          /$of+$t = wantx
           wantx/$n=furtherinA
           wantx/believe/$src/$version = wabe /$n=Q
            &Ath latest Q (from A.up)

         note that A:loading gives A:least habe
          or possibly when &Athinging
          since A:loading isnt on the &Ath climb
         A/** stay having wabe
     
     'Q lifecycles'
      starts as s, in &Athinger:
       made $Q-ish
       decide if:
        a question:
         $P requests it
        a statement:
         $Q fabricated about who pushes
         $P may push it to $src
       have a pile
       
       havex/believe/$P any in progress
         have|get Pc&src etc
         when complete they spread to:
         havex/believe/$src(/$P)/$version(/$P)
      
      also:
       havex/believe(/$Q)/$src(/$Q)/$version - all wabe/$Q
        to order $Q over any $src|$version
         certainly over any $version
          so branches ($src) can revert etc
        we are always adding to the last in a list
         ie always having the latest+best info
      
      and any /$P or /$Q list limits to 10?
      P|Q might be only beginning, partly filled out
       P for pieces of speech transmitting
        they may appear from websockets
       Q the whole speech bubble
        interpolation of what was said
     
     nearing &elvising:
      go via G.click[0][e+] for fast callback
      also G.click[8] for slow checkup
    =cut
    # requests fill out to response
    # $of+$t -> $of+$t+$string+$dige+$s
    fi.haveaQ = &acgts{ 
        # Q.c.* is the namespace, before s.string|el
        $lastcgk = ['string','el'].filter(k => hak(s,k))[0]
        $c = {}
        s = ex({},s)
        
        !lastcgk and c = s; s = {}
        else tax(c,s,ksaf(s,{bow:lastcgk}))
        each kv c {
            !iskeyish(v) and s[k] = delete c[k]
        }
        
        $Q = Cye([c.t||'?',1,c,s])
        Qy&A = A
        return Q
    }
    # the /believe/...$Q path, wildcard or from a Q.sc
    # believe may be another word, eg /asked/...$P
    fi.Qbel = &acgtQq{
        q ||= {}
        $bel = hashkv(q.believe||'believe')
        bel.src = Q ? Qs&src : 1
        if (!q.novers) {
            bel.version = Q ? fi&Qversion,Q : 1
        }
        !bel.src || !q.novers && !bel.version and throw "Q!bits"
        return bel
    }
    # derive a $version
    fi.Qversion = &acgtQ{
        return Qs&vers||Qs&dige
    }
    # this allows &Xsomp to make xc (row) at $oft
    #  as &AoQ joins it to /believe/ etc
    fi.Qubsist = &acgtAQq{
        # fun fact:
        # an $oft/$n must exist for &AoQ to join off
        # for A:loading, puts an $oft/$n
        #  A:least gets such from &Ath/&wantbelieve
        $fore = fi&Xsimp,A,Q.c
        !hak(fore.z) and fi&Xsimp,A,Q.c,{n:A}
        
        # see what Q can find, down /asked/ etc
        $QN = fi&AoQ,A,Q,q
        $O
        QN.map(&r{
            r.n != A and debugger
            O and debugger
            $bel = r.N.slice(-1)[0]
            bel and O = bel.n
        })
        # they probably reuse their asked|believe
        # < may find and en-version $P this way
        #me&nu,"oQN",{fore,QN}
        return O
    }
    fi.Asyncrequest = &acgtANc{
        each is N {
            s = ex({},s)
            s.string ||= "yardial"
            fi&elvis,{fi:'Athinger',A,N:[s],c:{}}
        }
    }
    # on A.4/A:loading, Q gathering into /believe/
    fi.Athinger = &acgtANc{
        A&thinger and A = A&thinger
        $Y = A.up
        each is N {
            s = ex({},s)
            
            # we can push+pull, usu pull:
            # request P +%src
            # response P +%version,string
            #  may keep P-ing for stages of decoding, search...
            #   relating them to each other somehow
            #  finally resolve to an s.P=$P, which becomes:
            # believe -> Q %string,P,src,version
            
            # s made into Q, may have only the question so far
            if (!hak(s,'P')) {
                # ask for it or keep receiving it
                $q = {believe:'asked'}
                $P = fi&haveaQ,s
                # +%string puts on the response side
                # < may be done without (/wjs/)
                if (Ps&string != null) {
                    # < a %digs may be supplied via http header etc
                    #   is the version of the source that compiled to this
                    #    ie /ghost/ %dige are /w/ %digs,
                    #     /w/ having compiled and argumented to %dige
                    $dige = dig(Ps&string)
                    Ps&dige != null && Ps&dige != dige and debugger
                    Ps&dige = dige
                    # < decode, get wjs script|function?
                    Ps&act ||= 'decode'
                }
                # user|remote might have specified the version
                #  or just computed it from %string
                # if there is O for what we want to push
                #  we can send trees only, reuse the objects, a la git
                fi&Qversion,P == null and q.novers = 1
                Ps&src ||= '1812'
                
                # previous $P
                $O = delete Ps&oO
                O ||= fi&Qubsist,A,P,q
                if (O) {
                    # can prevent creating identical .../$P
                    #  check ~ P.sc.* other than src
                    if (heq(O.sc,P.sc)) {
                        fi&com,"Psame",{c:P.c,sc:P.sc}
                        return
                    }
                    else {
                        me&nu,"Pchange",{P,O}
                    }
                }
                if (!Ps&act) {
                    # just asking
                    # i A:loading/$of+$t/asked/$src(/$version)?/$P
                    fi&AiQ,A,P,q
                    # link to previous P, when it +$version
                    s.oO = P
                    fi&elvis,{fi:'Asyncrequest',A,N:[s],c:{}}
                }
                else {
                    me&nu,"Gotether",q
                    # ~Q into A**
                    ex(s,P.sc)
                    s.P = P
                    fi&elvis,{fi:'Athinger',A,N:[s],c:{}}
                }
                
                $PN = fi&AoQ,A,P,q
                
                me&nu,"Asked"+i,{PN,P,O}
            }
            else {
                # < when to have a Q we already have? and the P?
                # < Qc&el and other knowns not for /$oft?
                
                # s|P decodes to Q
                $Q = fi&haveaQ,s
                
                $O = fi&Qubsist,A,Q
                if (O) {
                    # can prevent creating identical .../$Q
                    #  check ~ Q.sc.* other than src+version
                    if (heq(O.sc,Q.sc)) {
                        fi&com,"Qsame",{c:Q.c,sc:Q.sc}
                        return
                    }
                }
                
                # i A:loading/$of+$t/believe/.../$Q
                fi&AiQ,A,Q
                
                # o A:least may clue el2|3|8-ness
                # may have current /believe/ of all A:least**
                #  < they gc, domily
                #    recompositing X from X, de-row by inA
                $oftN = fi&AoQ,Y,Q
                $belN = flatten(oftN.map(xc => xc.N))
                # < decide el:8 when Q =~ belN/Q
                $el = !hak(belN) ? 2 : 3
                fi&com,"Q",{el,c:Q.c,sc:Q.sc,belN}
                
                # i A:least, where it will be believed
                fi&AiQ,Y,Q
                
                # constitutes a state change for all consuming Q
                fi&elvis,{fi:'Athinging',A:Y,N:[Q],c:{}}
                # and we are called in to update things whenever
            }
        }
    }
    # from above, on A.4 heading to A:n for ~Q
    # < almost an &indo user
    fi.Athinging = &acgtVNc{
        c ||= {}
        c.d ||= 1
        # avoids V loops
        c.refs || arrefs(c)
        # starting with V=A.4, finding V/V
        # < J: are A.3, with Q for any A they are working on
        $M = []
        fi&Xsomp,V,{At:1} .map(&r,eye{
            $n = r.n
            $lv = Cye([n.t,1,{n}])
            # < brack reduction: %%V,Vn,Q,Qwas +
            $into = arrefs()
            each iQ N {
                !Qc&of || !Qs&dige and throw "Athinging!Q"
                # < io left outer join
                # wanting of/t, grouping by n
                $oftN = fi&AoQ,n,Q
                !hak(oftN) and continue
                
                
                each i,oft oftN {
                    $n = oft.n
                    
                    # oft may !/believe/ yet, wrt Q el<3?
                    # assuming only latest /believe/ is in use
                    # < J: recreating and merging A|X
                    $la = oft.N.slice(-1)[0]
                    if (la) {
                        $Qwas = la.n
                        heq(Qwas.sc,Q.sc) and continue
                    }
                    
                    into.addref(n,Q)
                }
                #$belN = oftN.map(xc => xc.N.slice(-1)[0])
                #me&zu,"Mightbe"+eye,{r,n:r.n,oftN,belN,Q}
            }
            into.maprefs(&n,QN{
                # they might be for V or V/V
                $lvn = n == r.n ? lv : Cye([n.t,1,{n}])
                lvn != lv and ac(lv,'z',lvn)
                QN = uniqe(QN)
                lvns&QN = QN
                lvc&el ||= 8
                lvnc&el = 6
            })
            lvc&el and M.push(lv)
        })
        c.d > 1 and return M
        each i,lv M {
            me&ioty,lv .map(&lvn,{
                $M = fi&Athinging,lvnc&n,lvns&QN,ex({},c,{d:c.d+1})
                M.map(lvnn => ac(lvn,'z',lvnn))
            })
        }
        # these might be Vc&repeat()-able
        # el:6 should wake fully
        # el:7 are above el:6, slep any inputs from an el:6?
        # el:8 probably dont wake
        #fi&com,"Thinging",{Q}
        me&nu,"Athinging",{V,N,M}
    }
   
   // Elvis
    # i 4%todo/...
    fi.elvis = &acgtc{
        c.fi and e = Cye([c.fi,8,c])
        else {
            throw "whate"
        }
        ac(A.4,'todo',e)
    }
    # o 4%todo/*
    # called outside anything
    # < A:elvisings transacts off do() we finish
    #   errors|more-async cause a traffic jam
    fi.elvising = &acgt{
        $N = a&todo || []
        $began = N.slice()
        $known = N.slice()
        each ie began {
            # < mergible ec&N amongst c.*+c.c.*-same
            if (ec&fi) {
                # {fi:'Athinging',A:Y,N:[Q],c:{}}
                fi&com,'elvising',{e}
                $args = haks(e.c).slice(1).map(k => e.c[k])
                fi[ec&fi](A,C,G,T, ...args)
            }
            else {
                throw "what todo", c
            }
            if (hak(N) > hak(known)) {
                # this e emits more todo/e
                # before or after the rest of what we're doing?
                $neu = N.filter(n => !known.includes(n))
                es&spawns and debugger
                es&spawns = neu
                known.push(...neu)
            }
        }
        $finished = grepout(N,n => began.includes(n))
        !hak(N) and fi&com,'8-still'
    }
    # merge ec&N when ec&*, ec&c.*, etc same
    fi.emergible = &acgtN{
        $fiz = uniqe(N,{map:n => nc&fi})
        $nonNcc = &c{
            $fc = ex({},c)
            !fc.N || !fc.c and return
            delete fc.N
            delete fc.c
            return fc
        }
        $merged = []
        each fit,z fiz {
            $f = z[0]
            $fc = nonNcc(f.c)
            !fc and continue
            each in z {
                i *= 1
                !i and continue
                $nc = nonNcc(n.c)
                $not = !nc
                    || !heq(nc,fc) || !heq(nc&c,fc&c)
                    || !heq(n.y,f.y) || !heq(n.sc,f.sc)
                not and continue
                merged.push(n)
                fc&N.push(...nc&N)
            }
        }
        #me&nu,"Fiz",{N,merged}
        grepout(N,merged)
    }
   
   // Travel
    # catchable expr and debugger
    #  shows how $t/$n may dedup by sequence
    fi.ibug = &acgtti{
        G.bugs ||= {}
        i ||= 1
        G.bugs[t] = i
        return &{
            $still = G.bugs[t]
            still and throw "bug!catch", t, {still,i}
        }
    }
    fi.bug = &acgtt{
        G.bugs ||= {}
        !G.bugs[t] and return
        G.bugs[t]--
        !G.bugs[t] and return 1
    }
   
   // live
    fi.live = &acgtJs,ar{
        $Y = A
        
        # &t:
        # to i A^^X/$of,$t/$A
        #  then:
        #   auto J^^X/$of,$t/$At
        #   there is o J**/$At
        A = fi&Atopleast,1
        fi&Acom,A,'yaya',{}
        
        fi&test_Attention
        #fi&test_Nxcnorder
        
        # &zu attaches to CyR-space, above Y of Cat
        # < use $Ati - sequence having $At path
        $Atw = hashkv([A,...(As&z||[])].map(n => [nc&sip,n]))
        me&zu,"Aump",Atw
        As&log.map((n,i) => me&zu,"Log:"+i,n .sc.rowish = 1 )
        
        n abovst  s:vefge
        n tassely 3 s:brackets
        n soilesoezc 3 s:brackets

        $i = 5
        $c = exts({},'sit','t')
        c.oth = 1
        #4s&Bthing = Gc&B
        #4s&Bthing = eny(c)
        #u Dealap
        # < see I change
        #4s&Athing = A
        #As&selfpin = me&t,R,{of:'wjs',args:'ar,J,s'},'Fish'
        #As&selfpin = me&t,R,{of:'wjs',args:'flonk,J,s'},'Fish'
        #while (i--)
        #    ~>5 Fiseh: 3
        #fi&a,{fuselage:3}
    }
   
   // test
    fi.Acom = &acgtAsc{
        return fi&com,s,c
    }
    fi.com = &acgtsc{
        $Al = me.cbu(A, A => !A.up, A => A.up)
        $big = haks(c).map(k => k+":"+dis(c[k])).join("  ")
        $m = A.t+"#"+Ac&sip+" "+s+": "+big
        $log = Als&log ||= []
        log.push(m)
        ac(Al,'log',m)
    }
    # to script for many A, getting A = particulars
    # < switching A etc with B on any &h:
    #   Babz: fi&Thing,A:Al,la,ca
    #    -> G.h(A,C,G,T,{t:'Thing',A:Al},la,ca)
    fi.Adoer = &acgtY{
        Y ||= A
        return &{
            # start each call with the A from &Adoer
            A = Y
            each in arguments {
                isA(n) and A = n
                else
                isar(n) and $a = fi[n[0]](A,C,G,T, ...n.slice(1))
                else
                isfu(n) and $a = n(A)
                else
                debugger
                # assumes any A returned from that
                isA(a) and A = a; a = null
            }
            return A
        }
        
    }
   
   // t A
    # roll b->A
    # rota A->b
    fi.test_Attention = &acgt{
        A.4 = A
        $Ag = A&thinger = fi&Atsomewhere,A,'loading'
        
        $Am1 = fi&Atsomewhere,A,'more'
        # V<-X
        Ac&again()
        $Am2 = fi&Atsomewhere,A,'more'
        $Am = fi&Atsomewhere,A,'more'
        $Ae = fi&Atsomewhere,Am,'even'
        $Au = fi&Atsomewhere,A,'unrelated'
        
        # try get something
        A&oftserve = &sc{
            # c=wantx is Al's
            fi&Acom,A,'oftserve',{s}
            
            fi&elvis,{fi:'Athinger',A,N:[s],c:{}}
        }
        $oft = &{ return {of:'w',t:'random'} }
        $got = fi&Ath,Am2,oft()
        #$got = fi&Ath,Am,oft()
        $got = fi&Ath,Ae,oft()
        got and throw "got first"
        
        fi&emergible,a&todo
        me&nu,"Florro",a&todo.slice()
        fi&elvising,1
        
        fi&emergible,a&todo
        me&nu,"Flogo",a&todo.slice()
        fi&elvising
        
        fi&emergible,a&todo
        me&nu,"Flogort",a&todo.slice()
        fi&elvising
        
        fi&emergible,a&todo
        me&nu,"Flogart",a&todo.slice()
        
        fi&elvising
        return
        # supposing ^ wakes A:more:
        $got = fi&Ath,Am2,oft()
        $got = fi&Ath,Am2,oft()
        
        
        Am2s&got = got
        #$Am = fi&Atsomewhere,A,'more'
        # < look at awaiting of+t, group by $At|$sip
        
        #fi&Athinger,Ag,[{of:'w',t:'random',string:'changesing'}]
        
    }
    # &Xsomp $n...$n ordering
    fi.test_Nxcnorder = &acgt{
        A = fi&Atsomewhere,A,'test_Nxcnorder'
        
        $s = {of:'w',t:'leaks'}
        $x = fi&Xsimp,A,s
        $enQ = &s{
            $Q = Cye([s.src+' v'+s.version,1])
            fi&believeiQ,x,s,Q
            return Q
        }
        $got = a&got = {}
        $see = &t{
            got[t] = fi&believeoQ,x
        }
        enQ({believe:1,src:'1812',version:1})
        see('first')
        enQ({believe:1,src:'1812',version:2})
        see('2nd')
        enQ({believe:1,src:'1812',version:1})
        see('first again')
        
        return A
    }
    
 
 // X
   =pod
    the new X
     space for spaces of matter (its2)
     forming over and against any other|prior experience
     
     each X is for an A: X.A=A, A&X=X
     < merge X into A?
     < make X C, X -> X.sc, X.Xq -> X.c?
     
     a beach where traces hang up ways in
      a photographic field where A can know itself,
       at any level between A(.*)+ and A/C, even A/type/C
       and any moment, supposing indexing includes $moment
        or you would simply make another X
      with individual fronds of X.*
       networks of types and measures,
        in an expanse intersected by a curve
     
     A loads X with things approaching C
      X/$t = x, x.z/$C (aka X|x/$n), C.t=$t
       is a simple load of things for J
       x.z can handle dupes, see 'ressur concluded'
        other indexes|slope should be found to separate them:
        X/$n orders the X/$t
       that C might have no meaningful C.t, etc
        be just C.sc, eg &brackX for X.k.$gk...
        separatable by other lateralism:
       having extra coordinates for the same C|refs|etc in X...
        the X/$t produces A/C tuples
        may share C with various X.*.... producing:
         legs of twinning:
          e wanting C/$partofC/connects:to/C:D/because
         you may specify these, as i|o things
          so you are notified|involved
           as soon as X notices rows come into that view
          and thence &ha|&n, even &increment
           may see if they start|have|stop involvement in whatever
            creating the memory of a search for fitting a formula
            which would be the ultimate thing to optimise
         so it decides to write various things about it,
          including was-something-e-wanted
         
     so they attach C,
      any ways they want
      then start walking around it
      assuming things it didnt see arent there, see 'ressur concluded'
     to X, which is also attaching to itself:
     
     A tends to have identifiables (At path) anywhere it spreads out:
       Aip - subnets repeating
       At - path (mind+Ct)
      along with its own X
       to arrive X into X&A.up&X (upward)
        so it acquires X.V, the supposed last version of this X
        as resolved by At+Aip, etc
       see 'A@1 scans itself'
       X|x.had should know its xqt+ark:v in X|x.up
        having 
        too much to copy index, eg:
           X.up.At.$At = x
            x/$n = A = X.A = X.had.aye.At.$At = x
          tho it allows every x to know every other x
           all &qis per &Xio ($n-tering)
           would be a strange case of sequencing by /$n
        just:
           X.up.At.$At = x
            x/$n = A = X.A = X.had.aye.At = $At
          having to go X.up(.V)? yourself
           and &Xio o:aye {At}
     
     and X.* in general index A/**:
      X/$At: A:a/A:b
      X/$oAt: met other A:c
       &h-like calls with A:a may have eg &ha,C(y&A:b)
        we see b as other
         could be A:b and C.**A:a
        A:a|b&ip relates some time and space
        which thing goes into the other,
         how they slope etc. all might matter
       extra how|when|why indexing may pile up here:
        X.iAt.ha.$At.z/A for where &ha,C came from, etc
       in a few steps,
        A:a may other A:b for its own ends
        and|or|which-is become elvised, imposed into there asap
        depending on what function is crossing what lines, etc
      A..A eg A%dome is a self
     
    so
     it can put away like &brackX,
      for multiple n%*
      while noticing refs anywhere already
       thistimes, esp something duplicating
        esp becoming complete in some way (-group) of:
       thattimes, have recyclables
        have goners eventually:
        can be 'ressur concluded' at some point
         trad match t+i @17, see &arriveRbitX
          %Te only match t, so all i are the same to it
          %Te want to accept pointerbits
           and get named (Te.t) more elabourately
           per thing we need to separate
            the arrival of qua to
           we may be able to say C:Thing/-suchapi
            cutting down on At-ness between C...$pi
            expecting any|one|many -suchapi with any name
             or some name, qua besides c&pi='suchapi'
              and not, etc. an assertion.
            delivered from any point in the slope,
             where it makes sense, is grouped...
             drops into the was-implied section of %Te/** growth
           which is the compression
            of X back into C, basically
            the 'I want this and that somewhere in here'
            from sparse tendrils of implication 
            into the tidiest job sheet possible
          
       we may be doing only some of the channel
        which should re-emerge in perfect sequence...
        they will partition by ny&act=T.act,
         see 'ressur concluded', other lateralism
         and &twlic etc, does list gapality
       
       see 'resolve $n'
        
     it is used to find e-pointers
      which is often about deducing how simple it can be:
      &CX: X.t for t-path (the J..C..), having C
      &brackX:
        finding pointers to rows is new
         we tend to &brackstill the overall k:v concat
          while it is considered one big undivisible instant
          then group rows into C when it moments, eg -brackology
           from here we could generate a better-typed likeness for:
        
        could match as simple as &ja,'such,had,keys'
         might have to be all the keys (of a class)
         or be pattern matches that &voice
          &voice climbs trees of mind (the EXPR)
           while climbing chunks of the world
           the basic do sub depending on values loop
           it should walk out over X, measuring distances...
          pattern matches for &voice being transportable
          they would be pointer composing
         or match row cloned from such a row &Xout,$row
         or any other lateralism:
          row from|haswayto a certain A
           eg $dome, or Aip|At bits
           or n-ward to brack without coordinates, from a:
           or u-ward to them -> -groupology get names (in C)
            of the Km.t, having Kmc&rows
          any other X-ing the r is in
          match cloning (&ha,$n,...) from such a row, eg in V.rowrefs
           currently the only way to drop recycled domebits
            when they regenerate
            to have the osc C consistently in memory
           similar to row from certain A
         they could all be turning into an &Xout,{...},{...}
          that Te would instruct
        
        conversely, 'ressur concluded':
         the row might el:9 when these things go unmatched
         resolving the set of seemingly coming+going things
          to changes to their insides,
           when supposed together by homology|similarity:
           it may just have a key changing, becoming el:3
          to minimise overall change given extra expression and context
           things can be told apart by lateral inquiry:
            thing from same dome (A), that D^^A of ours
           or in|through-row|n-ward C having uniqueness
            compared to others in the ambigroup
        
        and be able to notice|react when it next &ha
        
        may adjust their names?
        
    &a-pprehending brack leading into:
        as the X grows it becomes a V
         &ja|&za read each
         parts of V could be
          virtually
           read from many sources, eg &t
           appearing in X already
          actually
           prepared, eg %dome
           preplanted in X already
         by the time
         then parts of X are parts of V
    
        &Kmish
         D&X -> D/** of Km, Kn starting at Dc&brackin
           can now read xq for structures
          they would be via
        %singletter
         elvis that undoes the last input character,
          before inputting another
          so anywhere the meaning of that letter went,
           must be retracted, redone with the new one
           meaning catching the first letter type event,
            multiple times (el2,el3+)
           the oscillator decides to i,-i based on o
          smudge over time to sing
   =cut
  // frontends
   =pod
   lang has instances of cultures at levels
   they share s,c,q
    q mostly, which talks of the whole trip:
    
    use: &ha|&ja|... sc,shade,mix
     perspectives, for most local expressions of truthseeking
     configures probably one:
    front: &a A,s,c,q||={}
     handles that family of types doing what they do
     make many calls, each get it takes
     to something like:
      &Xio,{i:'brack',X||=A},s,c,q
       each spec q.Xio|Xq.t, source X|A
       may change s,c,q completely
       each &Xio translates to:
    middle: &bracki X,s,c,q
     defining with each &qas, climbing them 
      each $n first, then $k|v...
      we can assert|check index is how we expect (down to a point)
     and climbing whatever it needs
    back:
     &qis,X,o,s,c,x <- many $s,$c travel x|X
      read+write X..x as per $xt, with $s, for $c
      s.sc bind params
      s,c new at backend|micro
       re an op on $xq (the index)
      o.xq|Xq...
      o.s|c|q were middle|macro level
       < o.c|q might hook by $xt to ex &qis..c, etc
      are individual to the $xt
   
   the theme of everything taking s,c,q (y,c,sc reversed)
    they may compile as they cross each layer, esp middle
     s.. is likely to be iterated by the middle,
     c+q are likely
      search|thing (what, reality)
       what we implant+excavate
      configurance (how to)
       io spec, complex WHERE, etc
      question
       shared over all layers,
        per use or at least frontend lifecycle
        < track each other over time
          frontend doesnt know what use it is for
          unless they are &h calls (G.h(acgt...)) which G&B...
       may make arbitrary lowlevelations
        may be copying (translating) to another X|x
        may el:9 everything at the backend
        may want to check all X/$n.sc same asap
         see 'the q.still variation'
       limit|replace certain x, who knows what.
    
    leads you to describe the thing you are in
    X is life+death crossing over, once matured
   =cut
  
  // &t
    =pod
        &t
         write search down - Qish as brack c
         find any things (rows) matching c
          go for the smallest set as the one
         write what we read, inc nothing
          do things to get, keep thing
         reads a thing!
     
     //   for &t - little X:parts relativity
          see X:new/$reks
          
          < intro to &clusp?
           def 'u some' -> A.1/u/some
            as a batch (until 'n using..' or &clusp)
            we mix up a %J:
             tv sort|replace $C** as usu
             named by joint(uN,'+'), source list
              cached at $sNorm=A.5/u/some+Normal, lent to others
            $sNorm can have W:Normal dependency
             that we want to make sense of through backroomish &t
            we mix them together like a %J
             also fully state any $of different to u:Normal
          
          X:anI underlaps:
           X:someu has some $n W:some
           X:Normalu has underlapping $n W:Normal
           &clusp
            mix them into
             C:some+Normal/$of**
              re-use C:Normal/$of
               trust that mind will not be tampered
               C refs would be different if changed within:
                sub-mind having been oscillated
                 or loaded from <script>
              new C:$of** if mixing
               because in &voice, we $ofs&z=[D+] around
                expecting lowlevel integrity of C** hardwirings,
                 < unify &voice iterators as X, later
                   swathes $of=common/%sc=rare could be indexed, jumped over
             X:sNu/$of
              knows all /$of
               re-use switches -> X:Normalu/$of/**
               new also has /$of/** 
              to become X:anI:
           X:anI/$of
            if re-use
             rowing switches -> X:Normalu/$of**
             x.Xorm? into the same /$of-ness there
            etc
           so
            first $of from X:anI (then X:Normalu)
             while &t at A**.I=X:anI (climbing slope)
          
          X:whicheverI @Search:
           having X:best, X:maybe, X:sorta
            for three grades of stuff
           goes for the first /$of found
            so eg X:best/$of would be a coherent bunch
             which may mean being mixed with Normal/$of 
          
          &t, while at A**.I=X:anI
           can find each $of from X:someu|Normalu
            ie without having to re-C everything from X:Normalu to X:anI
            see 'X:anI underlaps'
            &T changing a mind, pulls it closer
           
           A.5/u/Normal is W:Normal and Normal.js?
            or some u:some left as a cache
           A.5/n/Normal also,
            is our attempts to push|pull things
            the who|what we want them to be, etc
           
           5/u searches W:u/*
           5/n searches W:*
            may
             push W:u/Normal
              so 5/u gets it
             push W:Anything
              so 5/n gets it
           
           from a distance|angle
            n means production
            u means consumption
     
    =cut
    # Tthing that can wait for it various ways
    # c.modes of async
    fi.t = &acgtsc{
        # s,c may be $of,$t or 'I',$t
        isst(s) && !c and s = {of:I,t:s}
        s = exts({},s,'of')
        c = exts({},c,'t')
        c.t != null and s.t = delete c.t
        # s{of,t} c{el:2}
        $I = A.I || A.1.I || A.4.I
        $q = {}
        $N = fi&Xio,{i:'quest',X:I},s,c,q
    }
    # Itivity of s+c
    # s is Qish quest - look for a thing
    # c can el:9, el:2...
    fi.Xios.quest ||= {}
    fi.Xios.quest.i = &acgtXscq{
        fi&qas,X,q,'k'
        each kv s {
            # the keys
            $kx = me&X_t,X,k,n,'k'
            # have their values via unique id
            me&X_s,kx,v,n,'ref'
            
        }
    }
    fi.Xios.quest.o = &acgtXscq{
    }
  
  // way
    # throw if no

  // apprehend (&ha, &ja...)
   =pod brackio
    do as &bracki|o do
      we create a new $n picturing:
      s.s|shade|mix
      s.s=C might be cloned,
       %%dome and all the usual effects
      n.c knows of other stuff:
       row is recycled
       was entered by some A...
        there is an inside, &ha while Dome is 3
        must be siphoned into the self sometimes
        instruments producing brack when acted on
         other bracks below the line
    
    mere Ds&z=[$n+] (and &brackX) becomes:
     
     X/$n and X/$k|v|ks
     
     X/$n = xn - ground everything else
      an index for $n itself,
       that also for x.z/$n, out there
        these two 'for' resolve $n to each other
         usu effortless|already done
          as in &bracki rows causing all the x
           they are positing the x as inhabited
          or a part of your process
         maybe coming,
          or partly out of control
          esp if working from analogue distances
           of beyond one X|A etc
          like we put things in the big A.c
           to make them famous
           a kind of nobility is supposed,
            creating a wave of negation out there
      
      join X/$n from x/$n
       to get its sequence, and more:
       
       X/$n/$ks may exist
        or
       X/$ks can be made to look like it
        with $n-clausation
         being $ks/$n but sorting $n/$ks
       
       on the two /$n senses:
       
       X/$n is X.n[vi]=xn, uniques $n, type='s'
       x/$n is x.z[i]=$n, dupey $n, type=~'z'
       interesting. to write:
        x.z/$n, we def mean the latter
        x/$n, may join x.z/$n to X/$n
         or maybe,
          x.n[vi]=xxn ?
      
      any x/$n should also be in X/$n
       (for both those /$n senses)
      you join X/$n to get its sequence
       any X/$n/... are also there, indexed per $n
       
       X/$n/$k or $n-clausation slomo
        vis. X/$n = xn, xn/$k
        basic premise:
         having $n*, wanting $k*
         may be specified or wide open
        exists:
         xn/$k = xnk
          a copy of what it contributes
          xnk != xk (X/$k)
          might even link:
           xnk.xorm=xk (with other $n)
           to get to X/$k
           see 'x.Xorm'
          at least clues $k index
         X/$k = xk
          knowing already some xnk.z/$n
           amongst others in xk.z/$n
        else:
         simply grep $n in X.k..xk.z/$n
         so:
          it always works
          see 'X/$n/$answer already written down'
        so:
         we carry the $k from xn to X
          or the $n from|to any x.z/$n
       
       X/$n:spec/$k/$n
        $n:spec could be found in X/$n
         or we might grep $n in X/$k.z/$n
        either way some lowlevels appear
         its position in:
          X/$n - where to get to the row before, etc
          X/$k - keys defined by any node in order
          X/$k.z/$n - nodes defining keys in order
        so:
         we can always get more|less $n|$k|etc
         and join that rowsense somehow
         use whatever X.** mechanisms
        solving:
         eg X/$n:spec -> xn && xn.k
          means we can xn/$k = xnk
          carry the $k: X/$k = xk
           xk.z/$n:other
            $n:other having any particular $k that $n:spec had
            sorted by $k
             $n duping would be avoided,
             < rowsmush would squish blobs to fit things between
          swimming
           around to wider|narrower spaces
           how to traction one view on another
        
       about: parallel spaces and subselecting
        x is posited as inhabited by various $n
         x.z/$n specifically found it
         
        can always find an index to|from $n
         simply looking at any x.z/$n
         and applying it to other x.z/$n
        
        ie, having the X/$n/$answer already written down
         or falling back to grep for it
          or even invoke &answer to generate it
           modulating an index full of answers
            waiting to be needed
            lazy evaluation
        
            note on X|x/$n sequencing getting mingled:
                     because xn groups by $n
                      X/$n -> X.n[$nsi] = xn # per unique $n
                      x -> x.z[$i] = $n (not xz) # dupey, all &a...$n
                     sequence loss into X/$n:
                      n1, n2, n1 -> xn1(x2), xn2
                     restorable by join to something in order:
                      o X.z/$n o xn.z/$n
                       X.z=[$n+] every &qis c$n ever
                      see conflating of which $n
                      and unlocking assuredness
                       about the vectors
                     
                     X.perience/$n of its own order
                     X.z/$n ordered by time of &qis (supposable?)
                     X/$n once per $n, in order of appearance
                      order might impose to X.n but not X.nv (refers)
                       from X:old->X:new
                     #   s/ns/nv/ for plurality of n values
                     
                     eg
                     X/$k/$n out there can find their X/$n/$ks
                      $n being the join around X.**
                       ie $n cluster at found x
                        many x join many x/$n, out and back
                        x/$n finds $n finding x 
                     X/$k/$n/$ks
                      may work for notation
                       from a $k*s $n*s $ks
                       knowing to join by $n back to:
                     X/$ks where $n
                      X/$n/$ks might clue|copy a lead on $ks bits
                      or take X/$ks and grep for .z/$n
                     easy.
                     
                     waves of X..x come as per $n
                     
                     how much of what is an artifact of iteration
                      and how to de-warp it when per-somethinging
                       what to take as now
                        in the midst of the machine that changes
                        ie might want everyones %colours
                         to make a palatable difference
                     
                /note
     
      exact X/$n coming around again is to el:3?
    
    < dev
     < &bracko as usual.
      not for the moment needing to:
     < io paths
      the boundary / crosses may be:
      s.N/$n - an array of $n
      x/$n - the rows with something at x
      x/$n/$k -  joins to X/$k by $n
      $n+$k may be specified or wide open
       ie cause where as well as select
       they are notated like bind params
        say what index|column to join to
         since it is no longer always 'z' (tv climbing)
      < brack has $u%n = $n hierarchies, sorta
        would be $n:lower/$u:higher
    
    also:
      the q.still variation on any middle:
       &Xio:i:brack s.N/$n q.still=1
        we would pass all our rows
         to refresh the index,
          either in place or by making X:diff
         like &brackstill, simple as for speed?
          each X/$n (row) remembers the many {k,v} it had
          each $n again:
           resolving $n is easy (ref)
           alt xq.i(...) makes list of new {k,v}
           if cha,
            T.whack out of &bracki to:
       &Xio:i:brack s.N/$n q.still=2
        checks bunch of $n for re-read
   //    resolving $n is easy (ref), or: (+ X/$ks name pooling)
         starting with more specific X/$ks (name pooling)
          expressions
           shared by many|one $n
           there is usu a way to refer to an exact $n
            eg '%part=4'
             smooth variety of %part across $n is interesting
              the i X/$k/$v would notice
               having many x.z/$n last few of its x were .z.length==1
               conflating the possibility of using $ks
            eg '%%what,it,is', whole + ordered
             # sorting by $k may detect renames amongst a few 
            # probably conflating:
            eg '%%what,it,is...', parts (ordered but not /^/)
            eg '%what,is', parts (ordered?)
            eg '%', having sc at all
            eg '%%', being brack, as wild space blends with C
            and more expressions
             eg '%%what,it,is..' is leading into is (and whole)
            anything &brackology can make string
           anyway
            generates many X/$ks per $n
             a bunch of usuals,
              like t, t+cv, and see below
             until finding with no ambiguity
              X/$ks.z.length == 1
             finally give up with:
              X/$ks='%%same,things'/[8] -> sequenced
              X/$ks='[8] %%same,things'/[0]
               like footnotes
                and a multitude|point controller (%Cit) to you
               extra nametagging
                from an alien language
                 since our closest $ks is still ambiguous
                 and our $n-sequence within it
        so X:old
        emerging new in X:diff (partly?)
         with X/$n|k|v|ks like X:old
          since X:diff being q.$moded from some middle,
           we end up with their structure+order through &qis
         each X/$n** fully like X:old
        the create as
        we notice things,
         sooner or later (resolving $n)
         makes X:diff/$el=1-3,9/$n|sc|k|v probably
         maybe X:diff/$alterity measures
        so we can have little X:parts
         putting hypothetica, structure embeds
          on branches
        
        sequencing $n across things
         &qis $n is a dome
          with &qis $ks|etc before the next &qis $n
         &qis can be
          reading|writing any other index
           with each $n|$ks it is given
           ie in a loop that may be dimensioning around,
            middle|back could tail call
             and other &voice lateralism
           as neighbours (particularly in sequence) arrive:
            o $n:new/$ks o $n:old/$ks
             not knowing $n:old at first
              join by X:old/$ks
              which $n:old can be found in relation to,
               ie select $n/$ks from $ks/$n
                sort by X:old/$n
              making sizups:
            i $pairs/$n:new/$n:old
             as in '. appears to be the new .'
              then fill out
            i $similar/$pairs/$metrics
             each degree $similar (sort|dividable)
              per $pairs,
               specifically $metrics
            would make picking most similar pairs,
             satisfying all X:new/$n
            see resolving $n
        
   //    resolving $n
           eg X:diff.finds/$n:new/$n:old/$ks|$k
            these are our neighbours|similars
            all new $n,
             having $ks|$k
             remember old $ks|$k
             leading to pluralities of $n it could be
             all lining up ok
             by being the most ideal:
              sort by homology of $k|etc,
               making (maybe many) guesses at $n/$n
                maybe many shouldnt happen if you $tv:n
             if maybe many
              each $n/$n guess
               weighs into $n/weigh/$n/**
                incubates strategies for
                $n being the future of $n
                which itself gets measured for complexity
                 of $k etc change
                 it making $n/$el=9/$k microbits etc
                  like the A:diff miles below this indentation
                  but already wrapped in individuation (one $n/$n)
                 so it is easy to draw it out,
                 producing X.** with a shape
                and places motile plans for changing what was (lv)
                 where sequence is a big clue, re el:8
                  and a bunch of impressions of sequence
                   might be looming around
                   like reading a random list (A:new),
                    noisily remembered from A:old
                    notice groups of loose|tight sequence
                    and when their order|direction changes
                    see 'have their $n in the others gappy order'
                 where order changes:
                  putting new at old
                   notice $n before|after $n factfluctuation
                   12, 23, 34, continuity buildup is good
                    would conduce when a $k is moving between $n
                     otherwise that ^
                     would have the $n swapping histories
                     to remain with $k-continuity
                  < &T substraction, break down into ...
                  sequence materialising somewhere
                   at &a q.seq=$seq
                    is seq eventually X.seq?
                    is it $seq/$X/$n?
                     each $X:old|new
                      have their $n in the others gappy order?
                       then x.n.$i to X:new.n.$i
                       form groups from pairs of $n in the same order
                        by simple x.n.$i+1 to X:new.n.$i+1
                         having the $i from $n, to put $i in X:new.n
                        ie $n:oldy&nexty&future == $n:new
                      might form $m - groups of $n in an order
                       suppose $n could mean bunch of $n:
                     
                     may calculate some facts: (see 'weigh')
                      $n/$fore:n or $n/$aft:n
                       $n < $n or $n > $n, list-wise
                      $n/hops/$n
                       $n crossing $n might happen|matter
                      $n/$distance/$n
                       looking for small distance
                       consider magnitude of fluctuation of distance
                       are we spraying pixels between bulbs?
                      $n/van/$n
                       neighbour change (lost|became $distance=1)
                       named for summer travels aspect
                      $n/neigh/$n
                       the nearest in any direction
                      for lazy:
                       evaluation, when io calls for it
                       calc for continuous groups $m
                        rather than $n
                       divisibility is a big thing
                       more $m in|amongst|over other $m:
                        given an error margin to group by
                         cell dividing before the error margin slopes right off
                          lum per $n
                     
                     delimiting bunches of $n (lv)
                      with the few $n we mention
                      could move the lot around
                      eg lv el:6...el:8
                       finding the $n for el:6 that begins it,
                        until the $n for el:8 being after it
                       new 'position implied'
                        usu after last el:8 etc
                        may nc&from=$xpath|$ks
                         which may be a part of lv** we are yet to wake
                         may correspondingly el:9 over there,
                          if further|slopier than some amount
                          this is like being introduced as from somewhere
                          that somewhere able to answer for your leaving
                      eg lv el:4
                       renamey, non-moving
                        eg X.$tv:n, changing an n.t or ny&cv
                       old 'position implied'
                        usu after last el:8 etc
                        may nc&renamed=$tv|$ks stringifiable
                         then we could move as well,
                          to the 'position implied'
                      so:
                       el:6 + el:4 (move and rename)
                       and making a 'position implied'
                        that resets or changes direction,
                        could be as simple as:
                         el:8 moves pointer back to that:
                         we el:4, el:8 to where it goes,
                          el:6 it there with that new name
                        each thing should rename only once
                         per parent el:8, which can be inflated
                          to get smooth layouts of sets of change
                  
              sort $n/$n guess
               at some point
               with weigh in it
                inc what has happened to the order
                lv-friendly cursoring or not could be fast to compute?
               should be most intelligent to each $n
               anything not perfectly divisible|reasoned should &T 
               
               and having already done that for the last $n,
                so sequencing may reacquire itself
                  q.seq also connected to $dome, Dome
                   so we can continue it
                   so could be super-&a
                  so:
                   < array diffs with moveless or identity economy
                   < Xio.lv $C $N alluded to
            
            so: ref easy, name(s)...
              finding $n usu same ref easy,
               may have to find ny&up=$n by the time X:old
               they can be checked while held in a dome etc
               they get lost every time they exists
               have to know a unique name for them
                perhaps X/$ks - a pile of autogen names for nodes
                 they could divide themselves by adding to their names
                  ~ what &brackology is supposed to display a field of
                 they could easily find themselves apart,
                  with a sequence number after envelope
               yet like linear sequences,
                would call a stream of them wanderable
               anyway
               we probably have x.z=$n still,
               or resolve $ks to an $n
                < or go by homology,
                 another dimension of similarities in deeper ..x sprung?
                 or sequence conservation
            also:
             resolving $n with a namechange is a big deal:
              must be preserved carefully across many X
               eg X:new/$reks
                recent|most-likely $ks that changed
                translating pointers of X:old
                 for e running late, get el:4 round trip, retry
                low priority
            
   //    rand + sum resolving $n
         rand
          from revoked imagination of:
           $h = a hypothetical /$n x
            they might h&commit at the end
            to be revealed at the end:
             soundscape of z|zh
              electric and gas
              the point the letter changes
               pronounces boundaries as sound disconuity
                whose country imports these
                 who takes the art home
          
          see X:new/$reks
          
          X:specialeffects extend:
            it could be bound to rewriting wholer chunks
             eg X:anI serving each $of from several index
            it could make an interspersal only
             pulling up facts on how they change order
          
          X:selfscape
            many of its parts taken together
            correlate to parts of other
            wide angle lense on morphology
          
          if you needed more name
           (unique stringable discernment of eg $n)
            see resolving $n
           and those names could include X** pointers,
            but dont|cant include X.n.$i,
           no enough entropy in X.**
            you would &T up the intensity of $n** -> X.**
              growing projections inside $n, of local types
              engaging possible introspection|expansion
             their detailings would all be subject to process etc
              being actual occasions
                    
               to split atoms by whatever is keyish()
                eg '%same,things:C' using X/$k=things$visC
                 providing the bool isC() to draw -brack@101
               # with a note on sequencing, X&ip
               
              cant find any index to 
               might be played upon in the chat room
                ie things you create similar to otherses,
                 appearing mergey with both codes trying to patch in
            
         sum resolving $n
          usu find one $n:old for each $n:new
           everything is lost and reappears
            cant trust /$n sequence
           X/$ks may do this if keys arent moving
            $ks has a few codified names for the thing (strings)
           X/$k|v can find+sort $n with most in common
          based simply on the ideal name for a thing
           $n == $n:old most ideal, native
           the enclosing X:osc/$n you are likely to encounter
          
         finding a match for $n
          happens while we ...
          try reasonable combinations of old<->new $n
          then pick the least X:diff-icult
            having its 
             for $n, as we have probably limited,
              find X:old/$n by X:both/$ks or etc
             then A:diff/$n arrives, where it always was
               ~ bless
               along with A:diff/$n/$was,
                about knowing a previous version of itself
            
            genera standards and 
            this pressumes light into places
             to be passing qualities between $n in its conscious mode
              the seeming cellular exchanges of %these
               and their depths and approximate shapes
               play identity swaps
              vectorial qualia like things
               make infinite fields of X:diff for C
          some spaces will have things to reset
           when boundary conditions on the k,v etc
      
   //    X:diff - proper &brackstill
         we have an X:old rebuilding to X:diff for $n**
           re-indexing C users might have altered
            you should e C alterations
             esp if A far away (like they notice)
            usu Dome_7 do so
             warn when cha surprise
              brack rows not supposd to change?
            everything should use a thing that X|A interacts
            ie you osc in remote things,
             change them,
             have changes returned
          
         compare thing for key|value of X.**
          making the standard X:diff
         alt xq.i(...) finds and compares X/$n|$k
          see resolving $n
          compares may be expressed with X.variations
           sets of meaning
            like &a Xq.t='brackdiff'
          X/$el=2/$ks
           meaning it got a name unique to it
          X/$el=3/$ks
           one of its names changed
          X/$el=3/$k
           one of its keys changed
            maybe independent, if renaming sc.*, to:
          X/$el=1/$v
           one of its values changed
          X/$el=9/$k
           vanishing keys, must have a values disappear?
          X/$el=9/$n
           vanishing $n
           X/$el=9/...
            has everything it had
          
         
          X:diff.* might become X:new
           at the end:
            backend replication of X.**
            grouped by $n
             making X:new/** come out in sequence
             though it is mostly X:old
           or even when you o for it
            X:new/$search/$Xpath = X:old|diff
            X:new entirely outsourcing content:
             X:old = entirely
             X:diff = the updates
           
   =cut
    # &ha el:1, &ja el:7 (this-time), &za|da el:8 (the-time)
    # &da should emit nearly lv
    # < &bracki|&bracko
    fi.a = &acgtscq{
        # may be &a,sc,c?,el
        s = peel(s)
        num(c) and c = {el:c}
        c = peel(c)
        num(q) and c.el = q; q = null
        q = peel(q)
        c.el ||= 1
        
        # s can be a row, pipelined
        isC(s) and s = {src:s}
        else
        # exts s as sc unless stated (+ others...)
        !s.sc and s = {sc:s}
        
        # s.sc ||= s.src.sc
        
        c.el <3 and fi&apprehension_1,s,c,q
        elsif (c.el == 3) {
            # < el:3 could src=$n, sc=changes?
            #   or with s.src|sc to change, s.new|diff|gone=sc
        }
        elsif (c.el > 6) {
            # looking for something
            q.rowt = 'looking'
        }
        else {
            # < el:9 would disaffect|disconnect u|n
            #   the pipe would know how fast different patches dry up
            #    if they hold water by sheer existence, etc
            #    output of a computation fading away
        }
        
        # have a row, even for questions
        $n = s.n = Cye([q.rowt||'abrack',1])
        n.sc = s.sc || {}
        
        # row pipelined around
        s.src and ny&up = s.src
        ny&brack = A
        # < does anything ny&R?
        ny&A = A
        T.act and ny&act = T.act
        
        c.el <3 and fi&apprehension_2,s,c,q
        
        # enter|rummage
        # < fi&oi,s,c,q ({i:brack}) develop a query with multiple mediums
        #   s,c,q making waves of conversions, for arks deduced from pi
        #   these are sc,c,y of course
        c.el <3 and fi&Xio,{i:'brack'},s,c,q; return n
        else fi&Xio,{o:'brack'},s,c,q; return q.N
    }
   // s.* for &a
    # < rename a_i_1, etc?
    fi.apprehension_1 = &acgtscq{
        s.shade && isst(s.shade) and s.shade = peel(s.shade)
        s.mix && isst(s.mix) and s.mix = peel(s.mix)
        
        if (s.src) {
            $src = s.src
            if (!s.sc) {
                $sc = s.sc = ex({},src.sc)
                # < retransmit only such classes of sc
                $mix = s.mix
                if (c.noeto || mix && mix.nodeial) {
                    mix and delete mix.nodeial
                    delete sc.efrom; delete sc.eto
                }
            }
            else {
                # < el:3 could src=$n, sc=changes?
                #   or with s.src|sc to change, s.new|diff|gone=sc
                throw "src+sc"
            }
        }
        
        q.rowt ||= 'apprehension'
    }
    fi.apprehension_2 = &acgtscq{
        $n = s.n
        # mix mix -> n.sc
        each kv s.mix {
            n.sc[k] = v
        }
        # mix shade -> n.sc for a while
        s.shade || s.src and me&brackshade,n,s.shade,s.src
        # < el:2 makes its %%dome not expect redo,
        #    can replace it into there, certainly if el:3
        #     curently only if s.src'd from a c&recycled one:
                # < indexes enough to conclude that it's that
        ns&dome and me&dome_bracki,j,n
    }
   
   // Xi brack
    # index n by n%*
    #  X/k/ref(s) enumerate columns and their values
    # ongoingly to index N-news into X
    fi.Xios.brack ||= {}
    fi.Xios.brack.i = &acgtXscq{
        # binds to q.Xt
        $qas = fi&qas,X,s,c,q
        
        # z all rows, in order
        $Xn = qas('n','z')
        
        # each .sc.$gk as a name had
        $Xk = qas('k','t')
         # all via different xo are to the same xo-space?
         $Xv = qas('v','s',{via:[Xk]})
        
        # < inflating an A with millions of 'string'.length
        $N = s.N
        N ||= s.n && [s.n]
        !N and throw 'brackin?'
        each in N {
            Xn.i({n},{n})
            each kv n.sc {
                # the keys
                $kx = Xk.i({k},{n})
                #$kx = me&X_t,X,k,n,'k'
                # have their values via unique id
                $vx = Xv.i({v},{n},kx)
                #me&X_s,kx,v,n,'v'
            }
            # all our t x.z/$n anded might lead us to similar sets
            # so will s, earlier use might get to know about later
            X.z && X.z.length > 1000 and throw "Giant brack",s
        }
        return X
    }
   // Xo brack
    =pod
     e
    =cut
    fi.Xios.brack.o = &acgtXscq{
        # s.n - u-ward, what has this as n
        # s.u - n-ward, what has this as u
        # are two types of row-row linkage,
        #  that don't require the row to know %%n anymore?
        
        
    }
  
  // &Xio for &Xio for $Xqt
    # {i|o:$Xqt...}:q {thing} {how} {}:q
    # could be any medium|indexing (Xqt)
    # per direction (write+read) (Xio)
    fi.Xio = &acgtescq{
        
        # q.Xio|Xq.t <- e = {i:'brack'} || 'brack'
        typeof e == 'string' and e = {i:e}
        !e.Xio and e.Xio = haks(e)[0]; e.Xq = e[e.Xio]
        isst(e.Xq) and e.Xq = {t:e.Xq}
        q ||= {}
        # q.Xq already may know a previous &Xio
        
        $X = delete e.X
        # < Babz
        #X ||= delete e.A
        X ||= A
        
        # become A&X
        isA(X) and X = Xc&X ||= {A:X}
        
        # < ac q.allXio.$Xqt
        ex2(q,e)
        
        # know medium by name Xq.t (a=brack,t=quest,etc)
        $Xqf = fi.Xios[q.Xq.t]
        !Xqf and throw "!Xqt:"+q.Xq.t
        # of the ways  at the ground (i|o|etc)
        $Xqfio = Xqf[e.Xio]
        !Xqfio and throw "!Xio:"+q.Xq.t+"."+e.Xio
        # s is the unknown, used
        # c is mostly talking to the medium
        #   may c.where, c.sort etc
        # < q.Xq becomes the ongoing structure
        # q.* talks lower-level storage mechanics
        #  c.where compiled for xt-matching
        #   maybe sorting|weighting also
        #  q.for.t={el:9} should delete the X.t.*.z/$n?
        #   you should provide deletes about * + $n,
        #    over an interface that can receive el:6 (moves) etc
        return Xqfio (A,C,G,T,X,s,c,q)
    }
  
  // &qas enters|uses an X schematic for &Xio for $Xqt
   =pod &qas,...context -> qas(..schema) -> qis(..bits)
     ' entering an X schematic
     when the thing is as vague as it gets
     windows of noise manager
     traces of unique identity are named:
    X.Xq.$t = Xq
     Xq knows about ways into X:
    Xq.has.$k = xq
     xq describes index at X.$k
     xq.depth ||= 1, eg X.k.$scgk = x
     explicit notice of plurals
       eg X.ref refers to X.refs
      and other contrivances|hierarchies
     so we can find all $n in an X
      for generalised what-is-here
     and it may stage|re-stage changes
      el:2 or el:3 modes
     
     X itself is universal,
      names, keys and values (&X_refer) index between X..x
      many of them at once
      may converge on the same x.z.* via many paths
       < changing the set of columns per coherent set (&brackology2)
         tree-like thing, adding y&... walking
      puts its self-knowledge under X.Xq
       < once X is C, X.sc=X, X.c=X.Xq?
         so any X.c.*.has are Xq, else other c.*?
         then X.sc.t|y|c|sc.* are about some C.sc.* existing
          without isC(X.sc), since isC(X)
          so we can have C-like indexes
         since any keys, including C nks,
          can be used as the something
          the only place to not mistake 
          and X.sc wouldnt be mistaken for a CX can then know X.y|c|sc without being mistaken
      may have hooks, input handlers
       could affect anything, starting from X
        to get to the voicings
       notice them in X.*:
        X.ih=C for &nodei etc instructions
         how to clone|construct given C
        X.e (or y&A&X&e-ward from anywhere)
         est. elvising here
          &n may autovivify them
          eg bringing %ope etc
          can pointer to un-A|C-ed space,
           using whatever X.* the thing is in,
           leading through many layers of X
         staging changes to things
         is 
     Xq  per high level indexing org (Xq)
     xq  per index at X.*, how to get to x
     x   at the end of the index,
       having a bunch of values pile up there
     
     guide to X..x, and what x.z is, etc
      < conflict with structure|names already there,
        separate A to forward rename
     
     
      devolved to limbs they used to work with
      fear & greed controlling the world
      escaping the reality through intoxicating substances
      the main audience is 18-29 year olds
      so they can get involved in the projects
      an eye opener
      a situation with a way out
      to set up an animation studio
      low key independent 
     '
   =cut
    # est org at X.Xq.$Xqt = Xq
    #   for highlevel $stru-cture sharing (Xq)
    #  Xq.has.$k = xq, about X.$k
    # returns an xq creator with Xq context
    #  
    #  observe|comply to parameters of the index
    
    fi.qas = &acgtXscq{
        X.Xq ||= {}
        !q.Xq.t and throw "!q.Xq.t"
        $Xq = X.Xq[q.Xq.t] ||= {}
        Xq.t = q.Xq.t
        Xq.has ||= {}
        # < Xq beyond just {t:'brack',has:...}
        hak(q.Xq) > 1 and throw "&qas...q.Xq.* instruction"
        q.Xq = Xq
        Xq.up = X
        # may bump into e pointers from here
        # A.1.Te%catch.A.Xqt[Xq.t]
        #  which we would then go and find out more about
        #  every time we begin to ... at X space
        # pointering Te to things begins with the Xq we found it in
        #  probably finds the attachment type satisfied
        #   by a higher level connection|trigger than Xqt
        #    eg &ha would Te%catch.h.ha = Tq
        #     Tq then has indexing matching $n
        #   be used to notice how many whats are going on
        return &hue{
            # already inside Xq.t, eg 'brack'
            #  h.t -> u.t, X.$xqt base name for index bits
            #  u.t -> u.type, &X_$type index building function
            # both are required
            isst(h) and h = {t:h}
            isst(u) and u = {type:u}
            # hu are cq, for Xq+xq
            u.t && h.t and debugger
            u.t = delete h.t
            !u.t and throw "qas()!u.t"
            !u.type and throw "qas()!u.type"
            
            # some culture|habit can org there
            Xq.has ||= {}
            $xq = Xq.has[u.t] ||= {}
            xq.Xq && xq.Xq != Xq and debugger
            xq.t && xq.t != u.t and debugger
            xq.Xq = Xq
            xq.up = X
            # < find same xq.t amongst Xq.t
            # < hook up data smush patterns|memory for these *->u->xq
            
            # xq.type may be known, may compose many?
            # isfu(is) made more complex if %Te wants
            $is = fi.xqtypes[u.type]
            is and ex(u,is)
            
            # e more for xq
            if (e)
                ex(u,peel(e))
            
            # array merging, for Xq.via
            # < immutables: mex() q.ek, etc
            mex(xq,u)
            mex(Xq,h)
            
            # compute how it is
            # xq.sc - ordered hash of arks,
            #  to qis() s.sc, which may then be out of order
            isst(xq.sc) and xq.sc = peel(xq.sc)
            # xq.N - list of arks
            xq.N and xq.sc = hashkv(xq.N)
            # usual depth of one, must be keyed by xq.t
            xq.sc ||= hashkv(xq.t)
            xq.d = hak(xq.sc)
            !xq.d and throw "no size for xq:"+xq.t
            
            # value entry
            # at Xq+xq, micro to the &Xint|out s|c|q
            $o = {Xq,xq,s,c,q}
            xq.i = &scx{
                return fi&qis,X,o,s,c,x
            }
            
            return xq
        }
    }
    
    # what can be known about fi.Xf.t|s|z
    #  mix xq.* for xq.type
    #  xq.hashy|array - index material
    #   length of ^ based on:
    #  xq.sc - what qis(s.$k) (arks) to want
    #   default s[xq.t], eg s.t=$t
    #  xq.refers
    fi.xqtypes ||= {}
    fi.xqtypes.t = {hashy:1}
    fi.xqtypes.s = {array:1,refers:1}
    fi.xqtypes.z = {array:1,selfin:'multix'}
    
  //  &qis climbs X for $s for $xq, doing $c
    =pod qis(..bits)
      write or read (autovivificatorialy)
        X.$someindex ||= x += $n
       leading to x, another|inside X via $someindex
       x remembering what indexes it is in?
        joins|varies by x.z/r,
         the members being added to x locatable space
      
      similar to io.input()
      
         supplied arks as s.sc is io usual
          doing without the odd one should work
          having the index in a few shapes
          so a row can have gaps, wildcarded at x|X
           eg S Rhythm o $had/$hadnt/$has, when we can find had and has
            since X space isnt singular,
             we may be climbing two structures towards each other
              as in KnowThee
              where nesting io expressions (in|from eg S o ...)
              pull things towards each other for zapping to bits
               in X:Rhythm (re-selecting)
                X for rows forming,
                finding x (real or wild, here or there)
                 for some vectors of climb+exp
                having vectors of Xspaces involved
                  and other qualities like %mot, %may:el2
                of the solving branches
                of many parallel X..x (via loop, on $q?)
                 in rows,
                  which is expected to perceive 4d
                  X:Rhythm joining x:Match to maybe x:Found
                   it having no $hadnt x:Found ranks in x:Match
                    not-iterating, unless e handler for:
                     the few io exp in an S exp make a schema
                     it may have a sub-S to handle low-matches
                     or simply &nodei %%may:el2 for simple
                     or emit %mot:2 across that S exp of schema,
                      to whatever is almost connected to a possible $hadnt
                       leading to more possible %mot:2 desirees
                     so the S exp
                      made of io exp
                       arks|thingnesses are from params or other io exp
                       and how they relate. thus, networking
              
              X:Rhythm
               keeps track of any warp,
                such would slow the process for e introbility
                sorting by well-sorted-ness usually,
                 and what that sorting is
                as it makes X.. -> rows for io
                a process similar to:
               some x could include other x
                alt .. of X..x
                 perhaps into|with an other X|A|J also,
                 bringing an X into a %mot-or
                shuffling the fronds:
               
               X..$xy/$x connects another X..$x to there
                ie xy.z/$x, as opposed to $n
                 meta X.xqy[xy.t] = $xo
                  $xo informing of:
                   $xy having $x separating from its origin
                   how $xy differs to a normal $x
                   ie xo.zis='x' means xy.z/$x
                    all x having z index to the real item
                    might involve replacing all [old_x+] with [new_x+]
                   < have|index where clauses for the found $x(.z/$n, etc)
                 and|or:
                 meta X.xepart..$xo,$xy,$x for more complex vec
                  $xo must track places $x propagates into $xy
                   could be along X..$xy.. somehow
                  could leave the X|A|J
                   with &e facilitating wiring to versions, downstreaming
                   very any-pointey:
                    could be relating to multiple others
                     with ways in between, leading out, etc ad inf
                 so
                 you can call in your X.xqy mind if you detect any of that
                  eg to simply delete downstream x-propagations
                   may slow to examine X..$xy
                   an xy may contain weighty evidence etc
                
                seems usey for condensing %Te pointers to those x
                 by ..xy, tussled until consistent
                 knowing xy.xq is how we coord our selection of it,
                 xy.up=X=x.up
                 x.xq is how they coord themselves,
                  which we would get interested in
                 might have some traces of processes involved, why not.
                  they may be findable via x they leave around...
                 eg
                 so X.t.$t = x, x.z/$n
                  is primary (C.t index)
                  the x.up=X and x.xq describes X..x
                 so X.allx.$i = $xy, xy.z/$x = X.t.$t
                  following an x entails el:9 when+how etc
                   by some protocols gathering on x by xq
                    the various "collecting", "breakdown-of" set order
                   and being able to restate those chunks of spacetime,
                    through the time+name system
                    from the X perspective,
                     and across the network with other objects (&Supe*)
                      that are making %mot:2 etc
                     tracing its will to do anything.
                  complementary legs
                 so X.allX.$Xi.allx.$xi (two xq.type=s) also
                  for X knowing another X contains x
                   X&A and x&A can slope around
                   how to follow through time,
                    X living longer than x it knows about
                  the downstreams could be pointed to,
                   given a storable climbing-X|A exp,
                   with snapshots, many-X-shaped diff making...
                 
                 these could point further, have more index(s):
                  many X.** include various properties to X
                   eg having rows to include at some distance into X
                    eg x:wild, hops multitudes across gaps
                   eg do hooks, where|when they are located
                    their locationing becoming more specific
                   eg alternative views through schemas
                    of rows rearranged from main thing of X.*
                    very one-many spaces
                  constellations of X.**, cluster to put separate:
                   relatings to rowlegness|reason|positions
                    of more of these X.** structures
                     eg X.leg/t/$t/$xb.ness/'rowleg'/$xc
                      leg specifies eg the rowleg-ness, for row-smush
                       is for X.t/$t/$xa, has all the intent in $xc
                        which may not include any r (smush-config)
                       just to inflate to $xb gets us $xa,
                        $xb.reason, simple or complex: to $n:D joining this
                        $xb.positions of $xc involved, maybe classes in between
                        $xb.voicing of anything climbable with &voice
                        $xb.ioing of A&op - should from A:S climb into
                         the io exp and any state a downstream io might pry
                    so, having those qualities on a thing,
                     generated by the matching in io
                     that relates to where|how the match happens
                    and indexing some of them,
                     splitting up by desired uniqueness
                      usually to speed up or compress information
                  to become notions of light (x.r+)
                   travelling through space (X..x)
                   to be retracted from a downstream, eg X:Rhythmatics
                    at the &Xout el:9 level?
                     hooks would bring it up
                  
                waves become nested:
                 short lists of $very/$specific/$mediation/$before/$thing
                 become long lists of $vague/$pile/$thing
                   X.fqdn>2name>1name
                    verbosities for calling uniq items by attributes
                   X.tv>tw, tv>z
                    for which index can deduplicate others
                 
                 correlating variations on the path:
                  to thing, x.z/$n
                   $n (row) may be in many x
                    per its traces of stuff in Xspace
                  to complement,
                   eg X.align.abc.ac looking at Xspaces (rowspace?) to align
                    X.abc is a longer trip than X.ac
                     X.ac..x might talk about X.a that are binding to X.c,
                      with x.$clue for finding X.a|c,
                       selecting within them and imposing anything to u|n there
                       an ongoing theme, this ^
                     X.abc could be that relating through time?
                      has an as-time and through-time element|X-ness:
                       having proxima (types of nearness, quantified)
                       modulating, graph labeling over local extent
                     adding dimensions|layers of X perceiving X+
                   that there is a meaning possible
                    to be believed in
                    eg X.dome[r%dome].z/$n partitions $n elsewhere
                     making groupable how they are available through X.*
                     by aft-X..x filtering of x.z
                     this maybe-$n, ever-$x awareness
                      must line up with:
                       eg expecting to find history for structures
                        we have started taking apart or replacing
                        ie at what point do your limbs dreams
                         stop getting implanted in the over-limb
                   being equated|aligned and
                    what it is to mean is a whole other X
                  X..x being varying lengths
                   and qualities to A
                   bunches of it being grabbed at:
                  %dome recycles $whole X and replaces a $part of it
                   the old $part going somewhat offline
                    via our A and its new X perspective on what is at $whole
                    only available in certain senses once dome begins,
                     to those wanting to remember what it was
                   pushing stitched up X:$whole
                    A harvester
                   < generalise from per-n%dome
                     eg x** cursoring any areas of X.** we are to re-get
                     a where clause
                   $whole is like a git tree
                   its index contains all $parts
                   some being supplanted by newer $parts
                    existence of newer $parts comes via A
                     usu r%dome specifies which ..$parts are being stated into
                     having previous $whole..$parts to work from
                     being able to CRUD individual $parts..$part
                      as in lv, yet X.**-arbitrarily
                    being able or willing to CRUD X:
                     redo $whole for $parts (new X..x hashes)
                     delete $whole/$parts (X.. tidied)
                    depending on mergibility (Dome@3)
                   you must figure that by some x.z/$n being %domed 
                    and knowing its a certain X..x from before,
                     possibly amongst a set of dupes (hak(x.z)>1)
                      that arent duping anymore (due to sleepy processing)
                     what gets you into sleepy processing
                      ie C-pointing $part to adjust
                      must also say only that $part of $parts changes
                       more developing needed when T.dup
                       may be A:e to a name that is now a plurality
                       convention to leave the first one,
                        or does name@1 split into name@11,name@12
                   anyway, can redo parts of X..
                    for given pointer|ranges,
                     which become|avoid ambiguity
                 that seems to be including space we can re-include...
                 and when|how to propagate &Xout el:9
              
              the bits being the found things between X..x
               always broken down by thingnesses we can string up
               at the end of each rigid geometry thinger X..x
                x is coorded already, is itself, how it is coorded
                x.up = X
                x.X = x.top = X
                 a degree of slope (climb x.top)
                x.xq = xq = X.Xq.*.has.$xqt
                 xq.Xq = Xq = X.Xq.$Xqt
                 are the &Xstru and &Xthe x was created in
                 include some more index
                x.z are things here [r+]
                 these may provide an insider r&A?&X to mount r/*
                 eg J, having a commit X + X it might build + etc 
                  things may keep rowing from inside and out
                   forming with each other a diff pattern
                   might be T-d apart and together
                x.* (knowing x.Qt)
                are things in an x coordinated as above,
                 as distinct from ways to 
             we may %mot to el:2 the $hadnt
            
            x:had.wild.not = x:wild
             x:wild knowing pa.t=hadnt is not found
              track other x:wild from other $had (multix)
             onwards:
              x:wild.xs = [x:has]
           
           x..x:wild are things that break the type system of x
            yet include further Xspace anyway
            x:wild.t usu null|undef, may error code, have qua
             relatively against match for some reason,
              < indexed by reason, eg X.not_quite_sc.$scgk.$dist
                with the amount off.
                 these could be el-ish,
                  may compute from from several sc|etc
                   so it seems some y() -> ..x-positions
                    form the registers
                 or quanta, distance between
                to search for a blip of sound with such size|qua
                which we may then transcend the problem with,
                 by fading into another sound in the same key, etc
             how you can keep going is interesting
              usu relates to an el:2-ability being inferred
              what is needed to create, %feature magnets
             usu negate iteration through S o ...
              yet it may have a sense for whats going on
              S seeds the ways into creation
           to be able to have rows joining to rows,
            aligning or guessing through the index
          
         the thing arrives
               it could be stated as an emptiness (el:5?)
            which you mix into rows X
            at wildcarded X|x, row  the gap to yonder columns
             and mix in x as x-row selection,
              meta that the column 
           that you classify your way into,
            and mergeselect your way out of
           might often return the nearest selection to something
    =cut
    # context: Xk.i({t},{n})
    #  s.sc.$key=$value, along X..x, only ark usu xq.t
    #  c.n is what to est there
    # off the end of $x if provided
    #  is s.x, separate since s.* scooped into s.sc.*
    fi.qis = &acgtXoscx{
        $xq = o.xq
        s ||= {}
        c ||= {}
        # s.N might be either if array
        isar(s) and s = {N:s}
        else
        isar(c) and s.N = c; c = {}
        else
        # scoops s.* into s.sc.* if vague
        !s.N && !s.sc and s = {sc:s}
        # s.x = x to x..x
        x and s.x = x
        # s gets us there, c arrives with...
        
        $depth = xq.d
        $keys = xq.N || haks(xq.sc)
        s.N && s.N.length != keys.length and throw "key length"
        
        # while xq belongs to X,
        #  our notion of Xspace (where to build X.*)
        #  is subject to starting at $x,
        #   and xq.via.includes(x.xq)
        if (s.x) {
            $x = s.x
            !x.xq || !x.z and throw "s.x !x"
            !xq.via.includes(x.xq) and throw "s.x not via "+xq.t,{x,xq}
            $Xspace = x
        }
        else {
            $Xspace = X
        }
        # by name
        $index = Xspace[xq.t] ||= xq.array ? [] : {}
        $nx = index
        # the housing thinks everything is a key
        each ik keys {
            xq.N && s.N and $key = s.N[i]
            else
            s.sc and $key = s.sc[k]
            else {
                throw "qis() s.* vague", s
            }
            if (xq.array) {
                # arrefs: array allows keying by values, may uniquely
                $value = key
                nx != index and throw "array d>1"
                # mirror eg xq.t='ref'
                #  X.ref[vi]=x <-> X.refs[vi]=s
                $refst = oneor(xq,'refers', xq.t+'s')
                $refs = Xspace[refst] ||= []
                # corresponding array to hold x per value
                # < should probably index={refs[v+]<->ref[x+]}
                #   other array schemes|tools might live there
                $is = refs.indexOf(value)
                if (xq.refers && is >= 0) {
                    # uniquely, find same x
                    $vi = is
                }
                else {
                    # repeat, new x
                    $vi = refs.push(value)-1
                }
                $nex = nx[vi] ||= {}
                nx = nex
                
                # link many x by value
                if (is >= 0 && is < vi) {
                    $ox = nx[is]
                    # share array of same-valued x
                    # usu must join X.** with point-nested pointers
                    x.multix =
                    ox.multix ||= [ox]
                    x.multix.push(x)
                }
            }
            else {
                # may travel multiple layers of hashes
                !iskeyish(key) and throw "keying !string"
                $nex = nx[key] ||= {}
            }
            typeof nex != 'object' and throw "X{!object", {xq,i,key,keys,nx,nex}
            nx = nex
        }
        
        $x = nx
        # always:
        x.z ||= []
        x.up && x.up != Xspace and throw "x.up ~"
        x.xq && x.xq != xq and throw "x.xq ~"
        # < x.top? of a group of dimensiona
        x.up = Xspace
        x.xq = xq
        # < run into each other
        xq.lastq = q
        
        # magic relationising atoms (C)
        c.n and x.z.push(c.n)
        else {
            throw "no qis c to put"
        }
        
        # some x.t.$t.x.t.$t, which is 2* d=1
        #  carry on from x nowish, while playing loop with others
        #  indexing for things connected in this way and others
        #  here is where we climb X..x*..X between As
        #  and need to hang up a line to be able to call them back
        #  ie the self|other task
        return x
    }

# < see Bscape
A.1.t == 'Fish' and fi&live,J,s,ar

