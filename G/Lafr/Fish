# A emixer
$fi = self.fi = {}
self.isA = A => (A.y && A.y.A == A || A.y == A) && A.c && A.sc

 // X
   =pod
    the new X
     space for spaces of matter (its2)
     forming over and against any other|prior experience
     
     each X is for an A: X.A=A, A&X=X
     < merge X into A?
     < make X C, X now being X.sc
     
     a beach where traces hang up ways in
      a photographic field where A can know itself,
       at any level between A(.*)+ and A/C, even A/type/C
       and any moment, supposing indexing includes $moment
        or you would simply make another X
      with individual fronds of X.*
       networks of types and measures,
        in an expanse intersected by a curve
     
     A loads X with things approaching C
      X.t.$t = x, x.z/C, C.t=$t
       is a simple load of things for J
       x.z can handle dupes, see 'ressur concluded'
        other indexes|slope should be found to separate them
       that C might have no meaningful C.t, etc
        be just C.sc, eg &brackX for X.k.$gk...
        separatable by other lateralism:
       having extra coordinates for the same C|refs|etc in X...
        the X.t.. produces A/C tuples
        may share C with various X.*.... producing:
         legs of twinning:
          e wanting C/$partofC/connects:to/C:D/because
         you may specify these, as i|o things
          so you are notified|involved
           as soon as X notices rows come into that view
          and thence &ha|&n, even &increment
           may see if they start|have|stop involvement in whatever
            creating the memory of a search for fitting a formula
            which would be the ultimate thing to optimise
         so it decides to write various things about it,
          including was-something-e-wanted
         
     so they attach C,
      any ways they want
      then start walking around it
      assuming things it didnt see arent there, see 'ressur concluded'
     to X, which is also attaching to itself:
     A tends to have identifiables (At path) anywhere it spreads out:
       Aip - subnets repeating
       At - path (mind+Ct)
      along with its own X
       to arrive X into X&A.up&X (upward)
        so it acquires X.V, the supposed last version of this X
        as resolved by At+Aip, etc
       see 'A@1 scans itself'
       every X has a value for At, for X.A
        like x has a value for X..x
         they are $k (X.$k index name)
          + $ark:$v pairs for columns of that index...
          could be in x.had.$ark=$v,
           warn if another different 
         eg X.had.At="u:Blah", as in X.up.At."u:Blah".z/$X
         
         < x also knowing the index its in, its values
           x.karkv.$k.$ark=$v
            for X.$k with ordered hash of ark|columns with value
           may even track x.z/$r being input to other indexes
            a &t context may have many &Xint etc
           perhaps on X.rk = &X_s $r, &X_t $k
            so the x per $r track what X.$k.. that $r is in
         < similarly, we may X.kr = &X_t $k, &X_s $r
           may useful knowing an index appears|empties
            see xq
           with the same devicing that notices things doing the same
            of X.k.* space like X.k..x.z.* space
           an &Xint for what is &Xint-ed
     
     so X.had|karkv knows where|what|which A is in A.up&X (|V)
     and X.* in general indexes A/**:
      A/A, become X.At when they &X
      other A can be met: X.oAt
       in objects in a call in A:a, eg &ha,C(y&A:b)
       with a,b either way around
        perhaps being more o to the A:b&X above, etc
        which thing goes into the other,
         how they slope etc. all might matter
       extra how|when|why indexing may pile up here:
        X.iAt.ha.$At.z/A for where &ha,C came from, etc
       in a few steps,
        A:a may other A:b for its own ends
        and|or|which-is become elvised, imposed into there asap
        depending on what function is crossing what lines, etc
      A..A eg $dome is itself
     
     we would assume most x.z/$C
      
    so
     it can put away like &brackX,
      for multiple n%*
      while noticing refs anywhere already
       thistimes, esp something duplicating
        esp becoming complete in some way (-group) of:
       thattimes, have recyclables
        have goners eventually:
        can be 'ressur concluded' at some point
         trad match t+i @17, see &arriveRbitX
          %Te only match t, so all i are the same to it
          %Te want to accept pointerbits
           and get named (Te.t) more elabourately
           per thing we need to separate
            the arrival of qua to
           we may be able to say C:Thing/-suchapi
            cutting down on At-ness between C...$pi
            expecting any|one|many -suchapi with any name
             or some name, qua besides c&pi='suchapi'
              and not, etc. an assertion.
            delivered from any point in the slope,
             where it makes sense, is grouped...
             drops into the was-implied section of %Te/** growth
           which is the compression
            of X back into C, basically
            the 'I want this and that somewhere in here'
            from sparse tendrils of implication 
            into the tidiest job sheet possible
          
       we may be doing only some of the channel
        which should re-emerge in perfect sequence...
        they will partition by ny&act=T.act,
         see 'ressur concluded', other lateralism
         and &twlic etc, does list gapality
        
     it is used to find e-pointers
      which is often about deducing how simple it can be:
      &CX: X.t for t-path (the J..C..), having C
      &brackX:
        finding pointers to rows is new
         we tend to &brackstill the overall k:v concat
          while it is considered one big undivisible instant
          then group rows into C when it moments, eg -brackology
           from here we could generate a better-typed likeness for:
        
        could match as simple as &ja,'such,had,keys'
         might have to be all the keys (of a class)
         or be pattern matches that &voice
          &voice climbs trees of mind (the EXPR)
           while climbing chunks of the world
           the basic do sub depending on values loop
           it should walk out over X, measuring distances...
          pattern matches for &voice being transportable
          they would be pointer composing
         or match row cloned from such a row &Xout,$row
         or any other lateralism:
          row from|haswayto a certain A
           eg $dome, or Aip|At bits
           or n-ward to brack without coordinates, from a:
           or u-ward to them -> -groupology get names (in C)
            of the Km.t, having Kmc&rows
          any other X-ing the r is in
          match cloning (&ha,$n,...) from such a row, eg in V.rowrefs
           currently the only way to drop recycled domebits
            when they regenerate
            to have the osc C consistently in memory
           similar to row from certain A
         they could all be turning into an &Xout,{...},{...}
          that Te would instruct
        
        conversely, 'ressur concluded':
         the row might el:9 when these things go unmatched
         resolving the set of seemingly coming+going things
          to changes to their insides,
           when supposed together by homology|similarity:
           it may just have a key changing, becoming el:3
          to minimise overall change given extra expression and context
           things can be told apart by lateral inquiry:
            thing from same dome (A), that D^^A of ours
           or in|through-row|n-ward C having uniqueness
            compared to others in the ambigroup
        
        and be able to notice|react when it next &ha
        
        may adjust their names?
        
    as the X grows it becomes a V
     by the time
   =cut
    
  // frontend
   =pod
    these all take Xscq...
      search|thing (what we implant+excavate)
      configurance (&Xint level)
       i|o parameters, mostly for q.Xo
      question (&X_* level)
        may el:9?
        limit|replace certain x
    &Xint|out
     individual i|o parts of:
    &t
     write search down - Qish as brack c
     find any things (rows) matching c
      go for the smallest set as the one
     write what we read, inc nothing
     reads a thing!

    leads you to describe the thing you are in
    X is life+death crossing over, once matured
   =cut
    
    # us doing stuff
    fi.live = &acgt{
        $i = 5
        $c = exts({},'sit','t')
        c.oth = 1
        #4s&Bthing = Gc&B
        4s&Bthing = eny(c)
        #u Dealap
        # < see I change
        4s&Athing = A
        #As&selfpin = me&t,R,{of:'wjs',args:'ar,J,s'},'Fish'
        #As&selfpin = me&t,R,{of:'wjs',args:'flonk,J,s'},'Fish'
        while (i--)
            ~>5 Fiseh: 3
        fi&a,{fuselage:3}
    }
   // &Xint|&Xout,X|A,s,c,q||$t:Xqt,q (&middle is $Xqt)
    # Itivity of s+c
    fi.Xi = {}
    fi.Xo = {}
    # i|o {thing} {how} {}
    # could be any medium|indexing
    fi.Xint = &acgtXscqe{
        return fi&Xstru,fi.Xi,X,s,c,q,e
    }
    fi.Xout = &acgtXscqe{
        return fi&Xstru,fi.Xo,X,s,c,q,e
    }
    # CRUDJ(oin)D(iffer) on indexes
    # < q may make this into an iterator around here
    fi.Xstru = &acgtIXscqe{
        # specify X.Xq.$Xqt as q='word', q.Xq='word' or q.Xq.t
        # < expets() almost does this. or is it mightexpe(), mightpeel()?
        isst(q) && !peelish(q) and q = {Xq:{t:q}}
        q = peel(q)
        isst(q.Xq) and q.Xq = {t:q.Xq}
        # also
        e and ext2(q,peel(e))
        
        # we become A&X
        isA(X) and X = Xc&X ||= {A:X}
        else {
            debugger
        }
        
        # s is the unknown, used
        # c is mostly talking to the Itivity, may c.where, c.sort etc
        # q.Xq for the ongoing structure,
        # q.* talks lower-level Itivity and to &X_* (storage mechanics)
        #  q.for.t={el:9} should delete the X.t.*.z/$r?
        #   you should provide deletes about * + $r,
        #    over an interface that can receive el:6 (moves) etc
        #  maybe sorting|weighting
        # an Itivity (Xint|Xout) interprets per structure
        isst(I) and I = fi[I]
        $y = q.Xq && I[q.Xq.t] 
        !y and throw "!q.Xq.t:"+q.Xq.t
        return y (A,C,G,T,X,s,c,q)
    }
  
  // &t
    # Tthing that can wait for it various ways
    # c.modes of async
    fi.t = &acgtsc{
        # s,c may be $of,$t or 'I',$t
        isst(s) && !c and s = {of:I,t:s}
        s = exts({},s,'of')
        c = exts({},c,'t')
        c.t != null and s.t = delete c.t
        # s{of,t} c{el:2}
        $I = A.I || A.1.I || A.4.I
        $t = fi&Xint,s,{},'quest'
    }
    # Itivity of s+c
    # s is Qish quest - look for a thing
    # c can el:9, el:2...
    fi.Xi.quest = &acgtXscq{
        fi&qas,X,q,'k'
        each kv s {
            # the keys
            $kx = me&X_t,X,k,n,'k'
            # have their values via unique id
            me&X_s,kx,v,n,'ref'
            
        }
    }
    fi.Xo.quest = &acgtXscq{
    }
  // way
    # throw if no

  // apprehend (&ha, &ja...)
    # &ha el:1, &ja el:7 (this-time), &za|da el:8 (the-time)
    # &da should emit nearly lv
    # < &bracki|&bracko
    fi.a = &acgtscq{
        # may be &a,sc,c?,el
        s = peel(s)
        num(c) and c = {el:c}
        c = peel(c)
        num(q) and c.el = q; q = null
        q = peel(q)
        c.el ||= 1
        
        # s can be a row, pipelined
        isC(s) and s = {src:s}
        else
        # exts s as sc unless stated (+ others...)
        !s.sc and s = {sc:s}
        
        # s.sc ||= s.src.sc
        
        c.el <3 and fi&apprehension_1,s,c,q
        elsif (c.el == 3) {
            # < el:3 could src=$n, sc=changes?
            #   or with s.src|sc to change, s.new|diff|gone=sc
        }
        elsif (c.el > 6) {
            # looking for something
            q.rowt = 'looking'
        }
        else {
            # < el:9 would disaffect|disconnect u|n
            #   the pipe would know how fast different patches dry up
            #    if they hold water by sheer existence, etc
            #    output of a computation fading away
        }
        
        # have a row, even for questions
        $n = s.n = Cye([q.rowt||'abrack',1])
        n.sc = s.sc || {}
        # mix mix -> n.sc
        each kv s.mix {
            n.sc[k] = v
        }
        # mix shade -> n.sc for a while
        s.shade || s.src and me&brackshade,n,s.shade,s.src
        # row pipelined around
        s.src and ny&up = s.src
        ny&brack = A
        # < does anything ny&R?
        ny&A = A
        T.act and ny&act = T.act
        # < el:2 makes its %%dome not expect redo,
        #    can replace it into there, certainly if el:3
        #     curently only if s.src'd from a c&recycled one:
                # < indexes enough to conclude that it's that
        ns&dome and me&dome_bracki,j,n
        
        # enter|rummage
        c.el <3 and fi&Xint,A,s,c,'brack',q; return n
        else fi&Xout,A,s,c,'brack',q; return q.N
    }
    # resolving s.* (esp sc) for a &bracki
    fi.apprehension_1 = &acgtscq{
        s.shade && isst(s.shade) and s.shade = peel(s.shade)
        s.mix && isst(s.mix) and s.mix = peel(s.mix)
        
        if (s.src) {
            $src = s.src
            if (!s.sc) {
                $sc = s.sc = ex({},src.sc)
                # < retransmit only such classes of sc
                $mix = s.mix
                if (c.noeto || mix && mix.nodeial) {
                    mix and delete mix.nodeial
                    delete sc.efrom; delete sc.eto
                }
            }
            else {
                # < el:3 could src=$n, sc=changes?
                #   or with s.src|sc to change, s.new|diff|gone=sc
                throw "src+sc"
            }
        }
        
        q.rowt ||= 'apprehension'
    }
    # index n by n%*
    #  X/k/ref(s) enumerate columns and their values
    # ongoingly to index N-news into X
    fi.Xi.brack = &acgtXscq{
        # some &bracki:
        #  we create a new $n picturing:
        #  s.s|shade|mix
        #  s.s=C might be cloned,
        #   %%dome and all the usual effects
        #  n.c knows of other stuff:
        #   row is recycled
        #   was entered by some A...
        #    there is an inside, &ha while Dome is 3
        #    must be siphoned into the self sometimes
        #    instruments producing brack when acted on
        #     other bracks below the line
        
        # inflating an A with billions of 'string'.length
        
        $qas = fi&qas,X,s,c,q
        
        # z all rows, in order
        $Xn = qas('n','z')
        
        # each .sc.$gk as a name had
        $Xk = qas('k','t')
         # all via different xo are to the same xo-space?
         $Xv = qas('v',{via:[Xk]})
        
        $N = s.N
        N ||= s.n && [s.n]
        !N and throw 'brackin?'
        each in N {
            Xn.i({n})
            each kv n.sc {
                # the keys
                $kx = Xk.i({t:k},{r:n})
                #$kx = me&X_t,X,k,n,'k'
                # have their values via unique id
                me&X_s,kx,v,n,'v'
            }
            # all our _t x.z/$r anded might lead us to similar sets
            # so will _s, earlier use might get to know about later
            X.z && X.z.length > 1000 and throw "Giant brack",s
        }
        return X
    }
   // Xo brack
    =pod
     e
    =cut
    fi.Xo.brack = &acgtXscq{
        # s.n - u-ward, what has this as n
        # s.u - n-ward, what has this as u
        # are two types of row-row linkage,
        #  that don't require the row to know %%n anymore?
        
        
    }
    
  // &qas enters|uses an X schematic for &Xstru for $Xqt
   =pod
     ' entering an X schematic
     when the thing is as vague as it gets
     windows of noise manager
     traces of unique identity are named:
    X.Xq.$t = Xq
     Xq knows about ways into X:
    Xq.has.$k = xq
     xq describes index at X.$k
     xq.depth ||= 1, eg X.k.$scgk = x
     explicit notice of plurals
       eg X.ref refers to X.refs
      and other contrivances|hierarchies
     so we can find all $n in an X
      for generalised what-is-here
     and it may stage|re-stage changes
      el:2 or el:3 modes
     
     X itself is universal,
      names, keys and values (&X_refer) index between X..x
      many of them at once
      may converge on the same x.z.* via many paths
       < changing the set of columns per coherent set (&brackology2)
         tree-like thing, adding y&... walking
      puts its self-knowledge under X.Xq
       < once X is C, X.sc=X, X.c=X.Xq?
         so any X.c.*.has are Xq, else other c.*?
         then X.sc.t|y|c|sc.* are about some C.sc.* existing
          without isC(X.sc), since isC(X)
          so we can have C-like indexes
         since any keys, including C nks,
          can be used as the something
          the only place to not mistake 
          and X.sc wouldnt be mistaken for a CX can then know X.y|c|sc without being mistaken
      may have hooks, input handlers
       could affect anything, starting from X
        to get to the voicings
       notice them in X.*:
        X.ih=C for &nodei etc instructions
         how to clone|construct given C
        X.e (or y&A&X&e-ward from anywhere)
         est. elvising here
          &n may autovivify them
          eg bringing %ope etc
          can pointer to un-A|C-ed space,
           using whatever X.* the thing is in,
           leading through many layers of X
         staging changes to things
         is 
     Xq  per high level indexing org (Xq)
     xq  per index at X.*, how to get to x
     x   at the end of the index,
       having a bunch of values pile up there
     
     guide to X..x, and what x.z is, etc
      < conflict with structure|names already there,
        separate A to forward rename
     
     
      devolved to limbs they used to work with
      fear & greed controlling the world
      escaping the reality through intoxicating substances
      the main audience is 18-29 year olds
      so they can get involved in the projects
      an eye opener
      a situation with a way out
      to set up an animation studio
      low key independent 
     '
   =cut
    # est org at X.Xq.$Xqt = Xq
    #   for highlevel $stru-cture sharing (Xq)
    #  Xq.has.$k = xq, about X.$k
    # returns an xq creator with Xq context
    #  
    #  observe|comply to parameters of the index
    
    # ex with array merge
    #  eg s|c.via=[one|two] -> s.via=[one,two]
    self.mex = &scq{
        q ||= {}
        if (q.ek) {
            # fatal to want change
            
        }
        c = exable(c,s)
        return ex(s,c)
    }
    fi.qas = &acgtXscq{
        X.Xq ||= {}
        !q.Xq.t and throw "!q.Xq.t"
        $Xq = X.Xq[q.Xq.t] ||= {}
        # < Xq beyond just {t:'brack',has:...}
        hak(q.Xq) > 1 and throw "&qas...q.Xq.* instruction"
        q.Xq = Xq
        # may bump into e pointers from here
        # A.1.Te%catch.A.Xqt[Xq.t]
        #  which we would then go and find out more about
        #  every time we begin to ... at X space
        # pointering Te to things begins with the Xq we found it in
        #  probably finds the attachment type satisfied
        #   by a higher level connection|trigger than Xqt
        #    eg &ha would Te%catch.h.ha = Tq
        #     Tq then has indexing matching $n
        #   be used to notice how many whats are going on
        return &hum{
            # already inside Xq.t, eg 'brack'
            #  h.t -> u.t, X.$xqt base name for index bits
            #  u.t -> u.type, &X_$type index building function
            # both are required
            isst(h) and h = {t:h}
            isst(u) and u = {type:u}
            # hu are cq, for Xq+xq
            u.t && h.t and debugger
            u.t = delete h.t
            !u.t and throw "qas()!u.t"
            !u.type and throw "qas()!u.type"
            
            # some culture|habit can org there
            Xq.has ||= {}
            $xq = Xq.has[u.t] ||= {}
            # < find same xq.t amongst Xq.t
            
            # xq.type may be known
            
            # m more for xq
            m and mex(u,peel(m))
            
            # array merging, for Xq.via
            # < immutables: mex() q.ek, etc
            mex(Xq,h)
            
            mex(xq,u)
            
            # value entry
            # at Xq+xq, micro to the &Xint|out s|c|q
            $context = 
            xq.i = &sc{
                fi&qis,X,Xq,xq,s,c
            }
            
            return xq
        }
    }
    # what can be known about fi.Xf.t|s|z
    #  mix xq.* for xq.type
    #  xq.hashy|array - index material
    #   length of ^ based on:
    #  xq.sc - what qis(s.$k) (arks) to want
    #   default s[xq.t], eg s.t=$t
    #  xq.refers
    fi.types ||= {}
    fi.types.t = {hashy:1}
    fi.types.s = {array:1,refers:1}
    fi.types.z = {array:1,selfin:'multix'}
    fi.Xtype = &acgtXsc{
        # 
    }
    # context of Xk.i({t:k},{r:n})
    #  s.t is input to qt.type='t', etc
    #   < s.sc.$ark=$v
    #  c.r is what to est there
    fi.qis = &acgtX,Xq,xq,s,c{
        # }
        s ||= {}
        # just ['onecell']
        isar(c) and s.N = c; c = {}
        isar(s) and s = {N:s}
        =pod having bits
         supplied arks as s.sc is io usual?
          doing without the odd one should work
          having the index in a few shapes
          so a row can have gaps, wildcarded at x|X
           eg S Rhythm o had/hadnt/has, when we can find had and has
            since X space isnt singular,
             we may be climbing two structures towards each other
              as in KnowThee
              where nesting io expressions (in|from eg S o ...)
              pull things towards each other for zapping to bits
               in X:Rhythm (re-selecting)
                X for rows forming,
                finding x (real or wild, here or there)
                 for some vectors of climb+exp
                having vectors of Xspaces involved
                  and other qualities like %mot, %may:el2
                of the solving branches
                of many parallel X..x (via loop, on $q?)
                 in rows,
                  which is expected to perceive 4d
                  X:Rhythm joining x:Match to maybe x:Found
                   it having no $hadnt x:Found ranks in x:Match
                    not-iterating, unless e handler for:
                     the few io exp in an S exp make a schema
                     it may have a sub-S to handle low-matches
                     or simply &nodei %%may:el2 for simple
                     or emit %mot:2 across that S exp of schema,
                      to whatever is almost connected to a possible $hadnt
                       leading to more possible %mot:2 desirees
                     so the S exp
                      made of io exp
                       arks|thingnesses are from params or other io exp
                       and how they relate. thus, networking
              
              X:Rhythm
               keeps track of any warp,
                such would slow the process for e intro
                sorting by well-sorted-ness usually,
                 and what that sorting is
               
               so it has alternative|floody collections of x at X
                an x (coorded somewhere, originally)
                to connect that x via another X..x
                 must track places $x propagates to become $xy:
                  where in X..$xy.. lies that other $x
                   it could be beyond resolving .. for some view of X,
                    if using storable traces of things, to locate $x
                   or it could be $xy.z/$x
                    instead of the .z/$r the usu magic thing join C
                   noted as weird in xy.xq (schema for X..$xy..$x)
                   # blurring xy|xyk, the connections to a X.*|x for such connections
                   #  hmm... x.z/$r meaning X.$xqt..
                   #   or x/... meaning 
                   maybe higher indexed:
                    eg X.xqy.lizt_for_x = xy
                     just X.xqy.*:xyt shows which X.$xyt../$xyk
                     $xyk having indexes copied from $x it accumulates
                      as|under $xyt, the reason to smush
                   very any-pointey:
                    could be relating to multiple others
                     with ways in between, leading out, etc ad inf
                    so you can call in your X.xqy mind if you detect any
                   eg to simply delete downstream x-propagations
                    may slow to examine X..$xq
                    an xy may contain weighty evidence etc
                    xy has no xy.z, is only to mention X.lizt_for_x exists
                    xy.z could be, it is a sequence that is here
                     
                     typed to accumulate some:
                      all x in X.lizt_for_x?
                      but then the x-propagation tracking must know
                      perhaps it does know
                       where in ..x.. lies other x 
                        inc x.z, 
                    might have some traces of processes involved, why not.
                     they may be findable via x they leave around...
                 so X.t.$t.z/$hadnt:x
                  is primary (C.t index)
                 so X.lizt_for_x.$i.z/$hadnt:x
                  following an x entails el:9 when+how etc
                   by some protocols gathering on x by xq
                    the various "collecting", "breakdown-of" set order
                   and being able to restate those chunks of spacetime,
                    through the time+name system
                    from the X perspective,
                     and across the network with other objects (&Supe*)
                      that are making %mot:2 etc
                     tracing its will to do anything.
                  complementary legs
                 so X.allX.$Xi.allx.$xi (two xq.type=s) also
                  for X knowing another X contains x
                   X&A and x&A can slope around
                   how to follow through time,
                    X living longer than x it knows about
                  the downstreams could be pointed to,
                   given a storable climbing-X|A exp,
                   with snapshots, dual-X-shaped diff making...
                 
                 these could point further, have more index(s):
                  many X.** include various properties to X
                   eg having rows to include at some distance into X
                    eg x:wild
                   eg do hooks, where|when they are located
                    their locationing becoming more specific
                   eg alternative views through schemas
                    of rows rearranged from main thing of X.*
                    very one-many spaces
                  constellations of X.**, cluster to put separate:
                   relatings to rowlegness|reason|positions
                    of more of these X.** structures
                     eg X.leg/t/$t/$xb.ness/'rowleg'/$xc
                      leg specifies eg the rowleg-ness, for row-smush
                       is for X.t/$t/$xa, has all the intent in $xc
                        which may not include any r (smush-config)
                       just to inflate to $xb gets us $xa,
                        $xb.reason, simple or complex: to $r:D joining this
                        $xb.positions of $xc involved, maybe classes in between
                        $xb.voicing of anything climbable with &voice
                        $xb.ioing of A&op - should from A:S climb into
                         the io exp and any state a downstream io might pry
                    so, having those qualities on a thing,
                     generated by the matching in io
                     that relates to where|how the match happens
                    and indexing some of them,
                     splitting up by desired uniqueness
                      usually to speed up or compress information
                  to become notions of light (x.r+)
                   travelling through space (X..x)
                   to be retracted from a downstream, eg X:Rhythmatics
                    at the &Xout el:9 level?
                     hooks would bring it up
                  
                  waves become nested:
                   short lists of $very/$specific/$mediation/$before/$thing
                   become long lists of $vague/$pile/$thing
                   X.fqdn>2name>1name
                    verbosities for calling uniq items by attributes
                   X.tv>tw, tv>z
                    for which index can deduplicate others
                 
                 correlating variations on the path:
                  to thing, x.z/$r
                   $r (row, $n) may be in many x
                    per its traces of stuff in Xspace
                  to complement,
                   eg X.align.abc.ac looking at Xspaces (rowspace?) to align
                    X.abc is a longer trip than X.ac
                     X.ac..x might talk about X.a that are binding to X.c,
                      with x.$clue for finding X.a|c,
                       selecting within them and imposing anything to u|n there
                       an ongoing theme, this ^
                     X.abc could be that relating through time?
                      has an as-time and through-time element|X-ness:
                       having proxima (types of nearness, quantified)
                       modulating, graph labeling over local extent
                     adding dimensions layers X perceiving X+
                   that there is a meaning possible
                    to be believed in
                    eg X.dome[r%dome].z/$r partitions $r
                     making groupable how they are available through X.*
                     by aft-X..x filtering of x.z
                     this maybe-$r, ever-$x awareness
                      must line up with:
                       eg expecting to find history for structures
                        we have started taking apart or replacing
                        ie at what point do your limbs dreams
                         stop getting implanted in the over-limb
                   being equated|aligned and what it is to mean is a whole other X.
                  X..x being varying lengths
                   and qualities to A
                   bunches of it being grabbed at:
                  %dome recycles $whole X and replaces a $part of it
                   the old $part going somewhat offline
                    via our A and its new X perspective on what is at $whole
                    only available in certain senses once dome begins,
                     to those wanting to remember what it was
                   pushing stitched up X:$whole
                    A harvester
                   < generalise from per-n%dome
                     eg x** cursoring any areas of X.** we are to re-get
                     a where clause
                  $whole is like a git tree
                   its index contains all $parts
                   some being supplanted by newer $parts
                    existence of newer $parts comes via A
                     usu r%dome specifies which ..$parts are being stated into
                     having previous $whole..$parts to work from
                     being able to CRUD individual $parts(dome)..$part
                      as in lv, yet X.**-arbitrarily
                    being able or willing to CRUD X:
                     redo $whole for $parts (new X..x hashes)
                     delete $whole/$parts (X.. tidied)
                    depending on mergibility (Dome@3)
                   you must figure that by some x.z/$r being %domed 
                   
                   unless that row (whatever x.z/$r )
                   $part should refer to itfrom X..$specific|$vague.z/$r
                   x:vague.xq.domes=1, eg the $r recycled
                   x:specific can then replace parts it 
                   can replace parts of X
                    for 
                 that seems to be including space we can re-include...
                 and when|how to propagate &Xout el:9
              the bits being the found things between X..x
               always broken down by thingnesses we can string up
               at the end of each rigid geometry thinger X..x
                x is coorded already, is itself, how it is coorded
                x.up = X
                x.X = x.top = X
                 a degree of slope (climb x.top)
                x.xq = xq = X.Xq.*.has.$xqt
                 xq.Xq = Xq = X.Xq.$Xqt
                 are the &Xstru and &Xthe x was created in
                 include some more index
                x.z are things here [r+]
                 these may provide an insider r&A?&X to mount r/*
                 eg J, having a commit X + X it might build + etc 
                  things may keep rowing from inside and out
                   forming with each other a diff pattern
                   might be T-d apart and together
                x.* (knowing x.Qt)
                are things in an x coordinated as above,
                 as distinct from ways to 
             we may %mot to el:2 the $hadnt
            x:had.wild.not = x:wild
             x:wild knowing pa.t=hadnt is not found
              track other x:wild from other $had (multix)
             onwards:
              x:wild.xs = [x:has]
           x..x:wild are things that break the type system of x
            x:wild.t usu null|undef, may error code, have qua
             relatively against match for some reason,
              < indexed by reason, eg X.not_quite_sc.$scgk.$dist
                with the amount off.
                 these could be el-ish,
                  may compute from from several sc|etc
                   so it seems some y() -> ..x-positions
                    form the registers
                 or quanta, distance between
                to search for a blip of sound with such size|qua
                which we may then transcend the problem with,
                 by fading into another sound in the same key, etc
             how you can keep going is interesting
              usu relates to an el:2-ability being inferred
              what is needed to create, %feature magnets
            negating iteration
             to most sense of: S o $thing/*/*
             seeds the ways into creation
           to be able to have rows joining to rows,
            aligning or guessing through the index
          
         the thing arrives
               it could be stated as an emptiness (el:5?)
              such quanta could be ex
            which you mix into rows X
            at wildcarded X|x, row  the gap to yonder columns
             and mix in x as x-row selection,
              meta that the column 
           that you classify your way into,
            and mergeselect your way out of
           might often return the nearest selection to something
        =cut
        
        $depth = xq.d || xq.sc && hak(xq.sc) || 1
        # hash keys ordered?
        # some xo.t.xo.t, which is 2* d=1
        #  indexing for things connected in this way and others
        depth != N.length
        c == 1 and c = {}
        # here is where we climb X..x*..X between As
        # and need to hang up a line to be able to call them back
        #  ie the self|other task
        
    }
  
  // &X_t|s|z lowlevels
      =write or read (autovivificatorialy)
        X.$someindex ||= x += $r
       leading to x, another|inside X via $someindex
       x remembering what indexes it is in?
        joins|varies by x.z/r,
         the members being added to x locatable space
      =cut 
        
        # the X/$t += r
        # t must be string, r could be anything
        # in &RbitXarrive it is R, &brackX it is a row
        fi.X_t = &acgtXtrk{
            k ||= 't'
            X[k] ||= {}
            
            $x = X[k][t] ||= {};
            x.z ||= [];
            r && x.z.push(r)
            return x
        }
        # the X/uniq($s) += r
        fi.X_s = &acgtXsr,kf,kfs{
            kf ||= 's'
            kfs ||= kf+'s'
            # by id of the value
            $fs = X[kfs] ||= [];
            $vi = fs.indexOf(s);
            vi < 0 and vi = fs.push(s)-1
            $f = X[kf] ||= {};
            $x = f[vi] ||= {};
            x.z ||= [];
            r && x.z.push(r);
            return x
        }
        # the X/$s += r, $s repeatable
        #  no x will have more than one r
        fi.X_z = &acgtXsr,kf,kfs{
            # to avoid conflict with x.z
            kf ||= 'lizt'
            kfs ||= kf+'s'
            # by id of the value, each time it occurs
            $fs = X[kfs] ||= []
            $vi = fs.push(s)-1
            $f = X[kf] ||= {};
            $x = f[vi] ||= {};
            # each x knows the others
            # looser matches for others may be done above
            $is = fs.indexOf(s)
            if (is < vi) {
                $ox = f[is]
                # usu must join X.** with point-nested pointers
                x.multix =
                ox.multix ||= [ox]
                x.multix.push(x)
            }
            x.z ||= [];
            r && x.z.push(r);
            return x
        }
        
  // tues

# < see Bscape
fi&live,1

# use this to serve &t

n t  s:vefge

