# A emixer
$fi = self.fi = {}
~>3 newbits:
# the new X, is a C
#  it can put away like brackX,
#   for multiple n%*
#  while noticing refs anywhere already
#   thistimes, esp something duplicating
#    esp becoming complete in some way (-group) of:
#   thattimes, have recyclables
#    have goners eventually:
#    can be concluded at some point
#    we may be doing only some of the channel,
#    which should re-emerge in perfect sequence...
#    they will partition by ny&act=T.act,

=pod
as the X grows it becomes a V
 by the time 
these all take Xscq...
  search (what we implant+excavate)
  configurance (&Xint level)
  question (&X_* level)
    may el:9?
    limit|replace certain x
&Xint
 individual parts of:
&t
 write search down - Qish as brack c
 find any things (rows) matching c
  go for the smallest set as the one
 write what we read, inc nothing
 reads a thing!

leads you to described the thing you are in
X is life+death crossing over, once matured

=cut
  // m
    # could be any medium|indexing
    fi.Xint = &acgtXscq{
        return fi&Xstru,fi.Xinter,X,s,c,q
    }
    fi.Xout = &acgtXscq{
        return fi&Xstru,fi.Xouter,X,s,c,q
    }
    
    # could be add|remove
    fi.Xstru = &acgtIXscq{
        q = exts({},q,'stru')
        isst(I) and I = fi[I]
        
        X.sc and X = Xs&X ||= {A:X}
        # per structure,
        #  so X/$stru/has/$k, as in X.$k
        #   then later as we have|extract value for $k
        return I[q.stru] (A,C,G,T,X,Q,s,c,q)
    }
    =qas' entering an X schematic
    X.stru.$stru.has.$k=$c
     index at X.$k is described by $c
     c.depth usu 1, eg X.k.$scgk=x
     notice plural of $k, eg X.ref refers to X.refs
     so we can find all n in any index
      for generalised what-is
     < conflict with structure|names already there,
       separate A to forward rename
    =cut'
    fi.qas = &acgtXqkc{
        
        X.stru ||= {}
        $Q = X.stru[q.stru] ||= {}
        
        Q.has ||= {}
    }
    fi.Xinter = {}
    # s is Qish quest - look for a thing
    # c can el:9, el:2...
    fi.Xinter.quest = &acgtXQscq{
        fi&qas,X,q,'k'
        fi&qas,X,q,'k'
        Q.has.k ||= {}
        # values in refs, rows with them in ref
        #  which only happens inside k: X/$k/$ref
        Q.has.ref ||= {per:'k',refers:'refs'}
        each kv s {
            # the keys
            $kx = me&X_t,X,k,n,'k'
            # have their values via unique id
            me&X_s,kx,v,n,'ref'
            
        }
    }
    fi.Xouter = {}
    fi.Xouter.quest = &acgtXscq{
    }

    # index n by n%*
    #  X/k/ref(s) enumerate columns and their values
    # ongoingly to index N-news into X
    fi.Xinter.brack = &acgtXscq{
        # some &bracki:
        #  we create a new $n picturing:
        #  s.s|shade|mix
        #  s.s=C might be cloned,
        #   %%dome and all the usual effects
        #  n.c knows of other stuff:
        #   row is recycled
        #   was entered by some A...
        #    there is an inside, &ha while Dome is 3
        #    must be siphoned into the self sometimes
        #    instruments producing brack when acted on
        #     other bracks below the line
        
        # 
        X ||= {}
        each in N {
            each kv n.sc {
                # the keys
                $kx = me&X_t,X,k,n,'k'
                # have their values via unique id
                me&X_s,kx,v,n,'ref'
            }
        }
        return X
    }
    
  // &X_t|s|refer for Nodar
      =write or read (autovivificatorialy)
        X.$someindex ||= x += $r
       leading to x, another|inside X via $someindex
       x remembering what indexes it is in?
        joins|varies by x.z/r,
         the members being added to x locatable space
      =cut 
        
        # the X/$t += r
        # t must be string, r could be anything
        # in &RbitXarrive it is R, &brackX it is a row
        fi.X_t = &acgtXtrk{
            k ||= 't'
            X[k] ||= {}
            
            $x = X[k][t] ||= {};
            x.z ||= [];
            r && x.z.push(r)
            return x
        }
        # the X/uniq($s) += r
        fi.X_s = &acgtXsr,kf{
            kf ||= 's'
            return me&X_refer,X,s,r,kf
        }
        fi.X_refer = &acgtXsr,kf,kfs{
            !kf and throw "named"
            kfs ||= kf+'s'
            # by id of the value
            $fs = X[kfs] ||= [];
            $vi = fs.indexOf(s);
            vi < 0 and vi = fs.push(s)-1
            $f = X[kf] ||= {};
            $x = f[vi] ||= {};
            x.z ||= [];
            r && x.z.push(r);
            return x
        }
        
  // tues
    # Tthing that can wait for it various ways
    # c.modes of async
    fi.t = &acgtsc{
        # s,c may be $of,$t or 'I',$t
        isst(s) && !c and s = {of:I,t:s}
        s = exts({},s,'of')
        c = exts({},c,'t')
        c.t != null and s.t = delete c.t
        # s{of,t} c{el:2}
        $I = A.I || A.1.I || A.4.I
        $t = fi&Xint,s,{}
    }
  // w
    # throw if no


# < see Bscape
#4s&Bthing = Gc&B
4s&Bthing = 
#u Dealap
# < see I change
4s&Athing = A
#As&selfpin = me&t,R,{of:'wjs',args:'ar,J,s'},'Fish'
#As&selfpin = me&t,R,{of:'wjs',args:'flonk,J,s'},'Fish'
$i = 5
while (i--)
    ~>5 Fiseh: 2
fi&Xint,A,{}

# use this to serve &t

n t  s:vefge

