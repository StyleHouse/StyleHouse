# A emixer
$fi = self.fi = {}
 // X
   =pod
    the new X
     space for spaces of matter (its2)
     forming over and against any other|prior experience
     
     each X is for an A: X.A=A, A&X=X
     < merge X into A?
     < make X C, X now being X.sc
     
     a beach where traces hang up ways in
      a photographic field where A can know itself,
       at any level between A(.*)+ and A/C, even A/type/C
       and any moment, supposing indexing includes $moment
        or you would simply make another X
      with individual fronds of X.*
       networks of types and measures,
        in an expanse intersected by a curve
     
     A loads X with things approaching C
      X.t.$t = x, x.z/C, C.t=$t
       is a simple load of things for J
       x.z can handle dupes, see 'ressur concluded'
        other indexes|slope should be found to separate them
       that C might have no meaningful C.t, etc
        be just C.sc, eg &brackX for X.k.$gk...
        separatable by other lateralism:
       having extra coordinates for the same C|refs|etc in X...
        the X.t.. produces A/C tuples
        may share C with various X.*.... producing:
         legs of twinning:
          e wanting C/$partofC/connects:to/C:D/because
         you may specify these, as i|o things
          so you are notified|involved
           as soon as X notices rows come into that view
          and thence &ha|&n, even &increment
           may see if they start|have|stop involvement in whatever
            creating the memory of a search for fitting a formula
            which would be the ultimate thing to optimise
         so it decides to write various things about it,
          including was-something-e-wanted
         
     so they attach C,
      any ways they want
      then start walking around it
      assuming things it didnt see arent there, see 'ressur concluded'
     to X, which is also attaching to itself:
     A tends to have identifiables (At path) anywhere it spreads out:
       Aip - subnets repeating
       At - path (mind+Ct)
      along with its own X
       to arrive X into X&A.up&X (upward)
        so it acquires X.V, the supposed last version of this X
        as resolved by At+Aip, etc
       see 'A@1 scans itself'
       every X has a value for At, for X.A
        like x has a value for X..x
         they are $k (X.$k index name)
          + $ark:$v pairs for columns of that index...
          could be in x.had.$ark=$v,
           warn if another different 
         eg X.had.At="u:Blah", as in X.up.At."u:Blah".z/$X
         
         < x also knowing the index its in, its values
           x.karkv.$k.$ark=$v
            for X.$k with ordered hash of ark|columns with value
           may even track x.z/$r being input to other indexes
            a &t context may have many &Xint etc
           perhaps on X.rk = &X_s $r, &X_t $k
            so the x per $r track what X.$k.. that $r is in
         < similarly, we may X.kr = &X_t $k, &X_s $r
           may useful knowing an index appears|empties
            see xq
           with the same devicing that notices things doing the same
            of X.k.* space like X.k..x.z.* space
           an &Xint for what is &Xint-ed
     
     so X.had|karkv knows where|what|which A is in A.up&X (|V)
     and X.* in general indexes A/**:
      A/A, become X.At when they &X
      other A can be met: X.oAt
       in objects in a call in A:a, eg &ha,C(y&A:b)
       with a,b either way around
        perhaps being more o to the A:b&X above, etc
        which thing goes into the other,
         how they slope etc. all might matter
       extra how|when|why indexing may pile up here:
        X.iAt.ha.$At.z/A for where &ha,C came from, etc
       in a few steps,
        A:a may other A:b for its own ends
        and|or|which-is become elvised, imposed into there asap
        depending on what function is crossing what lines, etc
      A..A eg $dome is itself
     
     we would assume most x.z/$C
      
    so
     it can put away like &brackX,
      for multiple n%*
      while noticing refs anywhere already
       thistimes, esp something duplicating
        esp becoming complete in some way (-group) of:
       thattimes, have recyclables
        have goners eventually:
        can be 'ressur concluded' at some point
         trad match t+i @17, see &arriveRbitX
          %Te only match t, so all i are the same to it
          %Te want to accept pointerbits
           and get named (Te.t) more elabourately
           per thing we need to separate
            the arrival of qua to
           we may be able to say C:Thing/-suchapi
            cutting down on At-ness between C...$pi
            expecting any|one|many -suchapi with any name
             or some name, qua besides c&pi='suchapi'
              and not, etc. an assertion.
            delivered from any point in the slope,
             where it makes sense, is grouped...
             drops into the was-implied section of %Te/** growth
           which is the compression
            of X back into C, basically
            the 'I want this and that somewhere in here'
            from sparse tendrils of implication 
            into the tidiest job sheet possible
          
       we may be doing only some of the channel
        which should re-emerge in perfect sequence...
        they will partition by ny&act=T.act,
         see 'ressur concluded', other lateralism
         and &twlic etc, does list gapality
        
     it is used to find e-pointers
      which is often about deducing how simple it can be:
      &CX: X.t for t-path (the J..C..), having C
      &brackX:
        finding pointers to rows is new
         we tend to &brackstill the overall k:v concat
          while it is considered one big undivisible instant
          then group rows into C when it moments, eg -brackology
           from here we could generate a better-typed likeness for:
        
        could match as simple as &ja,'such,had,keys'
         or match entire row as cloned sc.$k=$v
         parts could be pattern matches for C, making transportable
         or match row cloned from such a row
         or any other lateralism:
          row from|haswayto a certain A
           eg $dome, or Aip|At bits
           or n-ward to brack without coordinates, from a:
           or u-ward to them -> -groupology get names (in C)
            of the Km.t, having Kmc&rows
          any other X-ing the r is in
          match cloning (&ha,$n,...) from such a row, eg in V.rowrefs
           currently the only way to drop recycled domebits
            when they regenerate
            to have the osc C consistently in memory
           similar to row from certain A
        
        conversely, 'ressur concluded':
         the row might el:9 when these things go unmatched
         resolving the set of seemingly coming+going things
          to changes to their insides,
           when supposed together by homology|similarity:
           it may just have a key changing, becoming el:3
          to minimise overall change given extra expression and context
           things can be told apart by lateral inquiry:
            thing from same dome (A), that D^^A of ours
           or in|through-row|n-ward C having uniqueness
            compared to others in the ambigroup
        
        and be able to notice|react when it next &ha
        
        may adjust their names?
        
    as the X grows it becomes a V
     by the time
   =cut
    
  // frontend
   =pod
    these all take Xscq...
      search|thing (what we implant+excavate)
      configurance (&Xint level)
       i|o parameters, mostly for q.Xo
      question (&X_* level)
        may el:9?
        limit|replace certain x
    &Xint|out
     individual i|o parts of:
    &t
     write search down - Qish as brack c
     find any things (rows) matching c
      go for the smallest set as the one
     write what we read, inc nothing
     reads a thing!

    leads you to describe the thing you are in
    X is life+death crossing over, once matured
   =cut
    # us doing stuff
    fi.live = &acgt{
        $i = 5
        c.oth = 1
        #4s&Bthing = Gc&B
        4s&Bthing = eny(c)
        #u Dealap
        # < see I change
        4s&Athing = A
        #As&selfpin = me&t,R,{of:'wjs',args:'ar,J,s'},'Fish'
        #As&selfpin = me&t,R,{of:'wjs',args:'flonk,J,s'},'Fish'
        while (i--)
            ~>5 Fiseh: 3
        fi&a,{fuselage:3}
    }
    # i|o {thing} {how} {}
    # could be any medium|indexing
    fi.Xint = &acgtXscqe{
        return fi&Xstru,fi.Xi,X,s,c,q,e
    }
    fi.Xout = &acgtXscqe{
        return fi&Xstru,fi.Xo,X,s,c,q,e
    }
    # CRUDJ(oin)D(iffer) on indexes
    self.isA = A => A.y == A && A.c && A.sc
    fi.Xstru = &acgtIXscqe{
        # specify X.Xq.$Xqt as q='word', q.Xq='word' or q.Xq.t
        # < expets() almost does this. or is it mightexpe(), mightpeel()?
        isst(q) && !peelish(q) and q = {Xq:{t:q}}
        q = peel(q)
        isst(q.Xq) and q.Xq = {t:q.Xq}
        # also
        e and ext2(q,peel(e))
        
        # we become A&X
        isA(X) and X = Xc&X ||= {A:X}
        
        # s is the unknown, used
        # c is mostly talking to the Itivity, may c.where, c.sort etc
        # q.Xq for the ongoing structure,
        # q.* talks lower-level Itivity and to &X_* (storage mechanics)
        #  q.for.t={el:9} should delete the X.t.*.z/$r?
        #   you should provide deletes about * + $r,
        #    over an interface that can receive el:6 (moves) etc
        #  maybe sorting|weighting
        # an Itivity (Xint|Xout) interprets per structure
        isst(I) and I = fi[I]
        $y = q.Xq && !I[q.Xq.t] 
        !y and throw "!q.Xq.t:"+q.Xq.t
        return y (A,C,G,T,X,s,c,q)
    }
  // &qas enters|uses an X schematic for Xint|Xout
   =pod
     ' entering an X schematic
     when the thing is as vague as it gets
     windows of noise manager
     traces of unique identity are named:
    X.Xq.$t = Xq
     Xq knows about ways into X:
    Xq.has.$k = xq
     xq describes index at X.$k
     xq.depth ||= 1, eg X.k.$scgk = x
     explicit notice of plurals
       eg X.ref refers to X.refs
      and other contrivances|hierarchies
     so we can find all $n in an X
      for generalised what-is-here
     and it may stage|re-stage changes
      el:2 or el:3 modes
     
     X itself is universal,
      names, keys and values (&X_refer) index between X..x
      many of them at once
      may converge on the same x.z.* via many paths
       < changing the set of columns per coherent set (&brackology2)
         tree-like thing, adding y&... walking
      puts its self-knowledge under X.Xq
       < once X is C, X.sc=X, X.c=X.Xq?
         so any X.c.*.has are Xq, else other c.*?
         then X.sc.t|y|c|sc.* are about some C.sc.* existing
          without isC(X.sc), since isC(X)
          so we can have C-like indexes
         since any keys, including C nks,
          can be used as the something
          the only place to not mistake 
          and X.sc wouldnt be mistaken for a CX can then know X.y|c|sc without being mistaken
      may have hooks, input handlers
       could affect anything, starting from X
        to get to the voicings
       notice them in X.*:
        X.ih=C for &nodei etc instructions
         how to clone|construct given C
        X.e (or y&A&X&e-ward from anywhere)
         est. elvising here
          &n may autovivify them
          eg bringing %ope etc
          can pointer to un-A|C-ed space,
           using whatever X.* the thing is in,
           leading through many layers of X
         staging changes to things
         is 
     Xq  per high level indexing org (Xq)
     xq  per index at X.*, how to get to x
     x   at the end of the index,
       having a bunch of values pile up there
     
     guide to X..x, and what x.z is, etc
      < conflict with structure|names already there,
        separate A to forward rename
     
     
      devolved to limbs they used to work with
      fear & greed controlling the world
      escaping the reality through intoxicating substances
      the main audience is 18-29 year olds
      so they can get involved in the projects
      an eye opener
      a situation with a way out
      to set up an animation studio
      low key independent 
     '
   =cut
    # est org for highlevel $stru-cture (Xq)
    #  it .has.$k = xq
    #  observe|comply to parameters of the index
    fi.qas = &acgtXscqhu{
        X.Xq ||= {}
        $Xq = X.Xq[q.Xq.t] ||= {}
        # may bump into e pointers from here
        # hu are cq for Xq|xq
        #  some culture|habit can org there
        Q.has ||= {}
        Q.has.k ||= {}
        # values in refs, rows with them in ref
        #  which only happens inside k: X/$k/$ref
        Q.has.ref ||= {per:'k',refers:'refs'}
    }
    # Itivity of s+c
    fi.Xi = {}
    fi.Xo = {}
  
  // &t
    # Tthing that can wait for it various ways
    # c.modes of async
    fi.t = &acgtsc{
        # s,c may be $of,$t or 'I',$t
        isst(s) && !c and s = {of:I,t:s}
        s = exts({},s,'of')
        c = exts({},c,'t')
        c.t != null and s.t = delete c.t
        # s{of,t} c{el:2}
        $I = A.I || A.1.I || A.4.I
        $t = fi&Xint,s,{},'quest'
    }
    # Itivity of s+c
    # s is Qish quest - look for a thing
    # c can el:9, el:2...
    fi.Xi.quest = &acgtXscq{
        fi&qas,X,q,'k'
        each kv s {
            # the keys
            $kx = me&X_t,X,k,n,'k'
            # have their values via unique id
            me&X_s,kx,v,n,'ref'
            
        }
    }
    fi.Xo.quest = &acgtXscq{
    }
  // way
    # throw if no

  // apprehend (&ha, &ja...)
    # &ha el:1, &ja el:7 (this-time), &za|da el:8 (the-time)
    # &da should emit nearly lv
    # < &bracki|&bracko
    fi.a = &acgtscq{
        # may be &a,sc,c?,el
        s = peel(s)
        num(c) and c = {el:c}
        c = peel(c)
        num(q) and c.el = q; q = null
        q = peel(q)
        c.el ||= 1
        
        # s can be a row, pipelined
        isC(s) and s = {src:s}
        else
        # exts s as sc unless stated (+ others...)
        !s.sc and s = {sc:s}
        
        # s.sc ||= s.src.sc
        
        c.el <3 and fi&apprehension_1,s,c,q
        elsif (c.el == 3) {
            # < el:3 could src=$n, sc=changes?
            #   or with s.src|sc to change, s.new|diff|gone=sc
        }
        elsif (c.el > 6) {
            # looking for something
            q.rowt = 'looking'
        }
        else {
            # < el:9 would disaffect|disconnect u|n
            #   the pipe would know how fast different patches dry up
            #    if they hold water by sheer existence, etc
            #    output of a computation fading away
        }
        
        # have a row, even for questions
        $n = q.n = Cye([q.rowt||'abrack',1])
        n.sc = s.sc || {}
        # mix shade -> n.sc for a while
        s.shade || s.src and me&brackshade,n,s.shade,s.src
        # row pipelined around
        s.src and ny&up = s.src
        ny&brack = A
        # < does anything ny&R?
        ny&A = A
        T.act and ny&act = T.act
        
        # enter|rummage
        c.el <3 and fi&Xint,A,s,c,'brack',q; return n
        else fi&Xout,A,s,c,'brack',q; return q.N
    }
    # resolving s.* (esp sc) for a &bracki
    fi.apprehension_1 = &acgtscq{
        s.shade && isst(s.shade) and s.shade = peel(s.shade)
        s.mix && isst(s.mix) and s.mix = peel(s.mix)
        
        if (s.src) {
            $src = s.src
            if (!s.sc) {
                $sc = s.sc = ex({},src.sc)
                # < retransmit only such classes of sc
                $mix = s.mix
                if (c.noeto || mix && mix.nodeial) {
                    mix and delete mix.nodeial
                    delete sc.efrom; delete sc.eto
                }
            }
            else {
                # < el:3 could src=$n, sc=changes?
                #   or with s.src|sc to change, s.new|diff|gone=sc
            }
        }
        
        q.rowt ||= 'apprehension'
    }


    # index n by n%*
    #  X/k/ref(s) enumerate columns and their values
    # ongoingly to index N-news into X
    fi.Xi.brack = &acgtXscq{
        # some &bracki:
        #  we create a new $n picturing:
        #  s.s|shade|mix
        #  s.s=C might be cloned,
        #   %%dome and all the usual effects
        #  n.c knows of other stuff:
        #   row is recycled
        #   was entered by some A...
        #    there is an inside, &ha while Dome is 3
        #    must be siphoned into the self sometimes
        #    instruments producing brack when acted on
        #     other bracks below the line
        
        fi&qas,X,q,'k'
        # 
        X ||= {}
        each in N {
            each kv n.sc {
                # the keys
                $kx = me&X_t,X,k,n,'k'
                # have their values via unique id
                me&X_s,kx,v,n,'ref'
            }
            # all our _t x.z/$r anded might lead us to similar sets
            # so will _s, earlier use might get to know about later
        }
        return X
    }
    fi.Xo.brack = &acgtXscq{
    }
    
  // &X_t|s|refer lowlevels
      =write or read (autovivificatorialy)
        X.$someindex ||= x += $r
       leading to x, another|inside X via $someindex
       x remembering what indexes it is in?
        joins|varies by x.z/r,
         the members being added to x locatable space
      =cut 
        
        # the X/$t += r
        # t must be string, r could be anything
        # in &RbitXarrive it is R, &brackX it is a row
        fi.X_t = &acgtXtrk{
            k ||= 't'
            X[k] ||= {}
            
            $x = X[k][t] ||= {};
            x.z ||= [];
            r && x.z.push(r)
            return x
        }
        # the X/uniq($s) += r
        fi.X_s = &acgtXsr,kf,kfs{
            kf ||= 's'
            kfs ||= kf+'s'
            # by id of the value
            $fs = X[kfs] ||= [];
            $vi = fs.indexOf(s);
            vi < 0 and vi = fs.push(s)-1
            $f = X[kf] ||= {};
            $x = f[vi] ||= {};
            x.z ||= [];
            r && x.z.push(r);
            return x
        }
        # the X/$s += r, $s repeatable
        #  no x will have more than one r
        fi.X_z = &acgtXsr,kf,kfs{
            kf ||= 'lizt'
            kfs ||= kf+'s'
            # by id of the value
            $fs = X[kfs] ||= []
            $vi = fs.push(s)-1
            $f = X[kf] ||= {};
            $x = f[vi] ||= {};
            # each x knows the others
            # looser matches for others may be done above
            $is = fs.indexOf(s)
            if (is < vi) {
                $ox = f[is]
                # usu must join X.** with point-nested pointers
                x.multix =
                ox.multix ||= [ox]
                x.multix.push(x)
            }
            x.z ||= [];
            r && x.z.push(r);
            return x
        }
        
  // tues

# < see Bscape
fi&live,1

# use this to serve &t

n t  s:vefge

