# fangs
me.Yingmind ||= {};

   // n 1
        me.Yingmind.n = &acgt{ return [
        # s = C
        # < many C in one n, implied layer of doming
        ['ground',0.01,&acgtRYs,SC{
            sy&R = R;
            Ys&leamity = 3;
            if (sc&W) {
                $to = Ys&to;
                !to and throw "!to"
                sc&J ||= me&fiu,to,s.t;
            }
            if (sc&J) {
                Y.1 and Y.2 = Y.1
                $J = Y.1 = sc&J;
                # < want Jhost t&w:J.t
            }
            if (sc&e) {
                $e = sc&e;
                # < see if any dome:e contain e Asip,
                #   or any along e cby, where it has been
                
            }
        },'ift,D'],
        # ghost suction
        ['realise',0.2,&acgtRYs,SC{
            if (sc&J) {
                # < Jy&Y
                me&Yingbal,'J:'+s.t,s
            }
        },'ift,D'],
   
   // n 5
        # atom -> atoms
        ['tick',0.5,&acgtRYs,SC{
            ss&icountre ||= 0;
            ss&icountre ++;
            $C = s;
            s = Cc&s;
            T.nN = [];
            # A=Y must serve G&t for A.I, have 4s&globals
            Y.6 = Y.4 = A.4;
            Y.7 = A.5;
            $D = Ys&Doming = me&Yingdome,R,Y,C;
            $Aye = A;
            A = Y;
            1s&N = [];
            if (c&J) {
                $pin = c&W;
                !pin and throw "huh"
                me&way,R,pin,{J:A.1,s}
            }
            A = Aye;
            Dy&ending()
        },'ift,D'],
        ['tock',0.7,&acgtRYs,SC{
            $D = Ys&Doming;
            $t = Ys&osc = me&Yingosc,R,s,D;
            # if this has a diff it can takeover a branch
            A = Y;
            if (ts&top) {
                $op = 1s&top = ts&top;
                if ('osc' == 'out replaces Cz in...') {
                    sy&tw = {};
                    ss&z = [];
                    me&ioty,op .map(z => me&fiu,s,z )
                }
                1s&hold and return
                sy&A = Y;
            }
            else {
                # unfinished
                1s&N.push(Y)
            }
        },'ift,D'],
    ]};
   
   // &Yingdome
    # for an A+C having S
    # ie the whole attention span
    me.Yingdome = &acgtRYs{
        $D = me&Yong,R,s,'Doming',{},1;
        me&Yingbal,'%Doming',D
        
        $current;
        # for an S+ay
        Dy&dome = &tc{
            isst(c) and c = G&peel,c
            c ||= {};
            c.t = t;
            return current = me&Yong,R,D,'Dome',c,1
        }
        # or on either end of them,
        # before the first S:
        Dy&dome('beginning','light');
        # after the last: %light vanishes if empty
        Dy&ending = &{
            Dy&domed(Dy&dome('ending','light'))
            me&Yong,R,D,{},2;
        }
        
        Yc&Srupto = &acgtst,talk,params{
            #~Srupt: s, ':', t, '%', talk
            
            # whatever is over now:
            Dy&domed();
            # various minds:
            A&Sonly && num(s) && s != A&Sonly and return 0
            A&ioing and return A&ioing.next()
            # vaguely named:
            t ||= s;
            # to happen once:
            A&doings ||= {};
            $l = A&doings[t] ||= {};
            if (l.done) {
                l.done < 2 and Dy&domed()
                l.done = 2
                return
            }
            l.done = 1;
            Dy&dome(t);
            #~sttalk: ki([s,t,talk,params]);
            return 1;
        };
        
        # grounds adopted from recent: n ...
        Dy&domed = &{
            !current and return
            $N = me&ydome;
            me&Yong,R,current,{N},2;
            current = null
        };
        return D
    };
    # Section deciver
    me.Yingmind.Doming = &acgt{ return [
        # C
        ['ground',0.01,&acgtRYs,SC{
            return Cye([s.t,3])
        },'ift,D'],
    ]};
    # piece of things
    me.Yingmind.Dome = &acgt{ return [
        # C
        ['ground',0.01,&acgtRYs,SC{
            $t = Ys&t;
            !t and throw "!t"
            $z = me&fiu,s,t
            return z
        },'ift,D'],
        ['ground',0.13,&acgtRYs,SC{
            each in Ys&N {
                ac(s,'z',n)
            }
            Ys&light && !ss&z.length and me&fiu,sy&up,s,9
        },'ift,D'],
    ]};
   
   // &Yingosc
    me.Yingosc = &acgtRsD{
        $s = me&Yong,R,s,'osc',{D:D}
        me&Yingbal,'%osc',s
        me&Yong,R,s,{},9
        return s
    }
    # < C from dome or so
    me.OsC = &acgtsDc{
        c ||= {};
        # < indo should use c, so c.O after is first
        $first;
        me&indo,D,c (&nd{
            $O = Cye(n);
            Oy&n = n;
            d.O = O;
            first ||= O;
            d.only and d.nofurther = 1; return
            # < flatten later, when swims back
            #   to keep both zeal%of:i and zeal%of:J
            #   so such a thing can be considered by the encoder
            $p = d.up && d.up.O || s;
            $dup = me&fiu,p,n.t,8;
            # < merge, io
            # < brack this so we old,neu
            dup && p == s and ac(s,'dups',dup)
            me&fiu,p,O;
        }) [0];
        return first
    }
    me.Yingmind.osc = &acgt{ return [
        # C
        ['osc',0.01,&acgtRYs,SC{
            return Cye([s.t,3])
        },'ift,D'],
        
        ['i Domings',0.5,&acgtRYs,SC{
            $Doming = Ys&D;
            each i,Dome Domings&z {
                each in Domes&z {
                    me&OsC,s,n
                }
            }
            # A:n magnet, was T.op, 1s&top etc
            $p = sy&up;
            $Yp = py&Y;
            Ypc&t != 'n' and throw "!n"
            
            Ys&top = me&OsC,s,p,{only:1};
            Yc&M = [Ys&top,...ss&z];
        },'ift,D'],
      // 6 swims
        ['o swims',0.6,&acgtRYs,SC{
            #~>4 sea: Y.t, s.t
            $C = s;
            $s = Ys&returns;
            c&s and s&strinoge = c&s.split("\n").length
            
            # %of travel to W:of for encoding!
            $swims = {of:'i'}
            each kt swims {
                # < ha,Y,eto:W,t:s&of,W:of
                #   W routing to Jproto,
                k == sc&W and continue
                C.sc[k] == 1 and C.sc[k] = t
                C.sc[k] && !C.c[k] and ah(Y,['swims'],k,C.sc[k],C)
                # many per J
                $J = s&J;
                if (J) {
                    $z = Js&top || Js&z || [];
                    me&ioty,z .map(&n{
                        nc&W == k and ah(Y,['swims',k,C.sc[k],n])
                    })
                }
            }
        },'ift,D'],
        
        ['i swims',0.62,&acgtRYs,SC{
            !Ys&swims and return
            
            # < making swum (via J) not travel for enlightenment
            each ktN Ys&swims {
                t == 1 and t = 'i'
                # Y%of=Y:voy, whole bunch of elvising
                $E = Y.sc[k] ||= me&Yingvoy,R,s,'swim',k
                me&Yong,R,E,'swim',{t,N},1;
                # to each thing
            }}
            
            # < tug
            each in Ys&swim {
                me&Yong,R,n,{},7;
                each iz ns&swum {
                    me&OsC,s,z
                }
            }
        },'ift,D,self'],
        
      // 7 out
        # osc/* -> top/*
        ['selfs',0.7,&acgtRYs,SC{
            # < the main thing, osc may other
            $t = Ys&top;
            me&ioty,s .map(n => me&OsC,t,n )
        },'ift,D,self'],
        ['selfs',0.77,&acgtRYs,SC{
            $t = Ys&top;
            $d = {};
            d.compLines = &D{
                delete Dc&J
            }
            # W.1
            ah(s,'store','',me&Lineso,t,d )
            
            # < W.5, dep for a single W:of inc. w:JaBabz.
            #  < backporting JaBabz,Wud for StyleAgent?
            
            # W.js
            me&ioty,t .filter(n => nc&W == 'of') .length
                && ah(s,'store','js',me&jsso,t,d )
            
        },'ift,D,self'],
        ['selfs',0.9,&acgtRYs,SC{
            # where s is this view of it and more (rolling domes)
            ss&top = Ys&top
        },'ift,D,self'],
        
    ]};
   
   // &Yingvoy - osc elvis leaving
    # < make a variant of Yingdome, for loading eg swim
    me.Yingvoy = &acgtRstk{
        $s = me&Yong,R,s,'voy',{k},1;
        me&Yingbal,'Y:voy:'+t+':'+k,s
        return s
    }
    # < vague sharable slep, Copy Lines, lv
    # < C.t == null should throw
    me.Yingmind.voy = &acgt{ return [
        # elvis stilling out
        ['elvoy',0.01,&acgtRYs,SC{
            !Ys&k and throw "nok"
            $U = sy&Y;
            !U and throw "nestY"
            $z = Cye([Ys&k,3]);
            ac(U,'swim',z)
            return z
        },'ift,D'],
        ['elvoy',0.13,&acgtRYs,SC{
            # picture each t:Wof
            Yc&M = ss&z;
        },'ift,D'],
        ['elvoy',0.2,&acgtRYs,SC{
            sc&W = Ys&k;
            sy&cv = 0.001;
        },'ift,D'],
        ['elvoy',0.21,&acgtRYs,SC{
            me&Yong,R,s,{},7;
            # < Y.1 already, enclosing J namespace
            me.cby(s,&s{
                sy&Y && sy&Y.1 and return Y.1 = sy&Y.1
            })
            sc&J = me&fiu,Y.1,s.t;
        },'ift,D'],
        ['elvoy',0.23,&acgtRYs,SC{
            # they all %%string
            sy&toLines and throw "hadLines"
            sy&toLines = me&indo,s (&s,d{ return sy&toLines });
            # this now a c&W to elvis, slept by %string
            
            $n = me&Zeve,R,s
            $e = ns&e;
            !isC(e) and throw "reb"
            ss&e = e;
            !n and T.hwack = "Y:voy:"+s.t; return
            # incorporate that
            !es&z and throw "Weird"
            # e:of is about several n:W:ofs
            $N = ss&swum = [];
            # < should use OsC that spots c&J?
            #   want to log J use
            each in es&z {
                # elvoys:n still origin, top made clean
                $J = nc&J;
                $top = Js&top;
                topy&cv != ny&cv and throw "*moted by peer"
                N.push(top)
            }
        },'ift,D,self'],
    ] };
    me.Yingmind.swim = &acgt{ return [
        ['elvoys',0.01,&acgtRYs,SC{
            # < exp lang
            $t = Ys&t;
            !t and throw "!t"
            $z = me&fiu,s,t
            $N = Ys&N;
            !N and throw "!N"
            Yc&M = N;
            return z
        },'ift,D'],
        ['elvoys',0.2,&acgtRYs,SC{
            $p = Ys&returns;
            !pc&W and throw "What"
            # may have Lines already, see 'variant of Yingdome'
            (sc&W ? ss&z : [s]).map(&n{
                $dup = me&fiu,s,n.t,8
                #dup and ac(s,'dups',dup)
                dup && dupy&cv != ny&cv and throw "cv"
                
                # < clone deeply
                $K = Cye(n);
                Ky&O = n;
                Ky&Y = Y;
                # may mix from $W/*
                s != n and Ky&W = s
                
                me&fiu,p,K
            })
        },'ift,D'],
        ['elvoys',0.21,&acgtRYs,SC{
            tvsortz(ss&z);
            Yc&M = [s,...ss&z];
        },'ift,D,self'],
        ['K',0.22,&acgtRYs,SC{
            # encoding advice
            $d = {jsony:1}
            me&Lineso,s,d;
        },'ift,D,self'],
    ] };
   // Storable
    # make W.js usable for:
    #  boot: w:Twoism loadI, page includes Hunt.js (moved out of W/)
    #  u: @Search Talks.js
    #   < without the lookup step (you know %dige)
    me.jsso = &acgttd{
        $functions = me&indo,t,ex({},d) (&s,d{
            $part;
            try {
                part = 'scan';
                !isC(s) and throw "Not C"
                sc&N and throw "mightbe R"
                part = 'clone';
                $D = Cye(s);
                part = 'Compress';
                G&Compress,D;
                Y && Ys&compLines and Ys&compLines(D,d)
                d.compLines and d.compLines(D,d)
                part = 'tojsfunc';
                
                d.tuple = [enj(D.t),enj(Dy&cv),$function,enj(D.sc)]
            }
            catch (er) {
                ~enLinesR: ki(d.path,2)+"   !"+part+"! "+er
                #me&Rec,R,'err';
                d.toLines = "[error} "+ki(s);
                #Rs&err = "enLinesR: "+part+": "+er;
                #n err  $s:Rs&err
                d.nofurther = 1
                throw er, 'further'
            }
            sy&toLines = d.toLines;
            return d.toLines
        });
        
        my @W = G&op,'cW:javascript';
        # first function, on the first line, should be a toc
        # one item per line of it, including line number ranges
        my $zI = Ds&z = []; # Is
        my $N = []; # flat list, to include toc
        for my $I (@W) {
            (my $Icv = I.y.cv) =~ s/^0\.//;
            for my $i (@{Is&z}) {
                (my $icv = i.y.cv) =~ s/^0\.//;
                my $name = join'_',C.t,c&ver,I.t,$Icv,i.t,$icv;
                $name =~ s/\W+/_/g;
                is&name = $name;
                ic&s =~ s/^function/function $name/
                    || die "Doesn't ^function: ".ki $s;
                push @$N, $i;
            }
        }

        for my $i (@$N) {
            ic&s =~ /\n$/ || die "No trailing \\n: ".ki $i;
            my $lines = split "\n", ic&s;
            is&lines = $lines; # also ^function...{\n and \n}\n$
        }

        my @toc; # [ind t y c sc]+
        for my $I (@W) {
            (my $Icv = I.y.cv) =~ s/^0\.//;
            push @toc, ['',I.t,I.y.cv,I.c,I.sc];
            for my $i (@{Is&z}) {
                push @toc, ['  ',i.t,i.y.cv,i.c,i.sc];
            }
            delete Is&z;
        }

        my $toc_lines = @toc + 3; # also ^function...{\n and \n}\n$
        my $code_lines = 0;
        for my $i (@$N) {
            is&line = $toc_lines + $code_lines;
            $code_lines += is&lines;
        }

        my @codes = map { delete _c&s } @$N;

        my $name = join'_', C.t, c&ver ;
        $name =~ s/\W+/_/g;

        my $cur = join'_', C.t, 'current' ;
        $cur =~ s/\W+/_/g;

        my $s = join "",
            "function $cur () { return $name() }\n",
            "function $name () { return [\n",
            # data and code has indent
            (map { $_->[0].sjson($_).",\n" } @toc),
            "]}\n",
            @codes;

        c&s = $s;

        # toc function C them all together
    }
    me.Lineso = &acgtsd{
        return me&indo,s,ex({},d) (&s,d{
            $Y = sy&Y;
            $part;
            try {
                part = 'scan';
                !isC(s) and throw "Not C"
                sc&N and throw "mightbe R"
                part = 'clone';
                $D = Cye(s);
                part = 'Compress';
                G&Compress,D;
                Y && Ys&compLines and Ys&compLines(D,d)
                d.compLines and d.compLines(D,d)
                part = 'toLines';
                d.toLines = d.jsony ? enj(D) : G&toLines,D;
                Ds&H && !d.toLines.match(/(H):(\w+)\b/) and throw "%H not so gc will see it"
            }
            catch (er) {
                ~enLinesR: ki(d.path,2)+"   !"+part+"! "+er
                #me&Rec,R,'err';
                d.toLines = "[error} "+ki(s);
                #Rs&err = "enLinesR: "+part+": "+er;
                #n err  $s:Rs&err
                d.nofurther = 1
                throw er, 'further'
            }
            sy&toLines = d.toLines;
            return d.toLines
        })
    }
   
   // &Zeve Jproto
    # supposing e=s and sc&W
    me.Zeve = &acgtRsaq{
        $p = me&Rsc,R,'^^Proto';
        # < o $s^^y&Ys&plan
        # be from Jrunto's plan to n, reoccurs after async
        $sup = me.cby(s,&s{
            $Y = sy&Y;
            return Y && Ys&plan
        });
        $Cn = sup[0];
        $Yn = Cn && Cny&Y;
        $plan = Yn && Yns&plan;
        !plan and throw "n!plan", sup
        
        # the question (gets .e=s in &nodee)
        q ||= {};
        q.dome ||= plan
        # recycles e
        sy&toLines and q.dige = dig(sy&toLines)
        
        sy&timese ||= 0;
        sy&timese++;
        
        return me&nodee,R,p,s,{},q
    }
    