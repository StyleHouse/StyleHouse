# Flanges!

me.SCones = &acgt{ return [
    # vast oldness, Peace
    ... me&ruv ,
    # W etc relatives
    ... me&Sch_Comm ,
    ... me&Sch_Pavings ,
    ... me&Sch_Constel ,
    ... me&Sch_ema ,
]};
me.Yingmind ||= [];

=pod reintroduce MindInto
 GONE are %ting, %tracting, %Gracto, %folder
 
 Know/*%Pave gently, a %Zave that doesnt expect here
 
  me&bal fills R%Ying/$step%ball%etc from the schema
    or %ball%eph for floating steps, not in Rc&s
 %Ying
  < s&J see 'resolve through JRom'
    Ying gets to Rom:$p many times,
      since %elvoids back into $p may happen now
      < depending on the attention span of A:planet
        which should only spend 1/3 of its time
        in ~200ms bursts, to keep interactive
      < not looping
    not different enough to Ying sleeping the non-elvised
    would be nice for slomo elvising,
     getting the controls on an A
 
 %KnowThee (the schema)
  is eventually a pin, full of S-teps
   which %Peace manages dispatch to
  s/$u/:u/, for highlighting
   
  S not
  # never got to, yet S may be defined:
  S o Know/**$u o Ghost/$n/$u o Run/**$n
  #  would create a %twin on a Ghost,
  #  where the u converts to of/t when $u comes along,
  #   all the way from $W:
  S i To/$W o Run/**$n
  #  $W are down/up from Run, push/pull:
  push may:input $W=C? maybe extra $u as well...
  pull:
    $u towards $n...Ghost...Know
    $W itself,
     may CB_load Lines dige, pass test
     it might have the rolling Wy&A:n situation
      of a $W in A.4
    $W.*,
     lv, code, etc.
   all that might be drawn out,
    dige checked for lazy downloading tests
  
  S 3
  S o Run/**$n%%acty:3
  # means any $n %%may,acty:3
  #  o ...%%acty known to auto %%may,acty
  
  # when n%%acty,may (engages):
  #  engage any %%may,acty<=3 on $n
  #   as in switching everything on
  #  engage $n's relations in Know, Ghost, To
  #   to acty:2?
  #   will upgrade if eg Know/** source needs reading
  #  the link to To, etc, producing %%may:input
  
  # all before iterating the $n here,
  #  before it transmits to To
  
  # maybe the step numbers auto %%acty clause
  S 6
  S i To/$W o Run/**$n
  me&Yong,$W,'To',...
  # clarifies how to input to To,
  #  makes it require %%acty=6,
  #  starts the simulation there,
  #  which should get init with some attention,
  #  and travelly situata
  # and we're near the terminal again...
  S 67
  while waiting for To, at regular intervals
  S 7
  accept, pull
  hoisting $u back to ...
  producing channels of matter from these points
  eg $u, $ch, 
  
  < %%acty row not ending in may$
    should engage the may,
    as long as its not ^may
  
  may,be,{},acty:3
    brack may click on,
     introducing %%acty:3,may to ja
  may,acty,acty:3,{}
   the may:acty method an open-pressure interpreter
    reading %%acty-ish from around,
    auto engaging up to 3 if any cause (inc click on)
  
  < io: optimise for Knowy&tw[u.t], %%tw
  < io: pipelines, listen for new Run/**
  
%Paving ############
  inheriting %Pave-ish sc, like %Pave
  < deduce impliables at &adhere or &CB_load
  receiving %Live-ish sc from %Pave
  them all,
  < gathers itself, finds j%trouble, makes %openey
    trouble got means ->Ghost->Travel->To and back
  < &settle
 %Pave net connect a thing
  inheriting %Pave-ish sc
    Know%directory=else/ward:
     Know/**$t are else/ward/$t
    < That%directory=ForThe/That implied by That%J
     < $t%director implies $t/**%directory += $t
  < producing %Live-ish sc (to %Paving)
 
  %Search for %species (is in the $t)
   < local %Search host,
  < _ting c&ready -> Qup the first time !?
    < comeback to %waits etc
  
 %Ying
   < logs/maps/rules elvising going in
    < so $r can be paused
  adhere generally
  < %Pavings want attending into Travel
    defaulting to mixing the W I as per %J
  < elvis itself the steps wanting to wake up
    start that paused, lets travel loose
  < code folder, fix Zif diff squish
 %twmt
   recycle tw ha
 %twin
  might be the pairing of musictime and imagespace,
   to get alignment and interactivity in the show
  < nodeo %%may and %%waits
  
  < To
   %Search
    who implements the index where of=* mix into definition
  < make .5 ghost from @Search, into .5/of/t%dige
    < dupish so two different %directory things etc,
    then %twin uses those .5/.../* sc being linked
      being linked because:
        .5 becomes known (el=1)
        have Run something (el=2)
     or the s.sc already in the link
     to figure which Know/** we want
      %twmt has compiled {tw,s,candidates for Qc}
      %Pavings ein helps to:
       creating a type folder if dup with conflicting Qc
  
  < get KnowThee doing something
   brackdowns and noDisplay ing:
   
  < %Crun mapping Peace:5 etcs,
    anything interesting on them (SCA, waits)
     similar gear might org travels
      expecting+introgressing
    fishfood, pause, savepoints?
    being an elvis queue <-> machines of load

=cut
me.Sch_Comm = &acgt{ return [
  // the room
    ['Abodo',0.7,&acgtRs{
        delete s&bgi;
    },'ift,D'],
    ['Peace',0.7,&acgtRs{
        #s&hue ||= 30;
    },'ift,D'],
    ['noisemaking',0.6,&acgtRs{
         me&ha,R,{waitel:2,p:py&l};
         me&ha,R,{dwitty:'vael',flat:'others',vap:2}
         me&ha,R,{dwitty:'val',until:'seemingly'}
         # sa (waighre) asks
         $lo = me&sa,R,'vap','dwitty,flat,until';
         me&nu,"vap3",lo
         
         # loop:
         $lo = me&sa,R,'cow',1 [0] || 2;
         lo++
         me&ha,R,{cow:lo};
         
         me&ha,R,{dwitty:'vael',until:'seemingly',vap:3}
    },'ift,D'],
  
  // SummerCat
   // SummerCat
    # < a process similar to Travel itself,
    #   acty:3 saving a W
    ['SummerCat',0.297,&acgtRs{
        me&reaw,R,'SummerCat';
        $S = me&inode,R;
        !S and return me&waits,'node'
        $testmode = 0 ? '' : ',testmode'
        me&bal,'Inc','Aearch,eph'
        if (0) {
            me&bal,'Yusears','Yuse,eph,testmode'
            me&bal,'Jpara','Jpara,eph,testmode'
        }
        else {
            #me&bal,'Jhost','Jhost,eph'
            me&bal,'Jproto','Jproto,eph'
            me&bal,'Jrunto','Jrunto,eph'
            #me&bal,'Jfin','Jfin,eph'
        }
    },'ift,D'],
    ['sleeping+SummerCat',0.2971,&acgtRs{
        me&rollbs,R,'Inn'
    },'ift,D'],
   
   // @Aearch - capture I
    ['sleeping+Aearch','4',&acgtRs{
        # they still know the R that set them
        me&rollbs,R,'do_permanence,_ting';
    },'ift,D'],
    ['AearchGhost','298',&acgtRs{
        me&reaw,R,'AearchGhost,eph';
        $l = me.cby(R,'^^Aearch').length;
        if (l == 2 && Rs&icount < 2 ||
            l == 4 && R.t == 'JaBabz') {
            # < Babz: //= # !null-or
            Rs&boost == null and Rs&boost = -1
        }
        ac(R,'inheritsc','AearchGhost')
        (Rs&boost||0) < 0 and Rs&thiding = me&ioty,s .map(z=>z.t)
    },'ift,D'],
    ['Aearch','298',&acgtRs{
        me&reaw,R,'Aearch,_ting';
        $S = me&inode,R;
        !S and return me&waits,'node'
        $For = Ry&up;
        Fors&Inn = Rs&Inn = R;
        #me&reaw,For,'Inn';
        $Search = 4s&Pearch;
        $upting = Rs&upting = Searchs&_ting;
        !upting and throw "^^Inn!_ting", Search

        
        me&introqua,[R,'Ghost'],{boost:-1},'@1';
        $Ghost = Rs&Ghost = me&bal,'Ghost','AearchGhost,childy,eph' .c.s;
        
        # what are spaces for:
        # things we look up
        me&fiu,Ghost,'In';
        # things we make up
        me&fiu,Ghost,'Out';
        
        # Ghost/$what:In|Out/ $of(/$args)? /$P
        $whatP = &what,P{
            what = me&fiu,Ghost,what;
            $of = me&fiu,what,Pc&of;
            Pc&args and of = me&fiu,of,Pc&args
            return of
        };
        
        $Pio = Rs&Pio = {};
        Pio.what = &tP{
            $of = whatP(t,P);
            return me&fiu,of,P.t,8
        };
        Pio.not = &tP{
            $of = whatP(t,P);
            me&fiu,of,P.t,9
        };
        Pio.is = &tP{
            $of = whatP(t,P);
            me&fiu,of,P.t,9
            me&fiu,of,P
        };
        Rs&_ting = &Qr{
            return me&Aearch_ting,R,Q,r
        }
        
    },'ift,D'],
    &{
        #c _ting - a many arg'd entrypoint
        #  ting becomes the reduce for io's map
        # 
        me.Aearch_ting = &acgtRQr{
            !isC(Q) and throw "ting !C"
            
            if (0 && Qc&of != 'JaBabz' && Qs&string) {
                $q = Rs&Pio.what('Out',Q);
                q ||= Cye(Q);
                Rs&Pio.is('Out',q);
                q.sc = {};
                qs&string = delete Qs&string;
                qs&dige = dig(qs&string)
                return
            }
            #~>5 Aearch: Q.t, Qc&of
            $s = Rs&upting(Q,r);
            $P = Qs&P;
            !P and ~>5 upting!P: Q.t
            !P and return
            Rs&Pio.is('In',P);
            $q = Rs&Pio.what('Out',Q);
            q and throw "reading a write", Q, q
            !s and return
            return s
        }
    },
    
   // &%Yingbal - breakdowns
    &{
    # things to appear as ball
    # < uniquely bal anything Yong'd 01 return cv==3
    me.Yingbal = &acgttsc{
        # s must have a Y
        $Y = sy&Y;
        !Y and throw "notinit"
        # so we can climb up to an R
        $r;
        me.cby(s,&s{
            $bal = sy&bal;
            bal && bals&Yingbal != t and return r = bal
            sy&R and return r = sy&R
        });
        !r and throw "Rup"
        
        $R = me&yfuture,r;
        $C = Rs&C;
        Cy&R == R
        
        isst(c) and c = G&peel,c
        c ||= {};
        c = ex({eph:1,Yingbal:t},c)
        
        #t[0] == 'J' and debugger
        #~>4 The: R.t, t, s.t
        $r = me&bal,t,s,c;
        sy&bal = r;
        me&Ring,R,{und:r,ov:0.299};
        $C = rs&C;
        s&hue = 60;
        t[0] == '%' && t[1] == t[1].toUpperCase() and s&bgh = '010';
        return r
    }
    },
    # recycle the %eph, were &bal by something probably not awake
    ['Yingbal+eph+ball+reawakens',0.19,&acgtRs{
        $c = {where:&n{ return ns&ball && ns&eph }}
        me&recycleRbitXz,R,c;
    },'ift,D'],
    ['Yingbal',0.302,&acgtRs{
        me&reaw,R,'Yingbal,adhere,eph,nky,thiding';
        ah(R,'adhere','Yingbal',1);
        $Y = sy&Y;
        !Y and return me&tsc,"!Y",'','p'
        me&tsc,"Yt",Y.t,'p' .sc.fs = 7
        
        # < squish ball display: to 1-3 lines unless actying
        # for each bal-entered thing
        $abal = R.t != s.t;
        (Rs&boost || 0) > 0 and me&nu,"yY",sy&Y
        else
        abal and Rs&nky = 1
        # and then,
        $p = Ry&up;
        ps&nky && !abal and Rs&noDisplay = 1; ac(p,'thiding',R.t)
        
        # is taken
        sy&R and return
        #$S = me&inode,R;
    },'ift,D'],
    ['ball+thiding',0.33,&acgtRs{
        $n = me&tsc,"more","<";
        me&mtsc,n,'count',Rs&thiding.length,'y' .sc.ma = 0.4
        me&mtsc,n,'titles',ki(Rs&thiding,2),'g' .sc.fs = 8;
        ns&dis = 1;
        ny&cv = 0.754;
        
    },'ift,D'],
   
   // Jhost - prepare I
    # W prepares to happen
    ['Jhost',0.299,&acgtRs{
        $S = me&inode,R;
        $client = me.cbu(R,'SummerCat');
        !client and throw "!client"
        me&reaw,R,'Jhost,eph';
        $Yuaving = 'Paving:W,fully,openey,Yuaving';
        me&bal,client.t,Yuaving
        # < Know just w%dige,
        #   Ghost has arrays of args to precompile?
        #    or do we want to block read whenever we need something?
        #    since it is arranged to be near
        # w%dige is always as /ghost/ is,
        #  yet wc&s is compiled + args
        $balwjs = &ta{
            isar(t) and $ot = t.join('-'); t = t[0]
            $j = me&bal,ot||t,Yuaving;
            js&title = t;
            js&Paving = 'wjs';
            js&args = a;
            return j
        }
        balwjs('SCones','ar,me')
        balwjs([client.t,'w'],'J,s')
        balwjs([client.t,'w2'],'J,s,wodges')
        if (0) {
            # < Search of:w el:9 seems loopy
            #   we can assume all wjs no way now?
            $j = balwjs('w3','J,t,wodges');
            js&Paving = 'w';
            js&brackstable_aware = 1;
        }
    },'ift,D'],
    # < W.5|Ghost prepares the ghost
    ['Yuaving',0.46,&acgtRs{
        $S = me&inode,R;
        me&reaw,R,'Yuaving';
        Rs&decoy and return
        $Q;
        each tr Rs&Zaving {
            Q = rs&Q;
        }
        !Q and return me&waits,'!Q'
        $w = Qc&s;
        Rs&Question = Q;
        !w and return
        Rs&Live = w;
    },'ift,D'],
   
   // Jproto - plan -> now
    # W as planned by Matu
    ['Jproto',0.299,&acgtRs{
     // 1
        me&reaw,R,'Jproto,eph';
        $S = me&inode,R;
        $x = me&Jx,R;
        
        # %Jhost prepares &t
        me&settle_prev,R and return
        # of things going into it
        Rs&settled.map(&j{
            me&ioty,j,'Paving' .map(&r{
                $Live = rs&Live;
                $Q = rs&Question;
                $q = {Q,dome:'things'};
                Live and q.Live = Live; q.dige = Qs&dige
                me&ha,R,q
            })
        });
        # < x. contextualised modulata/expressiona: x.ro, etc
        # click act
        $ro = &kc{
            c ||= {once:1};
            c.k = k;
            return me&rolltog,R,c
        }
        # t = $dome(,pe:el,e:d), c = {}|C
        # < peel here to keep word order of this call
        $ha = &tc{ me&ha,R,c,{},'dome:'+t }
        
        
        
        # dome tires, need push
        #Rs&icount > 4 && !ro('~') and return
        # J.4 forgets, redoing without
        ro('4') and me&rolled,R,'four'
        # < ability to reset history, inc sy&things
        if (ro('!')) {
            [R,xc&Jrunto] .map(&r{
                delete rs&wou_accepted;
                rs&wou.sc = {}
            })
            return
        }
        
     // 2 plans
        $four = me&rollbsc,R,'four';
        $the = xs&client;
        
        # < previous thinking as %term'd into runs
        me&zaa,R,'dome:plans,plan,to,C' .map(&n{
            # %%plan,e,C come from the %%eto again
            ns&e and return
            # n may be forgot due to errors
            ha('plans',n)
        }) .length ||
            ha('plans,plan:v1',{to:four, C:Cye([the.t])})
        
        # %%plan,e,C come from the %%eto
        $washad = {};
        me&zaa,R,{eto:s,dome:1,e:1} .map(&n{
            $e = ns&e;
            each iD es&z {
                !Dc&W and throw "e/!W"
                
                $name = e.t+'/'+D.t;
                washad[name] ||= 0;
                # < fix sometimes dupe %%eto (in Jrunto)
                if (washad[name]++) {
                    me&tsc,"Doubling:"+e.t+'/'+D.t .sc.dis = 1;
                    continue
                }
                
                ha('plans',{e,plan:ns&dome+'-e',to:four,C:D})
            }
        })
        
        # < S 1 @plans
        me&dome_S,R,'plans','1';
        
     // 3 todo
        # < joined to haps
        # < pull next bit of time
        # < Babz &ja:'plan to' &n{
        #   key order, implied map
        me&jaa,R,'dome:plans,plan,to,C' .map(&n{
            me&Jproto_done,ns&C and return
            ha('todo',{plan:ns&plan})
        });
        # deduce done e from !@todo
        me&jaa,R,'dome:plans,e' .map(&n{
            me&ja,R,{dome:'todo',plan:ns&plan} and return
            $e = ns&e;
            !es&done and ~>4 edone: ns&plan, e.t
            es&done = 1;
        });
        
        me&dome_S,R,'todo','2';
        # < &stay, when ^ domes immute v
        
        if (!ro('pause',{})) {
            # repoint @now
            # < io plan(?^@todo) to C
            #   little joins not in the main plumb
            #   and relating to brack
            $N = me&jaa,R,'dome:todo,plan';
            $not = [];
            each in N {
                each il N {
                    ls&plan == ns&plan and continue
                    if (ls&plan.startsWith(ns&plan)) {
                        not.push(n);
                        break
                    }
                }
            }
            N = N.filter(n => !not.includes(n))
            $D = N[0]
            $tw = {};
            D && me&jaa,R,{dome:'plans',plan:Ds&plan,to:1,C:1}
            .map(&t{ 
                $uniquely = ts&plan+'/'+ts&C.t;
                tw[uniquely] and throw "now_dup: "+uniquely
                tw[uniquely] = 1
                
                ha('now',t)
            })
        
            me&dome_S,R,'now','3';
        }
        
     // 4 picture
        # < tell brackope about dome - more tension
        #  < plan can be like dome
        # < program cursor: goto time, inc clear run into
        #   any differing/meta aggreg.
        $g = me&opeolo,R,'plans';
        $plans = [];
        uniq(me&jaa,R,'dome:plans','plan' ).map(&k{
            # tabular expression?
            $gr = gy&can('w');
            $se = gry&can('c');
            $lc = sey&can('i',k)
            $le = gry&can('c');
            me&jaa,R,{dome:'plans',plan:k} .map(&n{
                plans.push(n)
                lcs&ope and ha('now',n)
                
                $ro = ley&can('w');
                ros&hue = 38;
                if (me&ja,R,{dome:'now',plan:k} ) {
                    nc&active = 1
                    ros&bgh = '010'
                }
                
                # looks like plan/$t%output%trips
                # < table of trips through Jrunto
                
                $t = ns&C ? ns&C.t : '?'
                $rc = roy&can('i',t)
                if (!me&Jproto_done,ns&C ) {
                    nc&ongoing = 1
                }
                ny&khas = &tkn{
                    $tk = 'the'+t;
                    $st = roy&output ||= roy&can('m',t);
                    $is = sty&can('i',n.sc[k]);
                    return is
                }
            })
        })
     
     // 5 Travel when done
        $done = plans.filter(n => !(nc&active || nc&ongoing));
        if (plans.length && plans.length == done.length) {
            each in done {
                ns&e and continue
                # plans from Jproto
                # < sort by plan
                $D = ns&C;
                $Ste = me&Stenugra,D.t;
                me&zaa,xc&Jrunto,{dome:ns&plan,C:D,store:1} .map(&t{
                    me&san_storerow,t
                    
                    # plan/$t%output
                    # < link $is <-> $r
                    $is = ny&khas('o','store',t);
                    
                    if (xc&Jfin) {
                        $name = D.t+'.'+ts&store;
                        # without Travel, each thing ~%Zave
                        $r = me&input,xc&Jfin,name;
                        $z = rc&s;
                        zy&t = t;
                        # < never happens?
                        !rc&b and me&Yingwant,R,xs&Jfin,{name,becomes:"done"}
                    }
                    else {
                        Stey&n_storerow(t)
                    }
                })
                xc&Jfin and continue
                
                $Inc = xc&Inc;
                !Incs&Ghost and throw "!uR"
                Stey&u_Ghost(Incs&Ghost);

                $q = {};
                q.dome = ns&plan+'-fin'
                # e slepable by the rows of %%store + Inc..P%dige
                # + random bumps
                if (ro('+T')) {
                    sy&Tbump ||= 0
                    sy&Tbump++
                }
                q.dige = dig( Stey&total() + (sy&Tbump||'') )
                
                me&nodee,R,xc&Travel,Ste,{},q;
                #me&nu,"Sten",Sten
            }
        }
        
        me&Rsc,R,'^^Inn' .t != 'Inc' and throw "lost Inc"
    },'ift,D'],
   
   // &Ste*
    &{
    me.san_storerow = &acgtt{
        !ts&dige and throw "store!dige"
        !ts&string and throw "store!string"
        !ts&store and throw "store!store"
        !ts&C and throw "store!C"
    }
    # make Ste/n|u/$of/$t of things
    #  index of %Search%Ghost
    me.Stenugra = &acgtt{
        $Ste = Cye([t,7]);
        
        # n
        $Sten = me&fiu,Ste,'n'
        
        # %%store,dige,string from %Jrunto
        Stey&n_storerow = &t{
            me&san_storerow,t;
            $D = ts&C;
            $name = D.t+'.'+ts&store
            ac(Sten,'digebits',name+':'+ts&dige)
            $SteW = me&fiu,Sten,'W';
            $title = D.t;
            # $t augmented, see Pave 291 re Qc&species
            ts&store != 'W' and title += "/"+ts&store
            # convert %%store to 5ish
            $W = me&fiu,SteW,title;
            Ws&dige = ts&dige;
            Ws&string = ts&string;
            # < Inc...W.js should be there
            # < Inc...$W/$js, $W dige covers it?
        }
        
        # u
        $Steu = me&fiu,Ste,'u';
        
        # the $Ghost from Aearch
        #  Searchish, same index as Ste/*
        Stey&u_Ghost = &s{
            !isC(s) and throw "!s (%Search%Ghost)"
            me&indo,s (&sd{
                # Ghost/In:mode/of(/args)?/t
                $nope = d.nofurther =
                    d.d == 2 && s.t != 'In' ||
                    d.d == 3 && s.t == 'JaBabz' ||
                    d.d >= 4 && s.t == 'Peace';
                # < P/P, fragments, point range
                nope ||= d < 4 || me&ioty,s .length;
                nope and return
                # of..t
                # < put args under t, compres further?
                $N = me.cby(d,&d{ return d.d == 3 }).map(d => d.s)
                $eu = Steu;
                each in N {
                    eu = me&fiu,eu,n.t
                    i < N.length-1 and continue
                    !ns&dige and throw "u!%dige"
                    eus&dige = ns&dige;
                }
                # < when only args changey
                ac(Steu,'digebits',eu.t+':'+eus&dige)
                #me&zu,"eu:"+s.t,eu
                #me&tsc,"Ata:"+d.d+"_"+s.t .sc.dis = 1;
            });
        }
        # and you:
        Stey&total = &{
            return me&ioty,Ste,'digebits'
                .map(n => ns&digebits.join(',') ).join(' ')
        }
        return Ste
    }
    me.diagetos = &acgtRs{
        $etos = sy&etos;
        etos && me&ioty,etos .map(&z{
            $x = {};
            $is = &tn{
                !(n && nc&allvs) and return
                x[t] = nc&allvs[nc&allks.indexOf('dige')]
            }
            is('etos',z);
            is('current',zs&current);
            is('accepted',zs&accepted);
            me&nu,"etos:"+z.t,x

        })
    }
    },
   
   // &Jx etc - ->
    &{
    # expressions for
    me.Jx = &acgtRc{
        $C = Rs&C;
        $x = Cye(["x:"+R.t,22])
        
        # 2 degrees of local Js by name, c/sc R/s
        # the 4
        xc&Ying = me.cbu(R,'Ying')
        !xc&Ying and throw "!Ying"
        # the 3, aka 'client'
        xc&client = me.cbu(R,'SummerCat');
        !xc&client and throw "!client"
        each tr x.c {
            x.sc[t] = rc&s
        }
        [xc&Ying,xc&client] .map(&crux,{
            me&ioty,crux,'ball' .map(&n{
                x.c[n.t] = n;
                x.sc[n.t] = nc&s;
            });
        })
        
        # < brackimply: sets x.zaa etc to dome:plans or etc
        #   you: x.doming = 'plans' # etc per S
        return x
    }
    # only if n@7 && osc@9
    me.Jproto_done = &acgts{
        !isC(s) and throw "notC"
        return sy&A
    }
    # send attention via Ying &waits_8
    #  no trace left in r, not like &nodee
    #   although most cases of this could be,
    #   eg Jproto elvises %%now to Jrunto,
    #    which process them and return an answer
    me.Yingwant = &acgtrsc{
        $R = me.cbu(r,'Ying');
        c = ex({waits:r,wants:s},c||{})
        me&ha,R,c
    }
    me.Yingerr = &acgtRetc{  
        $n = G&Cye,[t||'error','',{er:e}];
        nc&s = (e.message || e)+'';
        ns&now = Gtime();
        ns&A = A;
        ns&B = Gc&B;
        ns&R = R;
        nc&s.match(/^async/) and ns&async = 1
        else
        # < fix this... not realising its not ready?
        nc&s.match(/^no way:/) and ns&async = 1
        # bunch of artifaces, < (t,$s)+
        e.tc and nc&M = e.tc
        return n
    }
    },
   
   # < Pring gateway, know u per C?
   #    probably pile deps onto !e C, unless we can dep W:of?
   # < as a point dispatcher,
   #  < futurised Y
   #   < brackstable
   // Jrunto - now -> plan
    # W as done by A:n (T loaded)
    ['Jrunto',0.298,&acgtRs{
        me&reaw,R,'Jrunto,eph';
        $S = me&inode,R;
    },'ift,D'],
    ['Jrunto',0.31,&acgtRs{
     // 1
        # %Jproto prepares run!
        me&settle_prev,R and return
        $x = me&Jx,R;
        # &Zeve %%eto,e sends to:
        $p = Rs&Proto = xc&Jproto;
        !ps&wou and me&tsc,"Jproto!wou"
        $tw = {};
        $plans = {};
        me&zaa,p,'dome:now' .map(&E{
            $D = Es&C;
            tw[D.t] and throw "Already "+D.t
            tw[D.t] = 1;
            $to = Es&to;
            $plan = Es&plan;
            plans[plan] = 1;
            $b = Dy&Y;
            $starts = Gtime();
            # outputs of each $plan, uniquely named
            #  so steps can reiterate,
            #   until run through without async
            # eg to swim e:W:of:i, &nodee with %%dome:$plan
            # or anything else we unpack here
            # eg %%attendo:1s&N/n@7 waiting for ^^
            $ha = &c{ return me&ha,R,{dome:plan,C:D},{},c }
            $sa = &c{ return me&sa,R,ex({dome:plan,C:D},c||{}) }
            $s;
            $er = null;
            try {
                s = me&Yong,R,D,'n',{to,plan},1;
                s = me&Yong,R,s,{},9;
            }
            catch (e) {
                er = me&Yingerr,R,e,plan;
            }

     // 2 observe
            $Y = sy&Y;
            $bal = sy&bal;
            $An = s;
            if (Y && bal) {
                $J = Y.1;
                J != Dc&J and throw "!J"
                # Jproto <- 
                # eg %%dome:$plan for the e:W:of:i (via &nodee)
                #  and a 1s&N/n@7, the client waiting for ^
                # < the externalising state should have many domes...
                #   J:Dealap (inc non-single-track mindworld)
                #   J:Dealap/swim%Doming
                #   J:Dealap/swim%Doming/voy%W
                #   kept/not when they are full deducted from above
                #me&ha,R,{dome:plan,delta:Gtime(starts)}
                #ha({delta:2})
                each in Js&N {
                    # give it the plan to make e dome
                    ha({attendo:n.t})
                }
                Js&N = [];
                
                # drop out  A, Matu (rethink A.4), come back in due course
                # < reusing the in-progress A: A:n merge
                # < and subsequent wakes of it, must usu. casual
                # < sleeping domes etc, causality
                $hw = delete T.hwack;
                hw and ha({Thwack:hw})
                
                # < robusticles
                $t = Js&top;
                $osc = t && ty&osc;
                $store = osc && oscs&store;
                each ks store {
                    # species = k || 1
                    $v = ha({store:k,dige:dig(s),string:s})
                    # < recycle c?
                    #vc&s = s;
                }
            }
            else {
                me&tsc,'!Ybal'
            }
            
     // 3 respond
            # < Y:n<9 should keep trying
            if (me&Jproto_done,D ) {
                er and me&tsc,'late-errors','','b'
                ha('done');
                !sa('done') and ~>6 Done jrun: plan
                !sa('done') and me&Yingwant,R,pc&s,{becomes:"done"}
            }
            # ofing code reliably throws async when not finished
            if (er) {
                $msg = erc&s;
                if (ers&async) {
                    ha({async:msg})
                    # keep trying without Matu while mess changey
                    # < relating to @Aearch waiting
                    # < Jrunto 8, after Doming_7:
                    # R%brackstable isn't computed yet,
                    #  use b, check msg to be surer.
                    !(me&ollbs,R,'brackstable'
                        && sa({async:msg}))
                        && ha('waits:async')
                }
                else {
                    ha({err:msg})
                }
                n error  $s:er,R %Error
            }
        })
        each ti plans {
            # for %%dome=$plan
            me&dome_traction,R,t,{el:2};
        }
        
        if (me&rolltog,R,{k:'T',once:1}) {
            me&ha,R,"bump";
        }
    },'ift,D'],
    
   # < use %Zave
   // Jfin - !%Zave outputs
    ['Jfin',0.297,&acgtRs{
        me&reaw,R,'Jfin,eph';
        $S = me&inode,R;
        ah(R,'inheritscif','ball','Runthing',1);
    },'ift,D'],
    ['Runthing',0.297,&acgtRs{
        me&reaw,R,'Runthing,eph';
        $S = me&inode,R;
        me&settle_prev,R and return
        
        Rs&notfinal and return s&bri = 0.6
        $t = sy&t;
        !t and return me&tsc,'!yt'
        $D = ts&C;
        $k = ts&store;
        $n =
        n $k  R %Pave:W,directory:SummerCat
        ns&title = D.t;
        k != 'W' and ns&species = k
        
        ss&dige = ts&dige;
        
        $D = ts&C;
        $J = Dc&J;
        $t = Js&top;
        $osc = t && ty&osc;
        $store = osc && oscs&store;
        $string = store[k];
        ss&string = store[k];
        dig(ss&string) != ss&dige and me&tsc,"thestring",'','b'
        
    },'ift,D'],
    ['Runthing',0.46,&acgtRs{
        $g = me&opeolo,"Runthing",{walls:1};
        each t,Pave Rs&Zaving {
            Paves&waits and return me&waits,'Pave...'
            $Q = Paves&Q;
            $pa = gy&can('m',t);
            pas&mah = 30;
            #!pas&ope and continue
            
            Qc&el == 9 and me&mtsc,pa,'New!'
            else {
                $c = {t:t,Zif:1};
                c.got = s;
                c.exp = Qs&P;
                $di = me&Ret,R,c;
                me&zN,di;
                me&Ring,di,{und:di,ov:314};
                me&zuct,pa,di;
                pas&dis = 1;
                each in dis&waits {
                    ac(R,'waits',n)
                }
                Rs&summary = dis&summary;
            }
          // push
            $go = me&rolltog,R,{maydo:'Push',once:1,tsc:'B'},0;
            # sticks on while dige same
            go ||= me&sa,R,{Pushable:ss&dige};
            if (go) {
                if (!me&rollbs,R,'sent_string' ) {
                    # Q asks
                    ~>3 push: R.t
                    Paves&commitstring(ss&string);
                    Rs&sent_string = 1;
                }
                if (Qs&string == ss&string) {
                    me&tsc,'pushed';
                    # it cancels the go
                    go = 0
                }
                else {
                    $pu = me&tsc,'pushing'
                    me.nto(R,pu,&{ 
                        ~>3 repush: R.t
                        delete Rs&sent_string })
                }
            }
            go and me&ha,R,{Pushable:ss&dige}
        }
    },'ift,D'],
    
   // testmode for SummerCat|brackstable 
    ['brackstable_aware',0.33,&acgtRs{
        me&reaw,R,'brackstable_aware';
        $is = me&ollbs,R,'brackstable'
        !is and return
        $d = me&tsc,'brackstable-lives','=='+is,'y'
        dy&cv = 0.298
        me.nto(R,d,&{
            # forwards attention downstream, as if a fresh &settle
            $se = sy&settled
            ses&bump = 1
        })
    },'ift,D'],
    ['Jpara',0.299,&acgtRs{
        Rs&brackstable_aware = 1;
        me&reaw,R,'Jpara';
        $S = me&inode,R;
        # things to &settle before J thinks
        $N = Ry&up.sc.z.filter(r => r != R && rs&ball);
        #N.map(n => me&nu,nc&s )
        Rs&brackstable_aware = 1;
        me&settle,R,N and return ~>3 unsettled!:
        Rs&settled = N;
        ~>3 settled:
    },'ift,D'],
    ['Jpara',0.2999,&acgtRs{
        me&jaa,R,'bumping' .map(&n{
            ~>4 peraps: haks(n.sc).join(",")
        })
    },'ift,D'],
    ['testmode',0.2991,&acgtRs{
        me&reaw,R,'testmode';
    },'ift,D'],
    ['Jpara+settled+testmode',0.2995,&acgtRs{
        $M = [];
        $N = Rs&settled;
        N.map(&r{
            me&ioty,r .map(&r{
                if (rs&bumping) {
                    ~>4 seebumps: r.t, rs&bumping
                    # < the %%viar is missing from &brackology display,
                    #   but always present in &jaa selection below:
                    me&ha,R,{viar:rc&s,bumping:rs&bumping,dome:'clings'}
                }
            })
        })
        N.map(r => M.push( ... me&ioty,r,'Paving' ) )
        me&ha,R,{isalive:1};
        M.map(r => me&ha,R,{hasathing:r.t,dome:'things'} )
        me&nu,"Brzin",M
    },'ift,D'],
    ['Yuse',0.299,&acgtRs{
        Rs&brackstable_aware = 1;
        $S = me&inode,R;
        me&reaw,R,'Yuse';
        $Yuaving = 'Paving:W,fully,openey,Yuaving';
        me&bal,'Fields',Yuaving
        me&bal,'Delirium',Yuaving
        Rs&testmode &&
            me&bal,'Delfium','Yuaving,decoy'
    },'ift,D'],
    ['Yuaving+decoy',0.47,&acgtRs{
        Rs&brackstable_aware = 1;
        me&reaw,R,'Yuaving,decoy';
        me&rollbs,R,'bumping',3;
        if (me&rolltog,R,{k:'Trub',once:1}) {
            me&ha,R,"bump";
            Rs&bumping++
        }
        me&ha,R,{blumps:Rs&bumping}
    },'ift,D'],
   
  // Glimpes Textl
    ['Glimpes',0.32,&acgtRs{
        me&reaw,R,'Yinghost,cm';
        $w = me&t,R,'ghost','Yingmas-light';
        #$w = me&t,R,'ghost','Dome';
        !w and return me&waits,'t...'
        me&rollbs,R,'Yinghost';
        me&rolltog,R,{maydo:'reset-w'} and delete Rs&Yinghost;
        $z = Rs&Yinghost ||= Cye(w);
        zs&dige != ws&dige and z = Rs&Yinghost = Cye(w);
        
        me&Tie,R,'sayeth',1;
        if (Rs&sayeth != null) {
            zc&s = Rs&sayeth;
        }
        
        $cm_hidden = 0;
        if (1) {
            $t = "ste";
            'always recreate cm' && 1 and t += Rs&icount
            $cm =
            n $t 1 $s:zc&s %e:2
            cm_hidden and cms&dis = 0;
            $cmsc = cms&cm_sc = {hoistcm:R};
            $cm = me&rollbs,R,'cm';
            !cm and me&waits,'cm...'
        }
        # %chunksfold does it
        if (0) {
            cmsc.chunksfold = 1;
            return;
        }
        
        # or with guts hanging out
        $lines = zc&s.split("\n");
        !zs&chunks and me&chunksoflines,z,lines
        
        cmsc.valuecha = &acgt,cm{
            ~>5 gave value:
            $ope = me&cm_foldmap,cm
            me&cm_foldCode,z,ope,cm;
        };
       // chunks debug
        $ope = cm && me&cm_foldmap,cm || {};
        each is zs&chunks {
            $f = ope[ss&line];
            f and fy&chunk = s
        }
        if (0) {
            each if ope {
                $ch = fy&chunk;
                ch && chs&indent > 10 and continue
                $m = fs&mark;
                $pos = m.find();
                $loc = lines[fs&line];
                
                $g = me&tsc,"fold-on:"+fs&line,0,1
                !ch and me&mtsc,g,"surprise",0,'y'
                else {
                    me&mtsc,g,"loc",0,'y' .c.s = lines[fs&line]
                }
            }
        }
        if (1) {
            # a map, could ...
            $dive;
            me&indo,z,{dl:15} (&sd{
                d.d > 3 and return;
                if (!d.dive) {
                    $v = dive = d.dive = Cye(s);
                    v.t = 'dive';
                    vs&foldiness = ss&size / ss&lines;
                }
                else {
                    s = d.dive = me&fiu,d.dive,Cye(s);
                    sc&s = lines.slice(ss&line,ss&toline+1).join("\n");
                }
            })
            if (dive) {
                delete dives&of;
                n zoap  $s:dive,R %ball,tightly,noDescribe,reneg
            }
        }
    },'ift,D'],
  
  // Hoosh - /peek/g/j/28* -> G/g/j/*
    # proto how sweetly we shall soon do such:
    # < w:Hoosh, S-ing hierarchy spreading related objects
    #    so our Know %Paving=peek%line=<3/%line=4-4000
    #   Pave is externalised dependency doming
    
    # < 284:Foogla drops '#c %mund = GhoNut'..<'#c ting fance'
    #   joining keepers from Tongingness (%ting) to Domingness
    # < after git reset we should recheck all ting
    ['Hoosh',0.293,&acgtRs{
        $S = me&inode,R;
        me&reaw,R,'Hoosh';
        ah(R,'inheritscif','ball','Hooshin',1)
    },'ift,D'],
    ['Hooshin',0.2907,&acgtRs{
        ah(R,'noadhere','twmt',1)
        ah(R,'inheritscif','ball','Hooshin',1)
        me&reaw,R,'Hooshin,Comvalve,Comvave,Comvalue';
        $p = Ry&up;
        
        # compile side
        ss&Comvave and Rs&Comvave = 1
        else
        ps&Comvave and Rs&Comvalve = 1
        else
        ps&Comvalve and Rs&Comvalue = 1
        else
        if (ss&Lave) {
            $ope = Rs&play || ps&play ||
                me&rolltog,R,{maydo:'+%Lave'};
            !ope and return
            me.adhere.Paving(Ry&up,R);
            Rs&Paving = Rs&Lave = ss&Lave
        }
        else {
            me&tsc,"UNKNOWN"
        }
    },'ift,D'],
   // Comva*
    ['Comvave',0.29071,&acgtRs{
    },'ift,D'],
    ['Comvalve',0.29071,&acgtRs{
        # < make W:g-j
        # for R/r/%Zave=ghost
        # < ss&section=1 should do it, if %Paving...
        Rs&Section = 1;
        me&reaw,R,'Comvalve,Section';
    },'ift,D'],
    # take s from Lave, start saving it here
    ['Comvalue',0.29071,&acgtRs{
        $z = sy&Lave;
        !z and return me&waits,"!sy&Lave"
        $r = zy&R;
        $L = rs&Live;
        !L and return me&waits,'!L'
        !Ls&lines and return me&waits,'!L%lines'
        Rs&Live = L;
        
        $din = me.cbu(R,'Section');
        !din and throw "!section"
        n ghost  $section:din.t,R %Pave:ghost
        
        #me&nu,"From",z;
        #me&nu,"The",L;
        #me&nu,"s",s;
    },'ift,D'],
    # sleep, compile, saving it here
    ['Comvalue',0.6,&acgtRs{
        Rs&waits and return
        $r = Rs&Zaving && Rs&Zaving.ghost;
        !r and return me&waits,'!Zaving.ghost'
        $coms = rs&commitstring;
        !coms and return me&waits,'!coms'
        $Q = rs&Q;
        $L = Rs&Live;
        
        # unindent from yaml $k: |\n(    ...)+
        $lines = Ls&lines;
        #lines = lines.slice(0,130);
        $once = 0;
        each il lines {
            !l || l.substr(0,4) == '    ' and continue
            !once++ and debugger;
        }
        once and return me&waits,"Weirdind"
        $notind = lines.filter(l => l && l.substr(0,4) != '    ');
        notind.length and return me&waits,"!allind>=4" && me&nu,notind
        lines = lines.map(l => l.substr(4));
        
        # drop certain chunks
        $hashc = '#'+'c';
        $deletes = {};
        if (s.t == "Foogla") {
            deletes[hashc+' %mund = GhoNut'] = hashc+' ting fance';
        }
        $delete_til = '';
        lines = lines.filter(&l{
            if (delete_til) {
                !l.includes(delete_til) and return 0
                delete_til = '';
                return 1
            }
            each tn deletes {
                !l.includes(t) and continue
                delete_til = n;
                return 0
            }
            return 1
        });
        
        $z = sy&Lave;
        $m = zs&headline.match(/(# .+)$/);
        (m) and lines.unshift(m[1])
        #me&nu,'z',z;
        
        delete ss&string;
        # DIY diff
        $string = lines.join("\n");
        string.slice(-1)[0] != "\n" and string += "\n"
        
        $W = Qc&s;
        !W && Qc&el != 9 and return me&waits,'!W!el9!?'
        W && !Ws&dige and return me&waits,'!dige'
        W && Ws&dige == dig(string) and return me&tsc,'done'
        coms(string)
    },'ift,D'],
   // Lave
    ['Lave',0.4,&acgtRs{
        me&tsc,"Lave"
        $p = Ry&up;
        #delete Rs&Paving;
        Rs&waits and return me&tsc,"%waits",'','y'
        ss&tabove and sy&tin = pc&s;
    },'ift,D'],
    ['Lave+Live',0.6,&acgtRs{
        $L = Rs&Live;
        Rs&waits and return me&tsc,"%waits",'','y'
        if (Ls&type == 'd') {
            each il Ls&lines {
                $r = me&input,R,l;
                $z = rc&s;
                zs&args = "line:<3";
                zs&Lave = 'peek';
            }
        }
        if (Ls&type == 'f') {
            if (Ls&between) {
                # interpret betweens as items
                $N = me&peek_betweens,L;
                $onlytw = ss&onlytw && G&peel,ss&onlytw;
                $droptw = ss&droptw && G&peel,ss&droptw;
                
                each in N {
                    # < CBing its expected dige
                    onlytw && !onlytw[n.t] and continue
                    droptw && droptw[n.t] and continue
                    ns&shouldige = delete ns&dige;
                    $r = me&input,R,n.t;
                    $z = rc&s;
                    ex(z.sc,n.sc);
                    # will get huge responses, up to filesize limit
                    zs&args = "line:"+ns&line+"-"+ns&toline;
                    zs&Lave = 'peek';
                    # Q.t filename, not the pin, args differntiate them
                    zs&tabove = 1
                }
            }
            else {
                # < into CB|lookaQ
                ss&shouldige && ss&shouldige != Ls&dige
                    && me&tsc,"~dige!";
                
                $more = ss&length > ss&lineto;
                ss&line == 0 and 'start wandering in'
                # < and similar, check lines overlap,
                #   tailing logs read back until we know
                #    probably sensing now before wandering back
                #me&nu,"L",L;
                
                # < doesn't retract %%eto if bailed with %%waits?
                #$q = {tw:s.t,s,L};
                $eto = me.cbu(R,'Hoosh');
                #!eto and return me&waits,"no^Hoosh"
                #Ry&ha(q,{eto});
                # so serve that request from here
                $cr = me&input,eto,'Comvave';
                $cz = crc&s;
                # different to a %Lave
                czs&Comvave = 1;
                $p = Ry&up;
                # < pattern match or set what to name container
                $m = p.t.match(/\b(\w+)\/(\w+)$/);
                !m and return me&waits,"Name-container"
                # so as to not turn up as G/*/$t
                $cot = 'g/'+m[1];
                $cor = me&input,cr,cot;
                $coder = me&input,cor,s.t;
                $cs = coderc&s;
                csy&Lave = s;
            }
        }
        #me&nu,L
    },'ift,D'],
    &{
    me.peek_betweens = &acgtL{
        $N = [];
        $line = 0;
        each il Ls&between {
            if (l) {
                $m = l.match(/^(\d+)x(\w+)$/);
                !m and throw "nonbetween"
                l = Ls&lines[i-1];
                l == null and throw "nonline"
                # < anything. indent, \n\n, strange formations
                $tm = l.match(/^(\S+): \|/);
                !tm and throw "!yaml", l
                $t = tm[1];
                $n = Cye([t,1]);
                # not including the headline
                ns&headline = l;
                line += 1;
                ns&line = line;
                line += +m[1];
                ns&toline = line-1;
                # should yield:
                ns&dige = m[2];
                N.push(n)
            }
            else {
                i != 0 and throw "nobetween", i, l, L
            }
        }
        return N
    }
    },
   
  // Travelty
    ['Travels',0.39,&acgtRs{
        # < wants to cautiously inode while adhere-ing,
        #   to see if we set up:
        Rs&twmt_only = &jz{
            return zs&W || 1
        };
        me&ha,R,"Travels,to:Morrocco";
        
        # forwards finisheds it to worriment device
        # 
        me&jaa,R,"e" .map(&n{
            $e = ns&e;
            me&bal,"Re:"+e.t,e,'Releasor,MayGhost,eph'
        })
        
        return;
        me&ha,R,"Travels,to:everywhere",{R};
        #!me&za,R,'fodder' ? me&ha,R,'fodder,lamp' : me&ha,R,'lamp'
        
        me&ha,R,"Travels,to:everywhere",{R};
        $le = me&zaa,R,"Travels",'to';
        
        $p = sy&p;
        $pat = ss&pat ||= 'ology';
        me&nodei,R,py&r,{pat};
        me&jaa,R,{efrom:py&r.y.s,raga:1} .map(&n{
            le.push(ns&raga)
        })
        
        each in le {
            n = me&tsc,"land",n,'G';
            ns&dis = 1;
            ns&fs = 33;
            
            ns&hue = i*40;
            ns&blr = 9;
        }
    },'ift,D'],
    
    ['Duolish',0.303,&acgtRs{
        me&jaa,R,"efrom,pat" .map(&n{
            $q = {};
            q.raga = ns&pat.split('').join('_');
            me&nodei,R,ns&efrom,q
        })
    },'ift,D'],
  // Releasor - Travel agent
    =pod see %Compiling
      a %Compiling in its push-phase,
       can decide to redo, because CBing, already
    
     Travel%%tw=$t should match:
     Ghost%twin/$t, giving (/of/$kt)
     Know%%tw=$kt same in reverse
     # on the inside of the join:
      Ghost..$t may know %%tw,s,host=Travel|Know already
     # on the outsides:
     Travel|Know p are %twinned by Ghost,
      Ghost providing queries from their perspective
       on Ghost p %structure, [C:t,C:of,C:t]
     
     Then we should end up with...
     < sheets of $t..$kt to apply to the joins:
       u towards Know:
        should still be that version
       n towards That:
        
       
     < other Ghost... joining Know..$kt etc,
       must have their truth shrunk onto the join,
       since we are replacing the shared record of something
       this is like getting pinned at a version, 
     < some even more complex Zave-tuition
    =cut 
    ['Releasor','298',&acgtRs{
        me&reaw,R,'Releasor';
        $S = me&inode,R;
        # to %ball/* from y&tw over s&z
        Rs&childy = 'tw';
        $tr = Ry&up;
        tr = trc&s;
        # < stop using y&p
        $p = try&p;
        !p || tr.t != 'Travel' and throw "Travel?"
        
        # s was e, replaced on shunt
        # is the reality (Re:$t), beside the thing itself ($t)
        
     // func
      # < io this easy
      // y&Q leavers
        # $Steu/of(/args)?/t -> callback
        me.ofargsity = &acgt,Steu{
            return &y{
            me&indo,Steu (&sd{
                d.d <3 and return 's/of'
                $more = me&ioty,s .length
                more and return 'is an /args/ layer'
                $l = me.cby(d,&d{ return d.d <3 }).map(d => d.s);
                $t = l.pop();
                t != s and throw "confu";
                $of = l.shift();
                $args = l[0];
                # may not have args
                y (of,args,t)
            });
            }
        }
        # warn of args: $Steu/of(/args)?/t -> $f/of(/args)?/t
        # < for stretching %twin to support anyindex
        me.warn_argsity_of = &acgtWf{
            # W is the of column, nest it
            $cont = Cye(['eachofalone',1])
            me&fiu,cont,W;
            # warn of non of/t pushing (or whatever the %twin wants)
            me&ofargsity,cont (&of,args,t{
                $fo = me&fiu,f,of.t;
                args and fo = me&fiu,fo,args.t; ah(fo,'warn',"args-layer")
                $to = me&fiu,fo,t.t;
                args and me&zu,"hasArgs:",to
                toy&Q = t;
            })
        }
        # ac args: $Steu/of(/args)?/t -> $f/of/t%args[]
        # for writing as W.5
        me.Stearchish_to_twin = &acgt,Steu,f{
            $N = [];
            me&ofargsity,Steu (&of,args,t{
                $fo = me&fiu,f,of.t;
                $to = me&fiu,fo,t.t;
                tos&dige && tos&dige != ts&dige and throw "multiple diges ->"+to.t, t, toy&Q
                toy&Q = t;
                tos&dige = ts&dige;
                args and ac(to,'args',args.t)
                N.push(to)
            });
            return N
        }
        me.Stegroup_species = &acgtW,Steg{
            # sublate any species (share one $kt)
            #  $m:Dealap,$n:Dealap/js -> $m:Dealap/$n:js
            # < order by length of SteW/*.t, hier not fair
            $c = {yorigin:'Q',
                match:&mn{ return n.t.startsWith(m.t) },
                then:&mng{ 
                    g.t = gs&species = n.t.substr(m.t.length+1);
                    g.t && !g.t.includes('/') and 'ok'
                    else {
                        throw "species!grouping", m, n
                    }
                }
            };
            me&sublatile,W,Steg,c;
        }
      
      // y&origin leavers
        # rebuild and replace? $n/#$t
        me.Stereo = &acgtWt{
            !isC(W) and throw "!C W"
            W = Wy&origin || W;
            $eg = Cye(W);
            # to somewhere else
            isC(t) and $F = t
            else {
                # replacing
                $F = Wy&up;
                !F and throw "W!up"
                # ~t adding
                isst(t) and eg.t = t
                
            }
            egy&origin = W;
            return &y{
                y (W,eg);
                # places new thing
                !F and return
                $f = me&fiu,F,eg,8
                f && f != W && fy&origin != W and throw "knot sure", F, eg, f
                F and me&fiu,F,eg
            }
        }
        # regroup into each other
        me.sublatile = &acgtWtc{
            $into = t;
            c.yorigin ||= 'origin';
            me&ioty,W .map(&n{
                $g = Cye([n.t,2]);
                g.y [c.yorigin] = n;
                each im intos&z {
                    m == n || !c.match(m,n) and continue
                    c.then(m,n,g);
                    me&fiu,m,g
                    return
                }
                me&fiu,into,g
            })
        }
        
    // dunketha
      // outputs + 5 -> twin-form
        # have outputs
        $Sten = me&fiu,s,'n';
        $Steu = me&fiu,s,'u';
        
        # to output, nego into %twin
        $twine = me&fiu,s,'twine';
        # z first, leading up
        ss&z = arou(ss&z,z => z == twine,[]);
        ss&z.unshift(twine);
        
        # n
        $twn = me&fiu,twine,'n';
        # < various use cases for a wait-for-ok
        !me&fiu,Sten,'W' and return me&waits,"!W"
        
        me&ioty,Sten .map(&W{
            me&Stereo,W,twn (&W,eg{
            # schematic of what Q to place where
            $Steg = Cye(['g',1])
            
            if (W.t == 'W') {
                # make a pile of W%dige/[species%dige+]
                me&Stegroup_species,W,Steg;
        
                # each W make W.5 re this u/n configuration
                # make W.5 for each W grouping
                me&ioty,Steg .map(&m{
                    $f = Cye([m.t,9]);
                    # the 5.sc[$species] = dige, inc 1=Ws&dige
                    $spec = {1:m};
                    me&ioty,m .map(n => spec[n.t] = n);
                    each tn spec {
                        # the SteW/* is Qish: Q%string%dige without %of%args
                        #  which are implied by their placement in the Searchish
                        $Q = ny&Q;
                        f.sc[t] = Qs&dige
                    }
                    # re this u, flattening args
                    # < of:wjs -> of:w through the join?
                    #   see W|w: their species pool dige sensitivity
                    me&Stearchish_to_twin,Steu,f;
                    # f -> Qish q
                    $q = Cye(['5',2]);
                    qs&string = me&Lineso,f;
                    qs&dige = dig(qs&string);
                    # species thing fronting q as a writable of $W
                    me&fiu,m,q.t,8 and throw "already had a W.5", m
                    # into the Qish pile we began with
                    $n = me&fiu,m,q.t;
                    ny&Q = q;
                })
            }
            else {
                # copy anyway!
                me&warn_argsity_of,W,Steg;
            }
            
            # n... have %string etc from y&Q
            #  Steg structure y&Q -> g
            #  for something %%twin->Paving compatible re %species
            #  all other $of should just work?
            # < io resolving to y&Q, type checking
            me&indo,Steg (&sd{
                d.d <2 and return
                $p = d.la || eg;
                $v = sy&Q;
                !vs&dige and throw "notdiged",s,v
                v = d.la = Cye(v);
                # < doesn't keep the 
                vy&Steg = s;
                # t=$W/js -> js
                v.t = s.t;
                me&fiu,p,d.la
            });
            })
        })
        
        # n/W is now folded like %twin of/t
        #  with extra n/W/$species for Pave to realise exactly
        # checks others dont /args/
        # < %twin should learn anyindex:
        
        # < only for of:wjs?
        #   you might want the %twin|%Paving indexing to carry the args
        #   eg for watching lists,
        #    or anything but W|w which pool one big dige per thing
        # so in the .5 we know individual args,
        #  so reruns can more fully prepare eg of:wjs
        # yet for overall versioning,
        #  w:$t%dige is all Ghost/Know remembers
        #  will cover wjs:$t%dige(same)%args
        # W%dige covers W.js etc but not W.5,
        #  but W.5%dige covers W+W.js
        # < a ghost/w/wjs have the same %dige?
        
        # fold up all the u:
        # < wjs->w?
        # u... only have %dige etc (not even %args?)
        $twu = me&fiu,twine,'u';
        me&Stearchish_to_twin,Steu,twu .map(&to,{
            # drop deindexed info
            delete tos&args;
        })
      // outputs -> twin-linkage
        # looks for u/n stores behind/ahead of Travel
        # < complicated ideas
        
        each in ps&twinned {
            # < find t there, make &acty=3
            ns&remotes[0] != p and throw "aban"
            $r = ns&remotes[1];
            $h = r.t == 'Know' ? twu :
                r.t == 'That' ? twn : 0
            !h and throw "unremote", n, r;
            # for %MayGansp
            hy&release = s
            # Travely&p
            hy&host = p
            # Ghosty&pc&s
            hy&twin = ny&s
            # Knowy&p
            hy&remote = r
        }
        
        # < make a 5 about this s, added to itself,
        # < added to n, push via %twin
        #   W:Dealap will be a single yonder,
        #    though while this awake the 5 + js may update
        #   then Fingo should save asap
    },'ift,D'],
    &{
    me.deboost = &acgt{
        $R = Cy&R;
        # < Babz: //= # !null-or
        Rs&boost == null and Rs&boost = -1
    }
    
    me.bin = &acgtk{
        $R = Cy&R;
        isst(k) and k = G&peel,k;
        each tv k {
            ah(R,'inheritscif','ball',t,v)
        }
    }
    },
    ['MayGhost','298',&acgtRs{
        me&reaw,R,'MayGhost,eph';
        me&bin,'MayGhost';
        $l = me.cby(R,'^^Travels').length;
        l == 3 and s.t == 'twine' ? me&bin,'MayGansp' : me&deboost
        
        l <3 and return
        (Rs&boost||0) < 0 and Rs&thiding = me&ioty,s .map(z=>z.t)
    },'ift,D'],
    # %twin climb beings, to its idea of us
    ['MayGansp','298',&acgtRs{
        me&reaw,R,'MayGansp,eph';
        me&bin,'MayTwine';
        $S = me&inode,R;
        
        $g = me&case,34
        $twin = sy&twin;
        !twin and throw "!join to"
        gy&can('m','to').y.can('i',twin.t);
        
        $rs = sy&release;
        !rs and throw "!t->u/n bunch"
        # Ghost%%tw is mixed host=from|yonder
        $host = sy&host;
        !host and throw "!join from"
        hosty&s != sy&path[0] and throw "join from!this step", host, s
        # < %twin-like anyindex to anywhere
        $re = sy&remote;
        !re and throw "!remote host yonder"
        
        $j = me&yfuture,twin;
        # < resolve our thing there...
        $W = me&zaa,j,{host,tw:rs.t};
        W.map(&n{
            # Ghost/* found its Travel/*
            ns&s == sy&client;
            me&ha,R,{found:ns&efrom}
        });
        W.length > 1 and return me&waits,"many";
        
        # auto input Ghost/*<=%MayGansp
        #  **<=%MayTwine wait for ready
        #  this e retracting when we finish updates Ghost
        me&nodee,R,j,Cye([rs.t,1]),{},{el:2}
        
        me&tsc,"mg",'','d'
        
        (Rs&boost||0) > 0 and me&zu,"MayGansp.s",s;
    },'ift,D'],
    ['sleeping+wou_accepted','298',&acgtRs{
        # %wou must be there to access _accepted
        # < why w_a if no w when tunneling?
        me&rollbs,R,'wou'
    },'ift,D'],
    ['MayTwine','298',&acgtRs{
        me&reaw,R,'MayTwine,eph';
        me&bin,'MayTwine';
        $S = me&inode,R;
        $mg = me.cbu(R,'MayGansp')
        $p = Ry&up;
        $zp = me&zaa,p,'found',1 [0];
        # to be put in $zp/$z
        $z = zp && me&fiu,zp,s.t,8;
        if (z) {
            me&ha,R,{found:z}
            $he = heq(z.sc,s.sc);
            me&nu,'he',he
        }
        else {
            me&ha,R,{should:s}
        }
        
        # nearly home
        # &nodeo not found sends attention there:
        #  extra %twin &settle host makes it go,
        #  obscuring the probably still open:
        #   Travel's tw making gets forgot:
        #   < %%eto dont land there reliably, is it:
        #    < coinciding &Yinge not lost
        
        # < to be fairly %onlyish as we rattle toward ready
        # < using %acty levels to move readiness around?
        #   they must &settle at each one,
        #   transmitting to neighbours
        #    was an inspiration for nodei
        # < &elnodes must visit any $p/$n we add,
        #    to make sure it gives %twmt
        #   Rsync not enough?
        # < each step should Ring 2-9, try/catch
        
        # and back to this,
        # < Know..s%Paving must be set up in the remotes
        #    or Ghost..s can be trusted to &nodei them?
        # < Ghost..s grows/shrinks and downloads s.sc
        #  < goners may gc Know..s if !ja,Ghost,{host:Know,s}
        #  < keepers may drop sc evident in Know..s
        #  < other Ghost..s may acquire sc, above in reverse
        # ^ loosely around:
        # < n must push to That..s
        # < u must be as Know..s, or Ghost..s may acquire sc
        
        # tw
        me&tsc,"data++",'','d'
        
        (Rs&boost||0) > 0 and me&zu,"MayGansp.s",s;
    },'ift,D'],
]};
me.Sch_Constel = &acgt{ return [
    # hierarchise, do batches of updates 
    # < more than W I mixes
    # < plots intention to travel
    # R%Conal waits for Know|That/...r%Pave+=%fully
    # < set %creatine
  &{
    # permanent act of setting some properties
    #  returns true if unlikely to have taken effect
    # < replace with send-receive ack
    me.Redialsc = &acgtRrc{
        $k = !c ? '' : haks(c).join(',');
        k = 'Redialy'+(k?'-'+k:'');
        # is all there or 404
        $fok = r && (rs&Paving_goodin || rs&creatine);
        !fok and return me&waits,'!fok'
        if (me&sa,R,k ) {
            haks(c).map(k=>r.sc[k] != c[k]) and throw "undialed"
            ha(k)
        }
        else {
            ex(r.sc,c)
            me&ha,R,k;
            return 1
        }
    };
  },
  // Conste 3{
      # code vectoring along C between G
        ['ball+Conste','31',&acgtRs{
            $l = sy&l;
            sy&f = ly&f;
            # if top, have + ignore src f
            #  see unifiers may have ground
            sy&top == s and sy&f = ly&inf
            else {
                # non-top, must use ouf if non-leaf
                sy&f = ly&leaf ? ly&inf : ly&ouf
            }
        },'ift,D'],
        ['ball+Conste','32',&acgtRs{
            T.Mw = 'Conste';
            # from in or out?
            $f = sy&f;
            $Q = fs&Q;
            !Q || !Qs&ready and return me&waits,'!Q'
            me&Redialsc,R,f,{fully:1} and return
            Qc&species == 5 and return me&waits,'Q5'
            
             
  // Conste-ing{
            # only top %Conste compiles
            sy&top != s and return
            
            # o **!%redialy
            #  very in future
            $N = sy&N.map(s => sy&R).filter(&j{
                return !me&sa,R,'Redialy'
            });
            N.length and return ha('waits:them-redialy')
            
            # check out n
            $cha = [];
            $Lives = [];
            each in sy&N {
                $j = ny&R;
                $f = ny&f;
                !f and return me&waits,n.t+"-!f"
                !fs&Live and return me&waits,n.t+"-!f%Live"
                # fs&Live stills
                $was = me&rollbs,j,'Live';
                fs&Live != was and cha.push(cha)
                js&Live = fs&Live;
                # < copy into This/$t/{origin,comp} meanwhile
                #   to externalise to perl to jsbabz it
                #   to apply hacks in waves to it, so differ
                #   to allow processing over many lives
                #    syncing Know/* to resume/complete
                
                # see how the things should mix before hacking?
                #   to reduce the load to:
                # hacking each W as per ...
                # draw attention to hacks on the inside
        
                # any fy&Gc&s.sc.* unknown may be instructions
                # fy&W may have access to:
                # < Search%Mix.W low level tv mixage
                #   should mix %ting=js|W
                #     Ws&I/$of/$C as $W/$of/$C
                #   would be where I needs bootstrapping
                #    from a dozen few-thousand line /js/
                #     to a few dozen thousand line /W/
                #      with some Babzing before it I's too
                #      so we have a bunch of ghost to show for it
                
                # < look in Hacks/$t for compile tricks
            }
            $Lives = me&ioty,R,'Conste'
                .map(j => js&Live);
            Lives.filter(L=>!L).length and return me&ha,R,'waits:them-Live'
            
            me&rollbs,R,'Ready';
            cha.length and delete Rs&Ready
            
            # this mix in the source
            $D = Rs&Live;
            # < don't need it to be there
            !D and return me&waits,"!live"

            $g = me&opeology,"%Ready",{walls:1};
            ac(R,'M',g);
            if (gs&ope) {
                $re = me&opeKm,g,"redo?"
                res&ope and delete Rs&Ready
            }
            
            if (!Rs&Ready) {
                $Ready = Rs&Ready = me&unifydin,D,Lives;
                !Ready and return me&waits,"unifydin.."
                # we can/should attach s&W from Wind
                $Wi = Readyy&Wind || {};
                each kv Wi {
                    fio(Ready,[k,1,{},{W:k,ha:v}]);
                }
                # the osc that knows about this C
                Readyy&s = s;
            }
            $Ready = Rs&Ready;
            
            $c = {};
            c.closish = Rc&brackuiet && !Rc&brackope;
            me&opeuni,g,Ready,Lives,c;
            
            if (gs&ope) {
                me&nu,'Conste',{Ready,Lives}
            }
            
            # back to Conal
            $l = sy&l;
            $r = ly&R;
            me&ha,r,{Ready}
        },'ift,D'],

  // Conal 31
        # the pile of codes moving towards That/**$t
        # before
        #  leaf nodes read Know/**$t, write That/**$t
        #  others (can only mix) from and to That/**$t
        ['ball+Conal','31',&acgtRs{
            # < make these work a bit more varsier
            # Know/**$t
            # 
            $inf = me&supry,s,'yf','yl';
            inf and sy&inf = inf; me&ha,R,{inf}
            
            # That/**$t, if found...
            # That, beyond steps of compilationisms from Comal
            $L = me.cbu(R,'Ying').sc.Lastly;
            L = Ly&R;
            # get sy&fin = That..s
            #  s's mirror in the final A
            # gets sy&ouf to where it will be wanted
            me&supwyth,R,s,'fin',{theys:'l',top:L};
            
            
            $ouf = me&supry,s,'yf','yfin';
            ouf and sy&ouf = ouf; me&ha,R,{ouf}
            # which one...
            #  later tries to include non-leaf src W 
            #   to check it doesn't have grounds...
            #   < may not exist back there,
            #      since Comal grew it
            # < should be able to have grounds,
            #   yet doing this all with J/ping action
            #   rather than mixing compileds would be better
            $leaf = ! me&ioty,sy&l,[''] .length;
            leaf and sy&leaf = 1;
            sy&f = leaf && inf || ouf || inf;
            
            
            ss&coung ||= 0;
            $le = ss&coung++;
        },'ift,D'],

  // Conal 32
        ['ball+Conal','32',&acgtRs{
            T.Mw = 'Conal';
            me&reaw,R,'Conal';
            # < waits for &settle?
            ss&coung <= 1 and return me&waits,"aft-init"
            
            # f ~ref is ok, Comal checks ~Live
            # < test:
            #  to redo work that may depend on it
            #  eg delete rows with dep:yf
            # < wrap ha() with row template
            #   to add such a dependency to each thence
            
            # L=That
            $L = me.cbu(R,'Ying').sc.Lastly;
            L = Ly&R;
            # non-leaf && non-existent That..G
            !sy&leaf && !sy&ouf and me&ha,R,'mot:no-ouf'
            # fs&changey at either That/Know
            $yf = ['inf','ouf'];
            each ik yf {
                $f = s.y [k];
                !f and continue
                fs&changey and me&ha,R,'mot:cha,yf:'+k,{},{f}
            }
            # any mot-ivation
            if (me&ja,R,'mot' ) {
                # excites ups
                $mot = {mot:'char'};
                
                # defers ups until Updated
                #  may be not That/$t-changey by their turn
                !ss&Updated and mot.fro = s
                
                # aplup helps ha to a different node?
                throw "refactor me.aplup"
                #me.aplup(s,&ha,{ me&ha,R,mot });
            }
            
            # ^ goes around, now fro would be:
            $ready = !sy&leaf && me&sa,R,'mot' && !me&sa,R,'fro';
            
            $g = me&opeology,"Conal",{walls:1};
            ac(R,'M',g);
            if (gs&ope) {
                $re = me&opeKm,g,"putready?"
                res&ope and ready = 1
                
                $zu = me&opeKm,g,"zu"
                if (zus&ope) {
                    me&zu,"Comal",s
                }
                
            }
            !sy&leaf && sy&f != sy&ouf and me&mtsc,g,'!oufyet'
            
            #return;
            if (ready) {
                # %SupplyChai finds this, makes into %Conste
                me&ha,R,'ready';
                Rs&suprise_c = {dl:1};
            }
            
  // Conal-ing
            # %Comste returns Ready=[C9 with y&s]
            $Ready = me&sa,R,'Ready',1;
            if (Ready) {
                # find it into That..G
                each in Ready {
                    # W:Something, s)%Comste:
                    $z = ny&s;
                    !isC(z) and throw "no ys"
                    # hop back to s)%Comal:
                    $lz = zy&l;
                    sy&top.y.N.indexOf(lz) < 0 and throw "Nofind zyl",z
                    lz != s and throw "lz nots"
                    
                    # make skinny tree to it, s)%Conal +
                    $stack = me.cby(lz,sy&top);
                    stack[0] != sy&top and throw "stack weird", stack
                    
                    # not suprise
                    $tr = L;
                    each im stack {
                        $r = me&input,tr,m.t;
                        $rs = rc&s;
                        rsy&R = r;
                        my&fin = rs;
                        rsy&l = m; # should persis/compete
                        rs&Thinting = 1;
                        ac(r,'trouble',"Conste-pushish");
                        tr = r;
                    }
                    rs.t != s.t and throw "not our name?",s,'->',r
                    
                    # send ourselves
                    me&ha,R,'Wup',n;
                    #me&nu,"Readzy",r
                    #me&nu,"fropmtop",stack;
                }
                
  // Conal-oung - Wunifyst
                # meanwhile, generate the upload and await push:
                $Wup = me&sa,R,'Wup',1;
                if (Wup) {
                Wup.length > 1 and me&tsc,"manyWups"
                each in Wup {
                    # having G/**s:
                    $ts = sy&fin;
                    $t = tsy&R;
                    $f = tsy&f;
                    me&Redialsc,R,t,{fully:1} and continue
                    
                    # %Comste %Ready -> encoding %Lines .1+5
                    # < cache it with all this sense
                    $st = me&Wunifyst,R,s,n,'clonn';
                    
                    # mark as being in That
                    fs&Wupular = 1
                    
                    # grapple each %Pave
                    $origin = sy&inf;
                    $dest = sy&f;
                    
                    $se = gy&can('m','Diffs');
                    ses&dis = 1;
                    $od = sey&can('m','origin/dest');
                    $vis = ody&ope ? origin : dest;
                    
                    $tw = {};
                    each t,Pave dests&Zaving {
                        $Q = Paves&Q;
                        $De = st;
                        t != 'W' and window.tee = t;
                        if (t == "W\.5") {
                            !sty&fivestring and throw "!5string"
                            De = Cye([Q.t,1,{},{string:sty&fivestring}]);
                        }
                        Dey&Pave = Pave;
                        tw[t] = De;
                    }
                    
                    each t,Pave viss&Zaving {
                        $Q = Paves&Q;
                        $De = st;
                        if (t == "W\.5") {
                            !sty&fivestring and throw "!5string"
                            De = Cye([Q.t,1,{},{string:sty&fivestring}]);
                        }
                        
                        # < attention upgrades to JRom
                        $pa = sey&can('m',t);
                        pas&dis = 1;
                        pas&mah = 30;
                        Qc&el == 9 and me&mtsc,pa,'New!'; continue
                        !pas&ope and continue
                        
                        $c = {t:t,Zif:1};
                        c.got = De;
                        c.exp = Q;
                        $di = me&Ret,R,c;
                        me&zN,di;
                        me&Ring,di,{und:di,ov:314};
                        me&zuct,pa,di;
                        each in dis&waits {
                            ac(R,'waits',n)
                        }
                        Rs&summary = dis&summary;
                    };
                    
                    # put it on disk
                    $go = me&rolltog,R,{maydo:'Push',once:1,tsc:'B'},0;
                    go ||= me&sa,R,{Pushable:sts&dige};
                    if (go) {
                        if (!me&rollbs,R,'sent_string' ) {
                            # Q asks
                            each t,De tw {
                                $Pave = Dey&Pave;
                                ~>3 push: R.t
                                Paves&commitstring(Des&string);
                            }
                            Rs&sent_string = 1;
                        }
                        $Q = dests&Q;
                        if (Qs&string == sts&string) {
                            me&tsc,'pushed';
                            # it cancels the go
                            go = 0
                            # and the grypes
                            delete ges&grypes;
                            # and the changey
                            delete fs&changey;
                            ss&Updated = 1;
                            
                        }
                        else {
                            $pu = me&tsc,'pushing'
                            me.nto(R,pu,&{ 
                                ~>3 repush: R.t
                                delete Rs&sent_string })
                        }
                    }
                    go and me&ha,R,{Pushable:sts&dige}
                    
  // Comalor or when found == + Know cha
                    if (ss&Updated) {
                        if (s == sy&top) {
                            # < all deleted when the top is Updated
                            me&mtsc,g,'Alldone!',0,'p';
                            me&SC_fcommit,R,s;
                        }
                        else {
                            $p = sy&up;
                            $pr = py&R;
                            me&ha,pr,'mot:upd',{},{supr:s}
                            me&ha,R,'Updated'
                            
                            $re = me&opeKm,g,"Up?"
                            res&ope and fs&commiting = 1
                            
                            zu && zus&ope and me&nu,"p",pr
                            

                        }
                    }
                }
                }
            }
            
            ss&count ||= 0;
            $le = ss&count++;
        },'ift,D'],
        ['ball+Thinting','63',&acgtRs{
            sy&R = R;
            
        },'ift,D'],
    &{
    # commit sy&N's f, making Cupload in %ting
    # < me&waits into wai as well,
    #  < modopting into brackdown
    #    as a thumbnail, over the specifics
    #    which could go on joined by ark:waits
    me.SC_fcommit = &acgtRs{
        $fs = [];
        each in sy&N {
            ny&inf and fs.push(ny&inf)
            ny&ouf and fs.push(ny&ouf)
        }
        $waifs = [];
        each if fs {
            fs&commiting ||= 1
            fs&commiting <3 and waifs.push(f)
        }
        if (waifs.length) {
            if (fs.length > waifs.length)
                me&nu,'stillf-commiting',waifs
            return me&waits,"G-commits"
        }
        $c = {maydo:'MindSave',once:1,tsc:'B'};
        $go = me&rolltog,R,c,0;
        !go and return

        $mi = me.cbu(R,'Ying');
        !mi and throw "No ^^%Ying"
        $mg = me.cbu(mi,'Gens');
        !mg and throw "No ^^%Ying^^%Gens"

        each in sy&N {
            delete ns&Updated
        }
        # turn off %MindInto
        me&introqua,mi,{play:0};
        # push/diff
        me&introqua,mg,{boost:1};
        me&tsc,"leaving"
    };
    #c unifydin Swims Things
    # Swim N into fresh D
    #  D is not a dome but the old C
    me.unifydin = &acgtDN{
        # the W:HutKitchen
        $ID = Cye(D);
        IDy&tw = {};

        # unifiers may have ground
        $Dnz = me&ioty,D,['']
            .filter(dW => !dWc&W && !dWs&W);
        if (Dnz.length) {
            # would be updated if we way the W,
            #  rather than plumb it indifferently
            # < find mirrors in We, keep over dup
            #   related to updating only Stylating,
            #     without loading siblings HutKichten/*
            me&zu,"extra_ground",Dnz;
            return
        }
        
        # Swimming things lose a layer of separation
        each id N {
            # have We things
            #  cW puts for a W, are their compiled W:of
            #  sW point to what they unified
            $dWz = me&ioty,d,[''] .filter(dW => dWc&W);
            each i,dW dWz {
                $Wt = dW.t;
                $eyei = 0;
                Wt == 'eye' and Wt = eyei = 'i'
                $IW = IDy&tw[Wt] ||= Cye(dW);
                IW.t = Wt;
                IWy&tv ||= {};
                IWy&cv != dWy&cv and ~>8 cvstrange: ID.t, IW.t
                # the of things are tiny:
                IW.y.cv = 0.001;
                
                ac(ID,'z',IW);

                each i,dt dWs&z {
                    $ty = IWy&tv[dt.t] ||= {};
                    $b = ty[dty&cv];
                    b and ac(IW,'overs',b)
                    b and IWs&z.splice(IWs&z.indexOf(b),1)

                    $It = ty[dty&cv] = Cye(dt);
                    dts&z and me&nu,"of/t/*",dt; return
                    ac(IW,'z',It);

                    # the origin of everything is very important
                    $Wa = dts&Wavel;
                    $l = [d.t];
                    if (Wa) {
                        $Waypin = Wa.split('/');
                        $Waypost = Waypin.pop();
                        Waypin.push(... Waypost.split(','));
                        l.push(... Waypin);
                    }
                    
                    eyei and Its&js = 'i'
                    Its&Wavel = l.join('/');
                }
            }
        }
        
        # Wind: ghostymotion with %ting %Live
        each iW N {
            $P = Wy&P;
            !P and continue
            # is a %ting %Live
            $Wi = IDy&Wind ||= {};
            Wi[W.t] = Ps&dige;
        }
        
        # order, hide %overs -> y&overs
        each i,IW IDs&z {
            IWs&overs and IWy&overs = delete IWs&overs
            tvsortz(IWs&z);
        }
        return ID
    };
    # looks at a compiled W
    me.opeuni = &acgtgDNc{
        $R = Cy&R;
        c ||= {};
        $Dg = me&opeology,c.t||D.t,{walls:1};
        fio(g,Dg);
        c.closish && !Dgs&ope and return Dg
        
        Dgs&dis = 1;

        if (N) {
            # say sources
            # < make %Wind (for .5)
            $Km = me&opeKm,Dg,'src',{};
            each iW N {
                $P = Wy&P;
                if (P) {
                    # is a %ting %Live
                }
                else {
                    me&waits,"!P:"+W.t;
                    me&mtsc,Km,'hasnoP','!P','G'
                }

                $Kn = me&opeKn,Km,W.t,{label:{}};
                Kns&fs = 7;
            }
        }

        each i,IW Ds&z {
            $Km = me&opeKm,Dg,IW.t,{};
            Kms&fs = 12;
            Kms&hue = 160;
            Kms&bri = 1.4;
            Kms&dis = 1;
            #n $IW.t  $s:IW,R %ball,tightly,reneg,refpool

            tvsortz(IWs&z);

            each i,It IWs&z {
                $Kn = me&opeKn,Km,It.t,{label:{}};
                Kns&fs = 7;
                if (Kns&ope) {
                    Kns&fs = 11;
                    Kns&dis = 1;
                    $dis = me&zu,"It",It;
                    me&zuct,Kn,dis
                }
            }
            each in IWy&overs {
                # < tested
                $Kd = Kmy&overs ||= me&opeKm,Dg,'dup';
                $Kn = me&opeKn,Kd,n.t,{label:{}};
                fio(Kn,['from',2,{s:(ns&Wavel||"?")},{fs:7,deco:1}]);
                if (Kns&ope) {
                    Kns&fs = 11;
                    Kns&dis = 1;
                    $dis = me&zu,"It",It;
                    me&zuct,Kn,dis
                }
            }
        }
        return Dg
    };
    # Wunifyst s-cached n-Lines
    me.Wunifyst = &acgtRsnk{
        $st = s.y [k];
        st && st.y [k+'ed'] != n and st = null
        if (!st) {
            st = s.y [k] =
                me&Copy,R,n,{ball:9,Lines:3,ov:8};
            st.y [k+'ed'] = n;
            me&fixstringn,st;
            
            # puts .5 of Wind, now we know our %ha (dige)
            $Wi = ny&Wind
            if (Wi) {
                $fi = G&Cye,[n.t,1];
                fis&ha = sts&dige;
                $sW = fio(fi,'W');
                each kv Wi {
                    fio(sW,[k,1,{},{W:k,ha:v}]);
                }
                $fis = sty&fiver = 
                    me&Copy,R,fi,{ball:9,Lines:3,ov:8};
                sty&fivestring = me&fixstringn,fis;
            }
        }
        return st
    };
    # no trailing \n from Lines?
    # < fix everywhere (entire Storage migration?)
    me.fixstringn = &acgt,st{
        !sts&string and throw "!string"
        sts&string.substr(-1) != "\n" and sts&string += "\n"
        sts&dige = dig(sts&string);
        return sts&string
    };
    },
]};
